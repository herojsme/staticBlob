<!DOCTYPE html><!--hJpZ9_1FZihJr8kZsrHcw--><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/assets/blog/authors/jj.jpeg" as="image"/><link rel="stylesheet" href="/staticBlob/_next/static/chunks/4e9cac203c4a1bb6.css" data-precedence="next"/><link rel="stylesheet" href="/staticBlob/_next/static/chunks/4f1026ea77de124d.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/staticBlob/_next/static/chunks/e40cdc54537c3204.js"/><script src="/staticBlob/_next/static/chunks/61877be1a9e85b2b.js" async=""></script><script src="/staticBlob/_next/static/chunks/8502bdbd5656fde4.js" async=""></script><script src="/staticBlob/_next/static/chunks/f6699b053f5410f0.js" async=""></script><script src="/staticBlob/_next/static/chunks/turbopack-9c7693fe172c833f.js" async=""></script><script src="/staticBlob/_next/static/chunks/476073a848cd7881.js" async=""></script><script src="/staticBlob/_next/static/chunks/fec5ea6183d0e55b.js" async=""></script><script src="/staticBlob/_next/static/chunks/3b60e5197848a126.js" async=""></script><script src="/staticBlob/_next/static/chunks/1a1cfcf10bcd6f78.js" async=""></script><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><title>C#笔记 | Next.js Blog Example with Markdown</title><meta name="description" content="A statically generated blog example using Next.js and Markdown."/><meta property="og:title" content="C#笔记 | Next.js Blog Example with Markdown"/><meta property="og:description" content="A statically generated blog example using Next.js and Markdown."/><meta property="og:image" content="http://localhost:3000/assets/blog/dynamic-routing/cover.jpg"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="C#笔记 | Next.js Blog Example with Markdown"/><meta name="twitter:description" content="A statically generated blog example using Next.js and Markdown."/><meta name="twitter:image" content="http://localhost:3000/assets/blog/dynamic-routing/cover.jpg"/><script src="/staticBlob/_next/static/chunks/a6dad97d9634a72d.js" noModule=""></script></head><body class="dark:bg-slate-900 dark:text-slate-400"><div hidden=""><!--$--><!--/$--></div><script>(a=>{let[b,c,d]=["system","dark","light"],e=matchMedia(`(prefers-color-scheme: ${c})`);window.updateDOM=()=>{let f,g=((f=document.createElement("style")).textContent="*,*:after,*:before{transition:none !important;}",document.head.appendChild(f),()=>{getComputedStyle(document.body),setTimeout(()=>document.head.removeChild(f),1)}),h=localStorage.getItem(a)??b,i=e.matches?c:d,j=h===b?i:h,k=document.documentElement.classList;j===c?k.add(c):k.remove(c),document.documentElement.setAttribute("data-mode",h),g()},window.updateDOM(),e.addEventListener("change",window.updateDOM)})('nextjs-blog-starter-theme')</script><button class="switch-module__DSibBW__switch"></button><div class="min-h-screen"><main><div class="border-b dark:bg-slate-800 bg-neutral-50 border-neutral-200"><div class="container mx-auto px-5"><div class="py-2 text-center text-sm">The source code for this blog is<!-- --> <a href="https://github.com/vercel/next.js/tree/canary/examples/blog-starter" class="underline hover:text-blue-600 duration-200 transition-colors">available on GitHub</a>.</div></div></div><div class="container mx-auto px-5"><aside class="-ml-[8px] mb-16 tracking-tight"><div class="lg:sticky lg:top-20"><nav class="flex flex-row items-start relative px-0 pb-0 fade md:overflow-auto scroll-pr-6 md:relative" id="nav"><div class="flex flex-row space-x-0 pr-10"><a class="transition-all hover:text-neutral-800 dark:hover:text-neutral-200 flex align-middle relative py-1 px-2 m-1 text-2xl" href="/">首页</a><a class="transition-all hover:text-neutral-800 dark:hover:text-neutral-200 flex align-middle relative py-1 px-2 m-1 text-2xl" href="/blog">博客</a><a class="transition-all hover:text-neutral-800 dark:hover:text-neutral-200 flex align-middle relative py-1 px-2 m-1 text-2xl" href="https://vercel.com/templates/next.js/portfolio-starter-kit">部署</a></div></nav></div></aside><h2 class="text-2xl md:text-4xl font-bold tracking-tight md:tracking-tighter leading-tight mb-20 mt-8 flex items-center"><a class="hover:underline" href="/">Blog</a>.</h2><article class="mb-32"><h1 class="text-5xl md:text-7xl lg:text-8xl font-bold tracking-tighter leading-tight md:leading-none mb-12 text-center md:text-left">C#笔记</h1><div class="hidden md:block md:mb-12"><div class="flex items-center"><img src="/assets/blog/authors/jj.jpeg" class="w-12 h-12 rounded-full mr-4" alt="JJ Kasper"/><div class="text-xl font-bold">JJ Kasper</div></div></div><div class="mb-8 md:mb-16 sm:mx-0"><div class="sm:mx-0"><img alt="Cover Image for C#笔记" loading="lazy" width="1300" height="630" decoding="async" data-nimg="1" class="shadow-sm w-full" style="color:transparent" srcSet="/staticBlob/assets/blog/dynamic-routing/cover.jpg 1x, /staticBlob/assets/blog/dynamic-routing/cover.jpg 2x" src="/staticBlob/assets/blog/dynamic-routing/cover.jpg"/></div></div><div class="max-w-2xl mx-auto"><div class="block md:hidden mb-6"><div class="flex items-center"><img src="/assets/blog/authors/jj.jpeg" class="w-12 h-12 rounded-full mr-4" alt="JJ Kasper"/><div class="text-xl font-bold">JJ Kasper</div></div></div><div class="mb-6 text-lg"><time dateTime="2020-03-16T05:35:07.322Z">March	16, 2020</time></div></div><div class="max-w-2xl mx-auto"><div class="markdown-styles-module__3QwRAG__markdown"><p>笔记.</p>
<h1><strong>C# 总结</strong></h1>
<hr>
<h2>基础</h2>
<h3>visual studio 2022</h3>
<ul>
<li>
<pre><code>https://visualstudio.microsoft.com/zh-hans/vs/
</code></pre>
</li>
<li>安装 配置 基础信息  ildasm反编译工具</li>
<li>
<pre><code>创建项目后生成一个文件夹中各个文件的含义：
</code></pre>
.sln--解决方案文件   .csproj-项目文件    .cs--源文件   .config-配置文件   bin文件夹--可执行文件exe
obj--中间目标文件   Properties文件夹--程序集信息文件AssemblyInfo.cs</li>
</ul>
<h4>vs2022常用快捷键</h4>
<p>shift+tab	tab		shift+up/down 			ctrt+d			shift+ctrl+l		alt+up/down			ctrl+k+d</p>
<p>反编译 ildasm</p>
<h3>.net 组成部分</h3>
<h4>.net 与.netframwork</h4>
<p>​	.net是微软公司开发的跨平台、多编程语言的软件开发框架</p>
<p>​	.netframwork是.net的一部分</p>
<h4>.netframwork：</h4>
<ol>
<li>
<p>类库</p>
<ol>
<li>框架类库FCL（FrameWork Class language）</li>
<li>基础类库 BCL （Base Class Library）包含我们在程序中用到的核心功能：命名空间、类、枚举、集合、文件io、线程、进程、反射、网络等</li>
</ol>
</li>
<li>
<p>公共语言运行时CLR  (Common Language Runtime)、</p>
<p>微软中间语言MSIL  (Microsoft intermediate Language)：</p>
<ol>
<li>实时编译 JIT （Just-In-Time）</li>
<li>垃圾回收 GC （<strong>Garbage Collection</strong>）</li>
<li>异常处理</li>
<li>内存管理</li>
<li>跨语言调试（为什么能做到，中间语言也有自己的规范：）
<ul>
<li>CTS:Common Type System:通用类型系统->解决不同语言的数据类型问题</li>
<li>CLS:Common Language Specification:公共语言规范->解决不同语言的语法规范问题</li>
</ul>
</li>
</ol>
</li>
</ol>
<p>​</p>
<p>![netframwork构成](D:\project\视觉\笔记\01 C#\netframwork构成.png)</p>
<p>![程序运行机制](D:\project\视觉\笔记\01 C#\程序运行机制.png)</p>
<h3><strong>C# 编译过程流程图</strong></h3>
<pre><code class="language-mermaid">flowchart TD
    A[编写 C# 源代码] --> B[C# 编译器 csc]
    B --> C[生成中间语言 IL]
    C --> D[生成程序集 .exe 或 .dll]
    D --> E[CLR 加载程序集]
    E --> F[JIT 编译 IL 为本机代码]
    F --> G[执行机器码]
</code></pre>
<hr>
<h2><strong>1. 基础语法</strong></h2>
<h3><strong>1.1 变量与数据类型</strong></h3>
<h4>变量三要素：</h4>
<p>​	定义、赋值、使用</p>
<h4>变量分类：</h4>
<p>​	内存有四个区：堆、栈、静态区、常量区</p>
<h5><strong>数值型</strong>：在栈中</h5>
<p>栈中存的是简单数据</p>
<ul>
<li>
<p>整型数值：</p>
<ul>
<li>
<p><strong>有符号：有正数、负数</strong></p>
<p>sbyte(8位/1字节);  	short(16位/2字节);  	int(32位/4字节);   	long(64位/8个字节)</p>
</li>
<li>
<p>无符号：<strong>只有有正数</strong></p>
<p>byte(8位/1字节); 	ushort(16位/2字节）	uint(32位/4字节) 	ulong(64位/8个字节</p>
</li>
</ul>
</li>
<li>
<p>浮点型数值：</p>
<p>​	float(32位/4字节)			单精度;</p>
<p>​	double(64位/8字节)		   双精度;</p>
<p>​	decimal(128位/16字节) 	    高精度适合财务计算;</p>
</li>
<li>
<p>bool布尔，(8位/1字节);  char字符(16位/2字节);</p>
</li>
<li>
<p>enum枚举,默认底层类型是 <code>int</code>;  可以通过显式指定底层类型来改变 <code>enum</code> 的大小</p>
</li>
<li>
<p>struct结构体, 其大小取决于它的字段类型和内存对齐规则。</p>
</li>
</ul>
<h5><strong>引用类型</strong>：在堆中</h5>
<p>堆中存的是复杂数据</p>
<ul>
<li>class 类 	  		  array 数组		delegate 委托</li>
<li>interface 接口	 	string 字符串    	dynamic 动态类</li>
</ul>
<h5><strong>隐式转换、变量常量</strong>：</h5>
<ul>
<li>显示声明  int a=12;</li>
<li>隐式声明  var a=12;</li>
<li>常量 const string str = "string";</li>
</ul>
<h5><strong>二进制、字节位数</strong>：</h5>
<h6>字节</h6>
<ol>
<li>最小计算机存储单位为字节(bit)，一个字节有八位如（00000001）</li>
<li>汉字两个字节，16位。</li>
<li>sizeof()//获取字节数</li>
<li>位数是相对二进制来说的</li>
</ol>
<h6>进制转换</h6>
<p>Convert.ToString() 可以快速转换   BitCovert 字节转换</p>
<pre><code>二进制 ↔ 八进制     3位&#x3C;->1位
二进制 ↔ 十六进制   4位&#x3C;->1位
二进制 ↔ 十进制   每个位数的结果相加
</code></pre>
<h3><strong>1.2 运算符</strong></h3>
<ul>
<li><strong>算术运算符</strong>：<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code></li>
<li><strong>比较运算符</strong>：<code>==</code>, <code>!=</code>, <code>></code>, <code>&#x3C;</code>, <code>>=</code>, <code>&#x3C;=</code></li>
<li><strong>逻辑运算符</strong>：<code>&#x26;&#x26;条件与</code>, <code>||条件或</code>, <code>!逻辑非</code>，<code>&#x26; 逻辑与 AND</code>,<code>^逻辑异或</code>,<code>|逻辑或 OR </code></li>
<li><strong>赋值运算符</strong>：<code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code></li>
<li>++  --  区分前++ 后++ 的区别   --一样，前++先运算再取值，后++ 先取值后运算</li>
<li>null 与布尔值逻辑运算
<ul>
<li>| x     | y     | x&#x26;y   | x|y |
| ----- | ----- | ----- | ---- |
| true  | null  | null  | true |
| false | null  | false | null |
| null  | true  | null  | true |
| null  | flase | false | null |</li>
</ul>
</li>
</ul>
<h3><strong>1.3 字符串</strong></h3>
<ul>
<li><strong>注意</strong>：尽管 string 为引用类型，但是定义相等运算符 == 和 != 是为了比较 string 对象（而不是引用）的值。</li>
<li>转义  \</li>
<li>拼接方式：
<pre><code class="language-csharp">  //1. 字符串内插 {&#x3C;interpolationExpression 结果的表达式>[,&#x3C;alignment 正数是右对齐；负数左对齐>][:&#x3C;formatString 格式化方式>]}
  //2. @ 逐字字符串文本
  //3. """
</code></pre>
</li>
<li>跟StringBuilder区别：string会生成一个新的内存存储，StringBuilder是在堆上修改。</li>
</ul>
<h3><strong>1.4 流程、分支、循环语句</strong></h3>
<ul>
<li>
<p><strong>条件语句</strong>：</p>
<pre><code class="language-csharp">//1.if else 	2. if elseif else 	3.switch case
if (age > 18)
{
    Console.WriteLine("Adult");
}
else
{
    Console.WriteLine("Teenager");
}
</code></pre>
</li>
<li>
<p><strong>循环语句</strong>：</p>
<pre><code class="language-csharp">//1.for  2.foreach   3.while	4.do while
//await foreach
//continue  break  return goto语句将控制权转交给带有标签的语句

for(int i=0;i&#x3C;length;i++){if(a==b){goto Found;}}
Found:
	Console.Write("2322")

int a=0;
while(a&#x3C;9){ 
  a++
}

switch(xx){ case "":xx break;  default:break;}
</code></pre>
</li>
</ul>
<h3><strong>1.5 方法</strong></h3>
<h4>1. 方法定义</h4>
<ul>
<li>访问修饰符  public private  protect</li>
<li>返回类型：值类型、引用类型、void 无返回值类型</li>
</ul>
<pre><code class="language-C#">访问权限 返回值类型 方法名(形参列表)
{
	方法体语句;
}

class Count{
    public static int Add(int a, int b)
	{
		return a + b;
	}
 	public static int Other(int a, int b,params int[] c)
	{
		
	}
    
    // 乱写的案例
    public static void Test(){
        int a=1;
        int b=2;
        Add(a,b);
		Add(ref a,ref b);
        Add(out int 3,out int 5)
        Other(a,b,4,5,6);
        Other(a,b,new int[]{7,8,9});
    }
}
</code></pre>
<h4>2.形参ref、out、params：</h4>
<p>​	ref(引用传递)、 out(返回多个值)、 params(可变参数)、 默认参数(用=传递)</p>
<h4>3. 重载</h4>
<p><strong>方法重载就是：方法的名称一样，但是方法签名不同</strong>。</p>
<p>方法签名由两部分组成：1.方法的形参列表 2.方法的名称</p>
<p>如果方法名一致，只要方法的形参列表不完全一致，编译器就会认为这是不同的方法签名。编译器会根 据输入的参数去调用不同方法</p>
<h5>3.1 普通重载：</h5>
<pre><code class="language-C#">class Count{
    public static int Add(int a, int b)
	{
		return a + b;
	}
	public static int Add(string a, string b)
	{
		return Convert.ToInt32(a) + Convert.ToInt32(b);
	}
    
    public static void Test(){
        Add(1,2)
		Add("1","2")
    }
}
</code></pre>
<h5>3.2 运算符重载 operator：</h5>
<pre><code class="language-C#">class Point{
	public double X { get; set; }
	public double Y { get; set; }
	public Point(double x, double y)
	{
		X = x;
		Y = y;
	}

    public static Point operator +(Point point1, Point point2){
		return new Point(point1.X + point2.X, point1.Y + point2.Y);
	}
}


...
Point point1 = new Point(1, 2);
Point point2 = new Point(3, 4);
//调用运算符重载：+
Point point3 = point1 + point2;
...  
</code></pre>
<h6>3.2-1注意点：</h6>
<p>可以重载的运算符</p>
<ul>
<li>算术运算符 | + 、 - 、 * 、 / 、 ++ 、 --   |</li>
<li>关系运算符 | > 、 &#x3C; 、 >= 、 &#x3C;= 、 == 、 != |</li>
<li>逻辑运算符 | &#x26; 、|、！、^                   |</li>
<li>位运算符   | ~                               |</li>
</ul>
<ol>
<li>.不可以被重载运算符有:赋值运算符[ = ],逻辑运算符中的[ &#x26;&#x26; 、 || ]</li>
<li>关系运算符如果想重载，那么必须要<strong>成对的重载</strong>，例如重载了 > ，则必须重载 &#x3C;；有==就一定要有!=</li>
</ol>
<h4>4.递归：</h4>
<p>自己调用自己，记得退出条件</p>
<hr>
<h2><strong>2 各种数据操作</strong></h2>
<h3><strong>2.1 String常用函数</strong></h3>
<ul>
<li>Length 获取字符串长度</li>
<li><code>+</code>  连接字符串     <code>+</code>多次拼接效率低，大文本用<code>StringBuilder</code></li>
<li>public char this[int index] { get; }  直接用索引获取字符</li>
<li>Substring(int start, [int length])  截取字符串</li>
<li>Split(params char[]) 分割 分隔符分割为字符串数组</li>
<li>String.Join(string separator, IEnumerable) 联结 常用于数组转字符串</li>
<li>Replace(old, new) 替换字符串内容 <strong>区分大小写</strong></li>
<li><code>String.Format(string format, params object[] args)</code>(静态)  | 格式化字符串 使用<code>{0:C}</code>等占位符</li>
<li><code>Trim()</code> / <code>TrimStart()</code> / <code>TrimEnd()</code>  去空格 去除首尾空白字符</li>
<li><code>Contains(string)</code> 包含 判断是否包含子串</li>
<li><code>StartsWith</code> / <code>EndsWith</code> 查找开头/结尾匹配</li>
<li>Compare()/ Equals()  比较  参数规则都很多</li>
<li><code>IndexOf</code> / <code>LastIndexOf</code> 查找字符/子串位置           未找到时返回-1</li>
<li><code>ToUpper()</code> / <code>ToLower()</code> 转全大写/全小写</li>
<li><code>ToString()</code>  类型转换 转为字符串（所有类型通用）</li>
<li>String.IsNullOrEmpty(String)  是否为null或空</li>
<li>String.IsNullOrWhiteSpace(String)  是否为null或空格</li>
</ul>
<h3>2.2 StringBuilder</h3>
<ul>
<li>Append 添加字符串</li>
<li>Insert 插入字符串</li>
<li>Remove  移除字符串</li>
<li>Replace 替换字符串</li>
<li>Clear 清空</li>
<li>Equals 比较</li>
<li>ToString 转换为String</li>
</ul>
<h3><strong>2.3  enum 枚举</strong></h3>
<ul>
<li>GetValues() 列举元素</li>
<li>GetNames() 列举名称</li>
<li>其他转换如下：</li>
</ul>
<pre><code class="language-csharp">public enum Weak{一,二,三,四,五,六,日}
//取值
Weak day = 周.二;
Console.WriteLine(day);

// 遍历
foreach (Weak i in Enum.GetValues(typeof(Weak))){Console.WriteLine(i);}
foreach (string i in Enum.GetNames(typeof(Weak))){Console.WriteLine(i);}
for (int i = 0; i &#x3C; 7; i++){
     Weak dayofWeek = (Weak)i;
     Console.WriteLine(dayofWeek);
 }

//枚举转字符串
string dayOfWeek2 = day.ToString();
Console.WriteLine(dayOfWeek2);

//字符串转枚举
string dayofWeek2 = "四";
Weak dayOfWeek4 = (Weak)Enum.Parse(typeof(Weak), dayOfWeek2);
Console.WriteLine(dayofWeek2);
</code></pre>
<h3><strong>2.4 struct 结构体</strong></h3>
<ol>
<li>结构体是值类型  用struct修饰 ，类是引用类型  用class修饰</li>
<li>结构体中的成员（字段，属性）在定义的时候不能直接赋值(常量除外)，类的成员在定义的时候是可以直接赋值的</li>
<li>结构体也有一个默认无参构造方法，但是这个构造方法不能被覆盖的，你在定义结构体的构造方法的时候必须是有参的，而且必须全部对结构体的字段和属性赋值，类的默认无参构造方法是可以被覆盖的</li>
<li>结构体在定义的变量的时候，你如果访问的是字段，你可以直接定义变量后调用。如果其它成员最好new<br>
当你new的时候，还是栈中开启内存，并且调用结构体的构造方法 ，类实例化必须new 堆中开启</li>
<li>结构体不能有析构方法</li>
<li>结构体是不能继承结构体的，结构体不能继承类，但是可以继承接口（多个接口），类可以继承类，类不能继承结构体，类可以继承接口（多个）</li>
<li>partial同样可以修饰结构体 sealed不能修饰结构体，static不能修饰结构体但是可以修饰结构体成员</li>
<li>结构体变量作为索引器或者属性的时候，不能对成员直接赋值</li>
</ol>
<pre><code class="language-csharp">public struct Person
{
    public string _name;
    public int _age{get;set;};
    public void _print(){Console.WriteLine("haha")};
}

Person p1 = new Person();
p1._name = "张三";
p1._age = 18;
p1._print();
</code></pre>
<h3><strong>2.5 日期与时间操作 (System.DateTime)</strong></h3>
<ul>
<li><code>DateTime.Now</code>  获取当前时间</li>
<li><code>DateTime.Parse(string)</code>   解析时间</li>
<li><code>ToString("yyyy-MM-dd HH:mm:ss")</code> 格式化输出</li>
</ul>
<pre><code class="language-csharp">// 格式化日期时间示例
DateTime now = DateTime.Now;
string timestamp = now.ToString("yyyy-MM-dd HH:mm:ss.fff"); // 带毫秒时间戳

// 计算时间差示例
DateTime start = DateTime.UtcNow;
// （业务操作...）
TimeSpan duration = DateTime.UtcNow - start;
Console.WriteLine($"耗时：{duration.TotalMilliseconds}ms");
</code></pre>
<hr>
<h3><strong>2.6 随机数生成 (System.Random)</strong></h3>
<ul>
<li><code>Random.Next()</code> 生成非负随机整数 （0~<code>Int32.MaxValue-1</code>）</li>
<li><code>Random.Next(maxValue)</code> 生成[0, maxValue)</li>
<li><code>Random.Next(minValue, maxValue)</code> 生成指定区间的整数 包含min，不包含max</li>
</ul>
<pre><code class="language-c#">// 生成6位随机验证码
Random rand = new Random();
string code = rand.Next(100000, 999999).ToString();
</code></pre>
<h3><strong>2.7 数学操作 (System.Math)</strong></h3>
<ul>
<li><code>Abs(x)</code> 绝对值</li>
<li><code>Sign(x)</code>   返回数值符号（-1,0,1）</li>
<li><code>Max(a,b)</code> / <code>Min(a,b)</code>  返回两者较大/较小值</li>
<li><code>Pow(x, y)</code> 计算x的y次方</li>
<li><code>Sqrt(x)</code> 平方根</li>
<li><code>Log(x)</code> / <code>Log10(x)</code>  | 自然对数/以10为底的对数</li>
<li><code>Sin(x)</code> / <code>Cos(x)</code> / <code>Tan(x)</code> | 三角函数计算</li>
<li><code>Asin(x)</code> / <code>Acos(x)</code> / <code>Atan(x)</code> | 反三角函数</li>
<li><code>Round(x, [digits])</code>   | 四舍五入（可指定小数位）</li>
<li><code>Truncate(x)</code>          | 截断小数部分</li>
</ul>
<p><strong>现代数学运算</strong> → 对于复杂计算推荐使用 <code>System.Numerics</code> 命名空间中的类型（如<code>Vector3</code>）</p>
<h3><strong>2.8 数组</strong></h3>
<h4>1 定长数组</h4>
<ul>
<li><code>new T[size]</code>            | 声明固定大小数组</li>
<li><code>Length</code> / <code>GetLength(n)</code> | 获取数组长度/多维长度</li>
<li><code>Copy(Array source, Array dest, int length)</code> | 复制数组元素  可直接内存复制，效率高</li>
<li><code>Reverse()</code>              | 反转数组元素顺序                         | 支持部分区间反转</li>
<li><code>Sort()</code>                 | 数组排序</li>
<li><code>IndexOf</code> / <code>LastIndexOf</code> | 查找元素索引</li>
<li><code>Exists</code> / <code>Find</code> / <code>FindAll</code> (需<code>using System.Collections.Generic</code>) | 条件查找元素              | 使用委托/Predicate</li>
<li><code>ToArray()</code> (LINQ扩展方法) | 其他集合转数组          需引入`System.Linq</li>
</ul>
<pre><code class="language-csharp">int[] A; 
A = new int[3] { 1, 2, 3 };//定义数组长度，并对数组的每一个元素进行赋值

//数组声明:第二种方式
int[] B = new int[3];//定义数组长度，并对数组的每一个元素进行赋值
B[0] = 1;

//数组声明:第三种方式
int[] C = { 1, 2, 3 };

//多维数组
int[,] B = new int[3, 4];

//交错数组
int[][] E = new int[3][] { new int[] { 1, 2, 3 }, new int[] { 4, 5 }, new int[] {
6, 7, 8 } };

//Length 是所有的长度 GetLength
</code></pre>
<h4><strong>2 List&#x3C;T> 泛型数组</strong></h4>
<ul>
<li><strong>添加元素</strong>   | <code>list.Add(4)</code></li>
<li><strong>批量添加</strong>   | <code>list.AddRange(new[] {4, 5})</code></li>
<li><strong>插入元素</strong>   | <code>list.Insert(0, 0) → [0, 1, 2, 3]</code></li>
<li><strong>删除元素</strong>   | <code>list.Remove(3)</code></li>
<li><strong>查找元素</strong>   | <code>list.Exists(x => x > 2)</code><code>list.Find(x => x % 2 == 0)&#x3C;br/> IndexOf FindIndex FindLast FindAll</code> | 条件检查与元素查找</li>
<li><strong>清空</strong>       | <code>list.Clear() </code></li>
<li><strong>排序列表</strong>   | <code>list.Sort() → [1, 2, 3]</code></li>
<li><strong>批量删除</strong>   | <code>list.RemoveAll(x => x > 2)</code></li>
<li><strong>列表转数组</strong> | <code>int[] arr = list.ToArray()</code></li>
<li><strong>切片</strong>       | Slice (int start, int length)</li>
</ul>
<p>常用属性：Capacity获取最大容量、Count获取当前元素个数、this[int Index]通过索引器访问元素</p>
<p>常用方法：Add、AddRange、Clear、Contains、Find、FindAll、IndexOf、Insert、InsertRange、ToArray</p>
<pre><code class="language-csharp">List&#x3C;string> fruits = new List&#x3C;string> { "Apple", "Banana", "Cherry" };
fruits.Add("Orange");
Console.WriteLine(fruits[1]); // 输出 Banana
</code></pre>
<h4><strong>3 ArrayList 集合</strong></h4>
<ul>
<li><strong>容量管理</strong>   | <code>Capacity</code>                          | 获取或设置当前容量（初始默认 <code>4</code>，动态扩容时容量翻倍）。⚠️ 设置过小可能丢失数据，建议优先用 <code>TrimToSize</code>。 |</li>
<li><code>TrimToSize()</code>                      | 将容量压缩到实际元素数量 <code>Count</code>。⚠️ 频繁调用可能降低性能。</li>
<li><strong>元素数量</strong>   | <code>Count</code></li>
<li><strong>添加元素</strong>   | <code>Add(object value)</code>⚠️ 值类型会<strong>装箱</strong>，需注意类型转换异常。</li>
<li><code>AddRange(ICollection c)</code>           | 批量添加集合元素。</li>
<li><code>Insert(int index, object value)</code>   | 在指定位置插入元素。</li>
<li><code>Remove(object value)</code>              | 删除第一个匹配的元</li>
<li><code>RemoveAt(int index)</code>               | 删除指定位置的元素。⚠️ 越界会抛出 <code>ArgumentOutOfRangeException</code>。</li>
<li><code>RemoveRange(int index, int count)</code> | 删除从指定位置开始的连续多个元素。</li>
<li><code>Clear()</code>                           | 清空所有元素（容量 <code>Capacity</code> 保持不变）</li>
<li><code>Contains(object value)</code>            | 判断是否包含元素。</li>
<li><code>IndexOf(object value)</code>             | 返回第一个匹配元素</li>
<li><code>LastIndexOf(object value)</code>         | 返回最后一个匹配元素的索引。</li>
<li><code>Sort()</code>                            | 对所有元素排序（依赖元素的 <code>IComparable</code> 接口）混合类型时可能抛出 <code>InvalidOperationException</code>。</li>
<li><code>Sort(IComparer comparer)</code>          | 使用自定义比较器排序</li>
<li><code>Reverse()</code>                         | 反转所有元素的顺序。</li>
<li><code>this[int index]</code>                   | 通过索引访问或修改元素。</li>
<li><code>ToArray()</code>                         | 转换为 <code>object[]</code> 数组。⚠️ 值类型元素需手动拆箱。</li>
<li><code>ToArray(Type type)</code>                | 转换为指定类型数组（如 <code>ToArray(typeof(int))</code>） 类型错误会抛出 <code>InvalidCastException</code>。</li>
<li><code>Clone()</code>                           | 浅拷贝创建一个新 <code>ArrayList</code>。</li>
</ul>
<p>常用属性：Capacity获取最大容量、Count获取当前元素个数、this[int Index]通过索引器访问元素</p>
<p>常用方法：Add、AddRange、Clear、Insert、Remove、RemoveAt</p>
<pre><code class="language-csharp">List&#x3C;string> fruits = new List&#x3C;string> { "Apple", "Banana", "Cherry" };
fruits.Add("Orange");
Console.WriteLine(fruits[1]); // 输出 Banana
</code></pre>
<h4><strong>4. 各个数组差异比较</strong></h4>
<h5><strong>1. 基本特性比较</strong></h5>
<ul>
<li><strong><code>int[]</code></strong> 数组是固定长度；**<code>List&#x3C;T></code><strong>可以自动扩容；</strong><code>ArrayList</code>**可以自动扩容</li>
<li><strong><code>ArrayList</code><strong>支持任意类型；</strong><code>int[]</code></strong> 、<strong><code>List&#x3C;T></code></strong> 只能约束的类型</li>
<li>都支持linq</li>
<li><strong><code>int[]</code></strong> 性能速度最快，**<code>ArrayList</code>**有装拆箱性能损耗</li>
</ul>
<h3><strong>2.9 Dictionary字典</strong></h3>
<ul>
<li><strong>添加键值对</strong>         | <code>dict.Add("Key", 100)</code><code>dict["Key"] = 100</code></li>
<li><strong>删除键值对</strong>         | <code>dict.Remove("Key")</code></li>
<li><strong>检查包含键/值</strong>      | <code>dict.ContainsKey("Key")</code><code>dict.ContainsValue(100)</code></li>
<li><strong>安全获取值</strong>         | <code>if (dict.TryGetValue("Key", out int val)) { ... }</code></li>
<li><strong>遍历字典</strong>           | <code>foreach (var kvp in dict) { kvp.Key, kvp.Value }</code></li>
<li><strong>字典转列表</strong>         | <code>List&#x3C;string> keys = dict.Keys.ToList();</code></li>
<li><strong>清空字典</strong>           | <code>dict.Clear()</code></li>
</ul>
<pre><code class="language-csharp">Dictionary&#x3C;string, int> ages = new Dictionary&#x3C;string, int>
{
    { "Alice", 25 },
    { "Bob", 30 }
};
Console.WriteLine(ages["Alice"]); // 输出 25
</code></pre>
<hr>
<h3><strong>3.0 队列(Queue)操作</strong></h3>
<ul>
<li><code>Enqueue(T)</code>      | 入队（添加到队尾）</li>
<li><code>Dequeue()</code>       | 移除并返回队首元素  <strong>队列为空时抛异常</strong></li>
<li><code>Peek()</code>          | 查看队首元素但不移除</li>
<li><code>Count</code>           | 获取元素数量</li>
<li><code>Clear()</code>         | 清空队列</li>
<li><code>Contains(T)</code>     | 判断元素是否存在</li>
<li><code>ToArray()</code>       | 将队列转为数组</li>
</ul>
<ol>
<li><strong>集合初始化语法</strong> → <code>Queue&#x3C;int> q = new Queue&#x3C;int>(new[] {1,2,3});</code></li>
<li><strong>数组与集合转换</strong> → 使用LINQ提供的<code>ToList()</code>、<code>ToArray()</code></li>
</ol>
<h3><strong>3.1 栈 Stack&#x3C;T></strong></h3>
<ul>
<li><code>Push(T)</code>         | 入栈（添加到栈顶）</li>
<li><code>Pop()</code>           | 移除并返回栈顶元素                       | <strong>栈为空时抛异常</strong></li>
<li><code>Peek()</code>          | 查看栈顶元素但不移除</li>
<li><code>Count</code>           | 获取元素数量</li>
<li><code>Clear()</code>         | 清空栈</li>
<li><code>Contains(T)</code>     | 判断元素是否存在                         | 效率为O(n)</li>
<li><code>ToArray()</code>       | 将栈转为数组                             | 元素顺序为出栈顺序（倒序）</li>
</ul>
<h2><strong>3. 面向对象编程</strong></h2>
<h3><strong>1 类与对象</strong></h3>
<h4><strong>1.1类的定义</strong>：</h4>
<pre><code class="language-csharp">访问权限 class 类名{
	类成员
}
</code></pre>
<h4>**1.2类的实例化 **：</h4>
<p>实例化的本质，其实一共就干了三件事情:</p>
<ul>
<li>在堆中申请一块内存空间</li>
<li>在这块内存空间按照类的定义进行分配</li>
<li>调用类的构造函数</li>
</ul>
<pre><code class="language-csharp">语法定义格式：
类名 对象名 = new 类名()
Person person = new Person { Name = "Alice", Age = 30 };

在使用new的时候才会去开辟内存空间而且是在堆中申请的，类是引用类型：地址在栈上，内容在堆中。
</code></pre>
<h4>2 构造方法\函数：</h4>
<h5>2.1定义：</h5>
<p>​	在构建对象的时候，会自动调用的方法，所以叫构造方法。<strong>构造方法可以有return也可以没有return，但不能返回值，构造方法时没有返回值的。</strong></p>
<p>​</p>
<h4>3 this的作用：</h4>
<ol>
<li>指向当前类的对象</li>
<li>显式调用另外一个构造函数</li>
</ol>
<pre><code class="language-C#">class Person
{
	public string _name;
	public int _age;
	public string _address;

	public Person():this("小白",18)// 调用其他构造
	{
		Console.WriteLine("我是无参的构造函数：Person()");
	}
	public Person(string name,int age)
	{
		Console.WriteLine("我是有参构造函数：Person(string name,int age)");
		this._name = name;
		this._age = age;
	}
	public Person(string name, int age, string address) : this(name, age)
	{
		Console.WriteLine("我是有参构造函数：Person(string name, int age, string address)");
		_address = address;
	}
}
internal class Program
{
	static void Main(string[] args)
	{
		Person person1 = new Person();
		Person person2 = new Person("嘉嘉",18,"深圳市-龙华");
		Console.ReadKey();
	}
}
</code></pre>
<h4>4 析构方法/析构函数：</h4>
<p>所谓的析构方法就是类对象，生命周期结束时。会自动调用的方法,<strong>在类名前加波浪符号~</strong></p>
<pre><code class="language-C#">public class TEST
{
	public TEST()
	{
		Console.WriteLine("默认无参构造函数");
	}
	~TEST()
	{
		Console.WriteLine("析构函数被调用");
	}
}
internal class Program
{
	static void Main(string[] args)
	{
		TEST test= new TEST();
	//Console.ReadKey();
	}
}
</code></pre>
<h3><strong>2 命名空间</strong></h3>
<p>命名空间就是你要声明的命名空间名字。命名空间整格式是 using 命名空间;</p>
<h4>用法：</h4>
<ol>
<li>同一命名空间下</li>
<li>不同命名空间怎么引入</li>
</ol>
<h3><strong>3 静态非静态</strong></h3>
<h4>static关键字：</h4>
<p>​	修饰属性、方法、类</p>
<p>​	**核心点：**只要是被static所修饰的。<strong>就会在启动的这个程序整个生命周期都是存在的</strong>。会消耗大量的内存，影响程序的性能。</p>
<h4>注意点：</h4>
<ul>
<li>静态方法中只能调用静态的成员，不允许调用非静态的成员</li>
<li>静态构造函数只会被调用一次，在类的静态成员被调用的时候会至多触发一次</li>
<li>如果想在静态方法中调用非静态的字段就必须申请内存(new)，在通过对象访问成员。</li>
<li><strong>静态类中的成员必须全部都是静态成员</strong>。</li>
</ul>
<h3>4 类属性</h3>
<h4>get\set 取值赋值</h4>
<ul>
<li>自动属性：默认都有</li>
</ul>
<pre><code class="language-C#">class Person
{
	public string Name{get;set;}
}
</code></pre>
<ul>
<li>只读、只写</li>
</ul>
<pre><code class="language-C#">class Person
{
	public string Name{get;}//只读
}
class Person
{
	public string Name{set;}//只写
}
</code></pre>
<ul>
<li>
<p>操作：关键字value</p>
<pre><code class="language-C#">class Person
{
	 public string Name
 	{
     	get {
            //....do something
         	return Name;
    	}
     	set
     	{
         	//....do something
        	Name = value;
     	}
 }
}
</code></pre>
</li>
</ul>
<h4>索引器</h4>
<p><strong>语法：</strong></p>
<pre><code>
访问权限 数据类型 this[[索引数据类型] 索引变量]
{
	get
	{
		return 变量;
	}
	set
	{
		变量=value;
	}
}
</code></pre>
<pre><code class="language-C#">class Person
{
    char[] _show = { '就', '是', '有', '这', '种', '操', '作', '!' };
	char[] _infoArray = { '鸡', '你', '太', '美', '！'};

	 public char this[int type,int index] //可以指定任意类型字段
 	{
     	get {
           switch(type){
               case 1:
                  // retrun _show[index]; //也可以做一些判断数组越界之类的
					return index>_show.Length?"获取的数据超出范围": _show[index]
               case 2:
                   retrun _infoArray[index];
           }
    	}
     	set
     	{
         	//....同上面
     	}
 }
}
//用法
Person p1=new Person();
p1[0,1]//取值
p1[1,1]=xxx//赋值
</code></pre>
<h3><strong>5 分布类/部分类</strong></h3>
<h4>关键字partial</h4>
<pre><code class="language-C#">//a 文件
partial class Person
{
	public string Name{
		get { return _name; }
		set { _name = value; }
	}
	public int Age;
}
//b 文件，可以不在不同地方同用一个类
partial class Person
{
	public  void getName(){
        return this._name;
    }
}
</code></pre>
<p>**注意点：**必须在同一命名空间下</p>
<h3><strong>6 类与成员的访问权限、行为修饰符</strong></h3>
<h4><strong>1. 访问修饰符</strong></h4>
<ul>
<li>
<p><strong>类访问权限</strong>
| <strong>修饰符</strong>     | <strong>范围</strong>                                      | <strong>示例</strong>                           |
|----------------|----------------------------------------------|------------------------------------|
| <code>public</code>       | 任何代码均可访问                              | <code>public class MyClass { ... }</code>     |
| <code>internal</code> | 在本项目里面可以访问 | <code>internal class Helper</code>        |</p>
</li>
<li>
<p><strong>类成员访问权限</strong>
| <strong>修饰符</strong>     | <strong>范围</strong>                                      | <strong>示例</strong>                           |
|----------------|----------------------------------------------|------------------------------------|
| <code>public</code>       | 任何代码均可访问                              | public string name; |
| <code>private</code>      | 仅定义该成员的类内部可用（默认类成员修饰符） | private int age; |
| <code>protected</code>    | 类内部及其派生类可用                          | protected string address; |
| <code>internal</code>     | 内部的，仅限于本类访问               | internal string PhoneNumber |
| <code>protected internal</code> | 同一程序集或派生类（逻辑或）            | protected internal string Email; |</p>
</li>
</ul>
<h4><strong>2. 类与成员行为修饰符</strong></h4>
<p>| <strong>修饰符</strong> | <strong>用途</strong>                                   | <strong>示例</strong>                           |
| ---------- | ------------------------------------------ | ---------------------------------- |
| <code>sealed</code>   | 密封类，禁止类被继承或方法被重写           | <code>public sealed class FinalClass</code>   |
| <code>static</code>   | 定义静态类或成员（无需实例化直接调用）     | <code>public static class MathUtils</code>    |
| <code>abstract</code> | 定义抽象类或抽象方法                       | <code>public abstract class BaseModel</code>  |
| <code>virtual</code>  | 允许方法被子类重写                         | <code>public virtual void Calculate()</code>  |
| <code>override</code> | 重写基类虚方法或抽象方法                   | <code>public override void Calculate()</code> |
| <code>new</code>      | 隐藏基类同名成员                           | <code>public new void Execute()</code>        |
| <code>partial</code>  | 拆分类到多个文件（常用于自动生成代码扩展） | <code>public partial class DataModel</code>   |</p>
<h3><strong>7 只读 readonly</strong></h3>
<p>定义类的成员   ---修饰字段（const也是修饰字段）
权限  readonly 类型名字  字段名=值;</p>
<p>对比const:
1 readony修饰在类中，const修饰可以在类中，也可以在main中（修饰局部变量）
2 它们都修饰字段
3 const编译性常量  readonly 运行时常量（推荐使用--性能高点）
4 const修饰的字段定义的时候必须赋初始值，后面不能改。readonly 定义的时候可以赋值也可以不赋值，readonly修饰的字段可以在构造方法中再次修改一次，这里修改了后面就不能修改了
5 readonly可以static修饰的 ，但是如果你定义成静态的readonly，在构造方法初始化的话你必须在静态构造方法中初始化。const是不可以用static修饰</p>
<h3><strong>8 继承（Inheritance）</strong></h3>
<h4><strong>1. 基本概念</strong></h4>
<ul>
<li><strong>继承的本质</strong>：子类（派生类）自动获取父类（基类）的 <strong>字段、方法</strong>（非私有成员），并可扩展或修改行为。</li>
<li><strong>语法</strong>：使用 <code>:</code> 符号声明继承关系。</li>
</ul>
<pre><code class="language-csharp">public class Animal  // 基类
{
    public string Name { get; set; }
    public void Eat() => Console.WriteLine("吃食物");
}

public class Dog : Animal  // 子类继承Animal
{
    public void Bark() => Console.WriteLine("汪汪！");
}

// 使用
var dog = new Dog();
dog.Eat();  // 继承自Animal类的方法
dog.Bark(); // Dog类自身的方法
</code></pre>
<h4><strong>2. 继承链的规则</strong></h4>
<ul>
<li><strong>单根性</strong>：C#不支持类的多继承（一个类只能有一个直接基类）。重点核心</li>
<li><strong>可传递性</strong>：允许链式继承（如 <code>A → B → C</code>），C会有A的共有与受保护成员。</li>
<li><strong>object类</strong>：所有类的隐式基类（最终基类）。</li>
</ul>
<h4><strong>3. 构造函数的执行顺序</strong></h4>
<h5>3.1 实例化子类的本质</h5>
<p>基类构造函数优先执行（默认调用无参构造函数），也就是说会先构造父类然后才到子类。</p>
<h5>3.2 base的两个作用：</h5>
<p><strong>1调用父类中的构造方法、2调用了父类的方法</strong></p>
<pre><code class="language-csharp">public class Animal 
{
    public Animal(string name) => Name = name;
    public void Print(){Console.WriteLine("Animal")}
}

public class Dog : Animal 
{
    public Dog(string name, string breed) : base(name) // 1 传递name到基类构造函数
    {
        Breed = breed;
    }
    public void Print(){base.Print();};//2 调用了父类的方法
}
</code></pre>
<h4>4.<strong>里氏转换</strong></h4>
<p>如下面的例子：</p>
<pre><code class="language-C#">class Friut{}
class Apple:Friut{
	public void AppleEat(){
        Console.WriteLine("我是苹果的吃法！");
    }
}
class Banana:Friut{
	public void BananaEat(){
        Console.WriteLine("我是香蕉的吃法！");
    }
}
</code></pre>
<h5>普通写法与里氏转换：</h5>
<p>里氏转换：<strong>父类可以装上一个子类对象，从而提高程序的拓展性</strong></p>
<pre><code class="language-C#">//正常写法：需要每个子类都声明
Apple a=new Apple();
a.AppleEat();
Banana b=new Banana();
b.BananaEat();

//里氏转换方式
Friut[] friuts={new Apple(),new Banana()};
(Apple(friuts[0])).AppleEat();
(Banana(friuts[1])).BananaEat();
</code></pre>
<h5>is关键字、as关键字</h5>
<p>上面强制转换不优雅，用is或as关键来</p>
<pre><code class="language-C#">foreach (var friut in friuts)
{
   //方式1 is关键字写法，并且赋值变量
   if (friut is Apple a){a.AppleEat();}
   if (friut is Banana b){b.BananaEat();}
    
   //方法2 as写法，as转换类型，如果转换不了就为null
   (friut as Apple)?.AppleEat();
   (friut as Banana)?.BananaEat();
}
</code></pre>
<hr>
<h3><strong>9 多态性（Polymorphism）</strong></h3>
<p><strong>多态性的本质</strong>：实现与拓展不同的功能；子类（派生类）自动获取父类（基类）的 <strong>字段、方法</strong>（非私有成员），它允许将子类对象视为父类对象，从而在运行时确定具体调用哪个类的方法。</p>
<h4><strong>1. 虚方法（Virtual Methods）</strong></h4>
<ul>
<li><strong>用途</strong>：允许子类重写父类方法实现。（<strong>选择性</strong>，可以重写可以不重写）</li>
<li><strong>关键字</strong>：<code>virtual</code>（父类声明方法）+ <code>override</code>（子类重写）。</li>
</ul>
<pre><code class="language-csharp">public class Animal 
{
    public virtual void MakeSound() => Console.WriteLine("默认声音");
}

public class Dog : Animal 
{
    public override void MakeSound() => Console.WriteLine("汪汪！");
}

// 使用多态
Animal animal = new Dog();
animal.MakeSound(); // 输出"汪汪！" （动态绑定）
</code></pre>
<h4><strong>2. 抽象类、抽象方法（Abstract）</strong></h4>
<ul>
<li><strong>抽象类</strong>：不能被实例化，只能作为基类。（<strong>强制性</strong>）</li>
<li><strong>抽象方法</strong>：<strong>仅定义签名，无实现</strong>，必须被子类重写。</li>
</ul>
<pre><code class="language-csharp">public abstract class Shape 
{
    public abstract double GetArea();  // 抽象方法
}

public class Circle : Shape 
{
    public double Radius { get; set; }
    public override double GetArea() => Math.PI * Radius * Radius;
}
</code></pre>
<h4><strong>3. 接口（Interfaces）</strong></h4>
<ul>
<li><strong>与抽象类的区别</strong>：接口只包含方法签名和属性，无实现，支持多重继承。 (<strong>扩展性</strong>)</li>
<li>可以很好的隔离不同类之间的联系，减少类和类之间耦合性</li>
</ul>
<pre><code class="language-csharp">public interface IFlyable 
{
    void Fly();  // 默认隐式为 public
}

public class Bird : Animal, IFlyable  // 多接口继承
{
    public void Fly() => Console.WriteLine("飞行中");
}
</code></pre>
<hr>
<h3><strong>10 类的运算符重载</strong></h3>
<h4>1. 运算符重载</h4>
<p>​	查看方法的运算符重载，一样的。</p>
<h4><strong>2. implicit</strong>隐式转换、explicit显式转换</h4>
<p>下面是一个米--》千米，千米--》米的例子：</p>
<pre><code class="language-C#">public class Meter
{
	public double Value { get; set; }
	public Meter(double value){Value = value;}
	//定义从Meter到Kilometer的隐式转换
    public static implicit operator Kilometer(Meter meter){
		return new Kilometer(meter.Value/1000.0);
	}
    //定义从Meter到Kilometer的显式转换
    public static explicit operator Kilometer(Meter meter){
		return new Kilometer(meter.Value/1000.0);
	}
}

public class KiloMeter
{
	public double Value { get; set; }
	public Meter(double value){Value = value;}
	//定义从Meter到Kilometer的隐式转换
    public static implicit operator Kilometer(Meter meter){
		return new Kilometer(meter.Value/1000.0);
	}
    //定义从Meter到Kilometer的显式转换
    public static explicit operator Kilometer(Meter meter){
		return new Kilometer(meter.Value/1000.0);
	}
}

Meter m=new Meter(1000);
KiloMeter km=m;// 隐式转换
KiloMeter km=(KiloMeter)m;// 显式转换

KiloMeter km=new KiloMeter(1);
Meter m=km;// 隐式转换
Meter m=(Meter)km;// 显式转换
</code></pre>
<hr>
<h3><strong>11 装箱拆箱、泛型</strong></h3>
<h4>1.装箱拆箱</h4>
<p>所有类型的基类是object，也就是说object类可以转任意类型；
装箱: 将值类型转换为引用类型；拆箱: 将引用类型转换为值类型</p>
<pre><code class="language-C#">//引用类型
object obj = null;
//值类型
int num = 10;
//装箱： 将值类型转换为引用类型
obj = num;
Console.WriteLine("装箱:" + obj);

//引用类型
object obj2 = 20;
//值类型
int num2;
//拆箱： 将引用类型转换为值类型
 num2 = (int)obj2;
Console.WriteLine("拆箱:" + num2);

</code></pre>
<h5>装拆箱的问题：</h5>
<p>性能损耗太严重</p>
<pre><code class="language-C#">object[] objArray = new object[100000000];
int[] intArray = new int[100000000];
Stopwatch sw = new Stopwatch();
sw.Start(); 
object obj = 1;
for (int i = 0; i &#x3C; intArray.Length; i++)
{
    intArray[i] = (int)obj;//拆箱
}
sw.Stop();
Console.WriteLine("共消耗:{0}",sw.Elapsed);
</code></pre>
<h4>2.泛型</h4>
<p>频繁装箱拆箱操作太损耗性能。但有些地方却又不能提前声明类型，这需要泛型。泛型可以把类型延迟到使用的时候注入。</p>
<h5>泛型约束</h5>
<p>泛型约束（where T : constraint）中的约束类型必须是接口、非密封类或者另一个类型参数.</p>
<pre><code class="language-C#">class MyClass&#x3C;T> where T : struct 
{
    // T 必须是值类型,只能限制到struct 这一层 
    //int、string、float、double些是密封类（通过使用sealed关键字），这意味着它不能被继承，因此不能被用作泛型约束
}

</code></pre>
<pre><code class="language-C#">class TestClass&#x3C;T, P>where T : class, new() where P : struct
 {
     public void Show(T t, P p)
     {
         Console.WriteLine("Hello, " + t.ToString() + " " + p.ToString());
     }
 }
</code></pre>
<h5>常用的约束：</h5>
<ol>
<li><strong>类型约束</strong>（<code>where T : MyBaseClass</code>）</li>
<li><strong>接口约束</strong>（<code>where T : IMyInterface</code>）</li>
<li><strong>值类型约束</strong>（<code>where T : struct</code>）</li>
<li><strong>引用类型约束</strong>（<code>where T : class</code>）</li>
<li><strong>无参构造函数约束</strong>（<code>where T : new()</code>）</li>
<li><strong>多种约束</strong>（<code>where T : MyBaseClass, IMyInterface, new()</code>）</li>
</ol>
<h4>3 协变out、逆变in</h4>
<p><strong>协变：IFoo&#x3C;父类> = IFoo&#x3C;子类>；</strong> 本该** 输出** 传父类的地方传子类,** out 关键字**
<strong>逆变：IBar&#x3C;子类> = IBar&#x3C;父类>；<strong>本该</strong> 输入</strong> 传子类的地方传父类，** in 关键字**</p>
<p><strong>只能针对泛型接口或者委托</strong>，<strong>不能针对泛型类</strong></p>
<pre><code class="language-C#">//协变 out 输出位置
    interface IFoo&#x3C;out T> { T GetName(); }
    class Foo:IFoo&#x3C;string>{
    	public string GetName(){return GetType().Name;}
    }
	....
	IFoo&#x3C;string> fooStr=new Foo();
	IFoo&#x3C;object> fooObj=fooStr;//
	Console.WriteLine(fooObj.GetName());  //因为要输出object类型，实际下会进行隐式转换：(Object)(new Foo().GetName())

//逆变  in  输入位置
    interface IBar&#x3C;in T> { void Print(T Content); }
    class Bar:IBar&#x3C;object>{
    	public void Print(object Content){Console.WriteLine(Content);}
    }
	....
	IBar&#x3C;object> barObj=new Bar();
	IBar&#x3C;string> barStr=barObj;//
	barStr.Print("haha");  //因为要输入object类型，实际下会对输入的字符串进行隐式转换：new Bar().Print((object)("haha"))
</code></pre>
<hr>
<h3><strong>11 关键特性对比与陷阱</strong></h3>
<h4><strong>1. <code>override</code> vs <code>new</code>修饰符</strong></h4>
<ul>
<li><strong><code>override</code></strong>：完全替换基类方法（多态生效）。</li>
<li><strong><code>new</code></strong>：隐藏基类方法（若通过基类引用调用，仍执行基类版本）。</li>
</ul>
<pre><code class="language-csharp">public class Base 
{
    public void Show() => Console.WriteLine("Base");
}

public class Derived : Base 
{
    public new void Show() => Console.WriteLine("Derived"); // 隐藏而非重写
}

// 测试
Base obj = new Derived();
obj.Show(); // 输出"Base" （静态绑定）
</code></pre>
<h4><strong>2. 抽象类 vs 接口</strong></h4>
<p>| <strong>特性</strong>               | <strong>抽象类</strong>                          | <strong>接口</strong>                          |
|------------------------|-------------------------------------|-----------------------------------|
| 实现方法               | 可以包含具体方法                    | 默认无实现（C# 8开始支持默认实现）|
| 成员类型               | 可包含字段、构造函数                | 仅方法、属性、索引器、事件        |
| 多继承                 | 不支持                              | 支持多继承                        |
| 设计侧重点             | “是什么”（Is-a 关系）               | “能做什么”（行为契约）            |</p>
<hr>
<h2><strong>5 异常处理</strong></h2>
<h3>5.1 <strong>捕获异常</strong></h3>
<pre><code class="language-csharp">try
{
    int result = 10 / 0;
}
catch (DivideByZeroException ex)
{
    Console.WriteLine("Error: " + ex.Message);
}
finally
{
    Console.WriteLine("Finally block executed");
}
</code></pre>
<h3>5.2 <strong>抛出异常</strong></h3>
<p><code>throw new ArgumentException("invalid param");</code> 返回指定的异常类型和错误消息。</p>
<h3>5.3 <strong>自定义异常</strong></h3>
<p>自定义异常类（继承 <code>Exception</code>）</p>
<pre><code>`public class MyException : Exception { ... }`
</code></pre>
<hr>
<h2><strong>6 文件操作</strong></h2>
<p><strong>核心命名空间</strong>：</p>
<pre><code class="language-csharp">using System.IO;        // 基础文件操作
using System.Text;      // 编码处理
</code></pre>
<h3>6.1. 文件系统操作</h3>
<h4>6.1.1 File类</h4>
<ul>
<li>常用静态方法
<ul>
<li>
<p>Create/Delete：创建/删除文件</p>
<pre><code class="language-csharp">try
{
    // 创建文件
    string filePath = Path.Combine(Environment.CurrentDirectory, "test.txt");
    using (File.Create(filePath)) { }
    Console.WriteLine($"文件已创建: {filePath}");

    // 删除文件
    if (File.Exists(filePath))
    {
        File.Delete(filePath);
        Console.WriteLine("文件已删除");
    }
}
catch (IOException ex)
{
    Console.WriteLine($"文件操作失败: {ex.Message}");
}
</code></pre>
</li>
<li>
<p>Copy/Move：复制/移动文件</p>
<pre><code class="language-csharp">try
{
    string sourceFile = "source.txt";
    string destFile = "dest.txt";
    string movedFile = "moved.txt";

    // 创建示例文件
    File.WriteAllText(sourceFile, "Hello World!");

    // 复制文件（如果目标存在则覆盖）
    File.Copy(sourceFile, destFile, true);
    Console.WriteLine($"文件已复制到: {destFile}");

    // 移动文件
    File.Move(destFile, movedFile);
    Console.WriteLine($"文件已移动到: {movedFile}");
}
catch (Exception ex)
{
    Console.WriteLine($"操作失败: {ex.Message}");
}
</code></pre>
</li>
<li>
<p>Exists：检查文件是否存在</p>
<pre><code class="language-csharp">string filePath = @"C:\example\test.txt";
if (File.Exists(filePath))
{
    Console.WriteLine("文件存在");
}
else
{
    Console.WriteLine("文件不存在");
}
</code></pre>
</li>
<li>
<p>GetAttributes/SetAttributes：获取/设置文件属性</p>
<pre><code class="language-csharp">try
{
    string filePath = "test.txt";
    
    // 创建文件并设置属性
    using (File.Create(filePath)) { }
    
    // 设置文件属性（只读和隐藏）
    File.SetAttributes(filePath, FileAttributes.ReadOnly | FileAttributes.Hidden);

    // 获取文件属性
    FileAttributes attrs = File.GetAttributes(filePath);
    Console.WriteLine($"文件属性: {attrs}");

    // 检查是否为只读
    bool isReadOnly = (attrs &#x26; FileAttributes.ReadOnly) == FileAttributes.ReadOnly;
    Console.WriteLine($"是否只读: {isReadOnly}");
}
catch (Exception ex)
{
    Console.WriteLine($"属性操作失败: {ex.Message}");
}
</code></pre>
</li>
<li>
<p>ReadAllText/WriteAllText：读取/写入文本文件</p>
<pre><code class="language-csharp">try
{
    string filePath = "test.txt";
    string content = "你好，世界！\nHello, World!";

    // 写入文本（UTF-8编码）
    File.WriteAllText(filePath, content, Encoding.UTF8);
    Console.WriteLine("文本已写入");

    // 读取文本
    string readContent = File.ReadAllText(filePath, Encoding.UTF8);
    Console.WriteLine($"读取的内容:\n{readContent}");
}
catch (Exception ex)
{
    Console.WriteLine($"文本操作失败: {ex.Message}");
}
</code></pre>
</li>
<li>
<p>ReadAllBytes/WriteAllBytes：读取/写入二进制文件</p>
<pre><code class="language-csharp">try
{
    string filePath = "binary.dat";
    
    // 创建示例二进制数据
    byte[] dataToWrite = new byte[] { 0x48, 0x65, 0x6C, 0x6C, 0x6F }; // "Hello" in ASCII

    // 写入二进制数据
    File.WriteAllBytes(filePath, dataToWrite);
    Console.WriteLine("二进制数据已写入");

    // 读取二进制数据
    byte[] dataRead = File.ReadAllBytes(filePath);
    Console.WriteLine($"读取的数据: {BitConverter.ToString(dataRead)}");
}
catch (Exception ex)
{
    Console.WriteLine($"二进制操作失败: {ex.Message}");
}
</code></pre>
</li>
<li>
<p>ReadAllLines/WriteAllLines：按行读取/写入文本</p>
<pre><code class="language-csharp">try
{
    string filePath = "lines.txt";
    string[] linesToWrite = new string[]
    {
        "第一行",
        "第二行",
        "第三行"
    };

    // 写入多行文本
    File.WriteAllLines(filePath, linesToWrite, Encoding.UTF8);
    Console.WriteLine("多行文本已写入");

    // 读取所有行
    string[] linesRead = File.ReadAllLines(filePath, Encoding.UTF8);
    Console.WriteLine("读取的行:");
    foreach (string line in linesRead)
    {
        Console.WriteLine(line);
    }
}
catch (Exception ex)
{
    Console.WriteLine($"行操作失败: {ex.Message}");
}
</code></pre>
</li>
</ul>
</li>
</ul>
<h4>6.1.2 Directory类</h4>
<ul>
<li>
<p>常用静态方法</p>
<ul>
<li>CreateDirectory：创建目录</li>
<li>Delete：删除目录</li>
<li>Exists：检查目录是否存在</li>
<li>GetFiles/GetDirectories：获取文件/子目录列表</li>
<li>Move：移动目录</li>
<li>GetCurrentDirectory/SetCurrentDirectory：获取/设置当前目录</li>
</ul>
<pre><code class="language-csharp">try
{
    // 创建目录
    string dirPath = Path.Combine(Environment.CurrentDirectory, "testDir");
    Directory.CreateDirectory(dirPath);
    Console.WriteLine($"目录已创建: {dirPath}");

    // 创建子目录
    string subDirPath = Path.Combine(dirPath, "subDir");
    Directory.CreateDirectory(subDirPath);
    Console.WriteLine($"子目录已创建: {subDirPath}");

    // 检查目录是否存在
    if (Directory.Exists(dirPath))
    {
        Console.WriteLine("目录存在");

        // 获取目录中的所有文件
        string[] files = Directory.GetFiles(dirPath, "*", SearchOption.AllDirectories);
        Console.WriteLine("目录中的文件:");
        foreach (string file in files)
        {
            Console.WriteLine($"- {Path.GetFileName(file)}");
        }

        // 获取所有子目录
        string[] subdirs = Directory.GetDirectories(dirPath, "*", SearchOption.AllDirectories);
        Console.WriteLine("子目录:");
        foreach (string dir in subdirs)
        {
            Console.WriteLine($"- {Path.GetFileName(dir)}");
        }

        // 移动目录
        string newPath = Path.Combine(Environment.CurrentDirectory, "movedDir");
        if (!Directory.Exists(newPath))
        {
            Directory.Move(dirPath, newPath);
            Console.WriteLine($"目录已移动到: {newPath}");
        }

        // 删除目录（包括其内容）
        Directory.Delete(newPath, true);
        Console.WriteLine("目录已删除");
    }

    // 获取和设置当前目录
    string currentDir = Directory.GetCurrentDirectory();
    Console.WriteLine($"当前目录: {currentDir}");

    // 设置当前目录（谨慎使用）
    Directory.SetCurrentDirectory(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments));
    Console.WriteLine($"当前目录已更改为: {Directory.GetCurrentDirectory()}");
}
catch (Exception ex)
{
    Console.WriteLine($"目录操作失败: {ex.Message}");
}
</code></pre>
</li>
</ul>
<h4>6.1.3 Path类</h4>
<ul>
<li>
<p>路径操作</p>
<ul>
<li>Combine：合并路径</li>
<li>GetDirectoryName：获取目录名</li>
<li>GetFileName：获取文件名</li>
<li>GetExtension：获取扩展名</li>
<li>GetFullPath：获取完整路径</li>
</ul>
<pre><code class="language-csharp">try
{
    // 合并路径示例
    string baseDir = @"C:\Projects";
    string projectName = "MyApp";
    string fileName = "config.json";
    
    // 使用Path.Combine合并路径（推荐方式）
    string fullPath = Path.Combine(baseDir, projectName, fileName);
    Console.WriteLine($"合并后的完整路径: {fullPath}");
    
    // 获取目录名示例
    string directoryName = Path.GetDirectoryName(fullPath);
    Console.WriteLine($"目录名: {directoryName}");
    
    // 获取文件名示例（带扩展名）
    string fileNameWithExt = Path.GetFileName(fullPath);
    Console.WriteLine($"文件名（带扩展名）: {fileNameWithExt}");
    
    // 获取文件名（不带扩展名）
    string fileNameWithoutExt = Path.GetFileNameWithoutExtension(fullPath);
    Console.WriteLine($"文件名（不带扩展名）: {fileNameWithoutExt}");
    
    // 获取扩展名示例
    string extension = Path.GetExtension(fullPath);
    Console.WriteLine($"扩展名: {extension}");
    
    // 获取完整路径示例
    string relativePath = @"..\Logs\app.log";
    string absolutePath = Path.GetFullPath(relativePath);
    Console.WriteLine($"相对路径转完整路径: {absolutePath}");
    
    // 跨平台路径处理示例
    string crossPlatformPath = Path.Combine("usr", "local", "bin");
    Console.WriteLine($"跨平台路径: {crossPlatformPath}");
    
    // 路径规范化示例
    string pathWithDots = @"C:\Projects\..\Documents\MyApp\..\Config";
    string normalizedPath = Path.GetFullPath(pathWithDots);
    Console.WriteLine($"规范化后的路径: {normalizedPath}");
}
catch (Exception ex)
{
    Console.WriteLine($"路径操作失败: {ex.Message}");
}
</code></pre>
</li>
</ul>
<h3>6.2. 流操作</h3>
<h4>6.2.1 Stream抽象类</h4>
<ul>
<li>基本操作
<ul>
<li>Read/Write：读取/写入字节</li>
<li>Seek：移动流位置</li>
<li>Flush：刷新缓冲区</li>
<li>Close/Dispose：关闭/释放资源</li>
</ul>
</li>
</ul>
<pre><code class="language-csharp">// Stream抽象类的基本操作示例
public class StreamDemo
{
    public static void BasicStreamOperations()
    {
        // 创建一个文件流作为示例
        string filePath = "stream_demo.txt";
        using (FileStream stream = new FileStream(filePath, FileMode.Create))
        {
            try
            {
                // 写入数据
                byte[] dataToWrite = Encoding.UTF8.GetBytes("Hello Stream!");
                stream.Write(dataToWrite, 0, dataToWrite.Length);
                
                // 刷新缓冲区，确保数据写入
                stream.Flush();
                
                // 移动到流的开始位置
                stream.Seek(0, SeekOrigin.Begin);
                
                // 读取数据
                byte[] buffer = new byte[100];
                int bytesRead = stream.Read(buffer, 0, buffer.Length);
                string readData = Encoding.UTF8.GetString(buffer, 0, bytesRead);
                Console.WriteLine($"读取的数据: {readData}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"流操作失败: {ex.Message}");
            }
        } // 使用using语句自动调用Dispose，释放资源
    }
}
</code></pre>
<h4>6.2.2 常用Stream类</h4>
<ul>
<li>FileStream：文件流
<ul>
<li>文件读写操作</li>
<li>缓冲区管理</li>
<li>异步操作支持</li>
</ul>
</li>
</ul>
<pre><code class="language-csharp">// FileStream示例：异步文件操作
public class FileStreamDemo
{
    public static async Task FileOperationsAsync()
    {
        string filePath = "filestream_demo.txt";
        using (FileStream fs = new FileStream(filePath, FileMode.Create, FileAccess.ReadWrite, FileShare.None, 4096, true))
        {
            try
            {
                // 异步写入
                byte[] dataToWrite = Encoding.UTF8.GetBytes("异步写入示例数据");
                await fs.WriteAsync(dataToWrite, 0, dataToWrite.Length);
                
                // 异步读取
                fs.Position = 0;
                byte[] buffer = new byte[100];
                int bytesRead = await fs.ReadAsync(buffer, 0, buffer.Length);
                string readData = Encoding.UTF8.GetString(buffer, 0, bytesRead);
                Console.WriteLine($"异步读取的数据: {readData}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"文件流操作失败: {ex.Message}");
            }
        }
    }
}
</code></pre>
<ul>
<li>MemoryStream：内存流
<ul>
<li>内存中的字节操作</li>
<li>临时数据处理</li>
</ul>
</li>
</ul>
<pre><code class="language-csharp">// MemoryStream示例：内存数据处理
public class MemoryStreamDemo
{
    public static void ProcessDataInMemory()
    {
        using (MemoryStream ms = new MemoryStream())
        {
            try
            {
                // 写入数据到内存流
                byte[] data = Encoding.UTF8.GetBytes("Memory Stream Data");
                ms.Write(data, 0, data.Length);
                
                // 获取内存流中的所有数据
                byte[] result = ms.ToArray();
                Console.WriteLine($"内存流数据大小: {result.Length} 字节");
                
                // 重置位置并读取
                ms.Position = 0;
                StreamReader reader = new StreamReader(ms);
                string content = reader.ReadToEnd();
                Console.WriteLine($"读取的内容: {content}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"内存流操作失败: {ex.Message}");
            }
        }
    }
}
</code></pre>
<ul>
<li>NetworkStream：网络流
<ul>
<li>网络通信数据传输</li>
<li>套接字操作</li>
</ul>
</li>
</ul>
<pre><code class="language-csharp">// NetworkStream示例：简单的TCP客户端
public class NetworkStreamDemo
{
    public static async Task NetworkOperationsAsync()
    {
        using (TcpClient client = new TcpClient())
        {
            try
            {
                await client.ConnectAsync("example.com", 80);
                using (NetworkStream stream = client.GetStream())
                {
                    // 发送HTTP GET请求
                    string request = "GET / HTTP/1.1\r\nHost: example.com\r\n\r\n";
                    byte[] requestData = Encoding.ASCII.GetBytes(request);
                    await stream.WriteAsync(requestData, 0, requestData.Length);
                    
                    // 读取响应
                    byte[] buffer = new byte[1024];
                    int bytesRead = await stream.ReadAsync(buffer, 0, buffer.Length);
                    string response = Encoding.ASCII.GetString(buffer, 0, bytesRead);
                    Console.WriteLine($"服务器响应:\n{response}");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"网络流操作失败: {ex.Message}");
            }
        }
    }
}
</code></pre>
<ul>
<li>BufferedStream：缓冲流
<ul>
<li>性能优化</li>
<li>缓冲区管理</li>
</ul>
</li>
</ul>
<pre><code class="language-csharp">// BufferedStream示例：提高读写性能
public class BufferedStreamDemo
{
    public static void BufferedOperations()
    {
        string filePath = "buffered_demo.txt";
        using (FileStream fs = new FileStream(filePath, FileMode.Create))
        using (BufferedStream bs = new BufferedStream(fs, 4096)) // 4KB缓冲区
        {
            try
            {
                // 写入大量数据
                byte[] largeData = new byte[1024 * 1024]; // 1MB数据
                new Random().NextBytes(largeData); // 填充随机数据
                
                // 使用缓冲流写入
                bs.Write(largeData, 0, largeData.Length);
                bs.Flush(); // 确保所有数据都写入底层流
                
                // 重置位置
                bs.Position = 0;
                
                // 使用缓冲流读取
                byte[] readBuffer = new byte[8192];
                int totalBytesRead = 0;
                int bytesRead;
                while ((bytesRead = bs.Read(readBuffer, 0, readBuffer.Length)) > 0)
                {
                    totalBytesRead += bytesRead;
                }
                
                Console.WriteLine($"总共读取: {totalBytesRead} 字节");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"缓冲流操作失败: {ex.Message}");
            }
        }
    }
}
</code></pre>
<ul>
<li>缓冲区管理</li>
</ul>
<h3>6.3. 文本操作</h3>
<h4>6.3.1 文本读写器</h4>
<ul>
<li>StreamReader/StreamWriter
<ul>
<li>文本文件读写</li>
<li>编码设置</li>
<li>缓冲区管理</li>
</ul>
</li>
</ul>
<pre><code class="language-csharp">// StreamReader/StreamWriter示例：文本文件读写操作
public class TextReaderWriterDemo
{
    public static async Task TextFileOperationsAsync()
    {
        string filePath = "text_demo.txt";
        
        // 使用StreamWriter写入文本文件
        using (StreamWriter writer = new StreamWriter(filePath, false, Encoding.UTF8))
        {
            try
            {
                // 写入单行文本
                await writer.WriteLineAsync("第一行：你好，世界！");
                
                // 写入多行文本
                string[] lines = new string[]
                {
                    "第二行：StreamWriter示例",
                    "第三行：支持异步操作",
                    "第四行：自动处理编码"
                };
                
                foreach (string line in lines)
                {
                    await writer.WriteLineAsync(line);
                }
                
                // 写入不带换行符的文本
                await writer.WriteAsync("这是不带换行符的文本");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"写入操作失败: {ex.Message}");
            }
        }
        
        // 使用StreamReader读取文本文件
        using (StreamReader reader = new StreamReader(filePath, Encoding.UTF8))
        {
            try
            {
                // 读取所有文本
                string allText = await reader.ReadToEndAsync();
                Console.WriteLine("读取全部内容：");
                Console.WriteLine(allText);
                
                // 重置流位置
                reader.BaseStream.Seek(0, SeekOrigin.Begin);
                
                // 逐行读取
                Console.WriteLine("\n逐行读取：");
                string line;
                while ((line = await reader.ReadLineAsync()) != null)
                {
                    Console.WriteLine(line);
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"读取操作失败: {ex.Message}");
            }
        }
    }
}
</code></pre>
<ul>
<li>StringReader/StringWriter
<ul>
<li>字符串操作</li>
<li>内存文本处理</li>
</ul>
</li>
</ul>
<pre><code class="language-csharp">// StringReader/StringWriter示例：内存中的字符串操作
public class StringReaderWriterDemo
{
    public static async Task StringOperationsAsync()
    {
        // 使用StringWriter构建字符串
        using (StringWriter writer = new StringWriter())
        {
            try
            {
                // 写入文本
                await writer.WriteLineAsync("StringWriter示例");
                await writer.WriteLineAsync("可以在内存中构建大型文本");
                await writer.WriteAsync("支持异步操作和格式化：");
                await writer.WriteLineAsync($"{DateTime.Now:yyyy-MM-dd}");
                
                // 获取构建的字符串
                string result = writer.ToString();
                Console.WriteLine("StringWriter构建的文本：");
                Console.WriteLine(result);
                
                // 使用StringReader读取文本
                using (StringReader reader = new StringReader(result))
                {
                    Console.WriteLine("\n使用StringReader逐行读取：");
                    string line;
                    while ((line = await reader.ReadLineAsync()) != null)
                    {
                        Console.WriteLine($"读取的行: {line}");
                    }
                    
                    // 重置到开始位置（需要创建新的StringReader）
                    using (StringReader newReader = new StringReader(result))
                    {
                        // 读取指定字符数
                        char[] buffer = new char[10];
                        int charsRead = await newReader.ReadAsync(buffer, 0, buffer.Length);
                        Console.WriteLine($"\n读取前{charsRead}个字符：");
                        Console.WriteLine(new string(buffer, 0, charsRead));
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"字符串操作失败: {ex.Message}");
            }
        }
    }
}
</code></pre>
<h4>6.3.2 编码处理</h4>
<ul>
<li>Encoding类
<ul>
<li>UTF8、Unicode、ASCII等编码</li>
<li>字符集转换</li>
<li>BOM处理</li>
</ul>
</li>
</ul>
<pre><code class="language-csharp">public class EncodingDemo
{
    public static void Main()
    {
        try
        {
            // 1. 基本编码示例
            string text = "Hello 你好 こんにちは";
            
            // UTF8编码
            byte[] utf8Bytes = Encoding.UTF8.GetBytes(text);
            string utf8String = Encoding.UTF8.GetString(utf8Bytes);
            Console.WriteLine($"UTF8编码字节数: {utf8Bytes.Length}");
            
            // Unicode编码
            byte[] unicodeBytes = Encoding.Unicode.GetBytes(text);
            string unicodeString = Encoding.Unicode.GetString(unicodeBytes);
            Console.WriteLine($"Unicode编码字节数: {unicodeBytes.Length}");
            
            // ASCII编码（不支持非ASCII字符）
            byte[] asciiBytes = Encoding.ASCII.GetBytes(text);
            string asciiString = Encoding.ASCII.GetString(asciiBytes);
            Console.WriteLine($"ASCII编码字节数: {asciiBytes.Length}");

            // 2. 字符集转换
            // UTF8转GB2312
            Encoding gb2312 = Encoding.GetEncoding("gb2312");
            byte[] gb2312Bytes = Encoding.Convert(Encoding.UTF8, gb2312, utf8Bytes);
            string gb2312String = gb2312.GetString(gb2312Bytes);
            Console.WriteLine($"GB2312编码结果: {gb2312String}");

            // 3. BOM处理
            string fileName = "test_with_bom.txt";
            
            // 创建带BOM的UTF8文件
            using (var stream = new FileStream(fileName, FileMode.Create))
            using (var writer = new StreamWriter(stream, new UTF8Encoding(true)))
            {
                writer.Write(text);
            }
            
            // 检测文件是否包含BOM
            byte[] fileBytes = File.ReadAllBytes(fileName);
            bool hasBom = fileBytes.Length >= 3 &#x26;&#x26; 
                         fileBytes[0] == 0xEF &#x26;&#x26; 
                         fileBytes[1] == 0xBB &#x26;&#x26; 
                         fileBytes[2] == 0xBF;
            Console.WriteLine($"文件是否包含BOM: {hasBom}");

            // 不带BOM的UTF8编码
            using (var stream = new FileStream("test_without_bom.txt", FileMode.Create))
            using (var writer = new StreamWriter(stream, new UTF8Encoding(false)))
            {
                writer.Write(text);
            }

            // 4. 编码检测
            using (var stream = new FileStream(fileName, FileMode.Open))
            {
                // 创建检测器
                byte[] buffer = new byte[4];
                stream.Read(buffer, 0, 4);

                // 检测编码
                if (buffer[0] == 0xEF &#x26;&#x26; buffer[1] == 0xBB &#x26;&#x26; buffer[2] == 0xBF)
                    Console.WriteLine("检测到UTF8 BOM编码");
                else if (buffer[0] == 0xFF &#x26;&#x26; buffer[1] == 0xFE)
                    Console.WriteLine("检测到UTF16 Little Endian编码");
                else if (buffer[0] == 0xFE &#x26;&#x26; buffer[1] == 0xFF)
                    Console.WriteLine("检测到UTF16 Big Endian编码");
                else
                    Console.WriteLine("未检测到BOM标记");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"编码操作失败: {ex.Message}");
        }
    }
}
</code></pre>
<h3>6.4. 序列化与反序列化</h3>
<h4>6.4.1 二进制序列化</h4>
<ul>
<li>BinaryFormatter
<ul>
<li>对象序列化</li>
<li>性能考虑</li>
<li>安全性注意事项</li>
</ul>
</li>
</ul>
<pre><code class="language-csharp">[Serializable]
public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
    [NonSerialized]
    private string secretData;
}

try
{
    // 创建对象
    var person = new Person { Name = "张三", Age = 25 };
    string filePath = "person.bin";

    // 序列化对象
    using (var fs = new FileStream(filePath, FileMode.Create))
    {
        var formatter = new BinaryFormatter();
        formatter.Serialize(fs, person);
    }
    Console.WriteLine("对象已序列化到文件");

    // 反序列化对象
    using (var fs = new FileStream(filePath, FileMode.Open))
    {
        var formatter = new BinaryFormatter();
        var deserializedPerson = (Person)formatter.Deserialize(fs);
        Console.WriteLine($"反序列化结果: {deserializedPerson.Name}, {deserializedPerson.Age}");
    }
}
catch (Exception ex)
{
    Console.WriteLine($"序列化操作失败: {ex.Message}");
}
</code></pre>
<h4>6.4.2 XML序列化</h4>
<ul>
<li>XmlSerializer
<ul>
<li>XML文档处理</li>
<li>特性标记</li>
<li>自定义序列化</li>
</ul>
</li>
</ul>
<pre><code class="language-csharp">[XmlRoot("Person")]
public class Person
{
    [XmlElement("FullName")]
    public string Name { get; set; }

    [XmlAttribute("age")]
    public int Age { get; set; }

    [XmlIgnore]
    public string TemporaryData { get; set; }
}

try
{
    // 创建对象
    var person = new Person { Name = "李四", Age = 30 };
    string xmlFile = "person.xml";

    // 序列化为XML
    var serializer = new XmlSerializer(typeof(Person));
    using (var writer = new StreamWriter(xmlFile))
    {
        serializer.Serialize(writer, person);
    }
    Console.WriteLine("对象已序列化为XML");

    // 从XML反序列化
    using (var reader = new StreamReader(xmlFile))
    {
        var deserializedPerson = (Person)serializer.Deserialize(reader);
        Console.WriteLine($"从XML反序列化: {deserializedPerson.Name}, {deserializedPerson.Age}");
    }
}
catch (Exception ex)
{
    Console.WriteLine($"XML序列化失败: {ex.Message}");
}
</code></pre>
<h4>6.4.3 JSON序列化</h4>
<ul>
<li>System.Text.Json
<ul>
<li>JSON数据处理</li>
<li>序列化选项</li>
<li>性能优化</li>
</ul>
</li>
</ul>
<pre><code class="language-csharp">public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
    
    [JsonIgnore]
    public string SensitiveInfo { get; set; }
}

try
{
    // 创建对象
    var person = new Person { Name = "王五", Age = 35 };

    // 配置序列化选项
    var options = new JsonSerializerOptions
    {
        WriteIndented = true,
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase
    };

    // 序列化为JSON
    string jsonString = JsonSerializer.Serialize(person, options);
    File.WriteAllText("person.json", jsonString);
    Console.WriteLine($"JSON序列化结果:\n{jsonString}");

    // 从JSON反序列化
    string jsonContent = File.ReadAllText("person.json");
    var deserializedPerson = JsonSerializer.Deserialize&#x3C;Person>(jsonContent, options);
    Console.WriteLine($"从JSON反序列化: {deserializedPerson.Name}, {deserializedPerson.Age}");
}
catch (Exception ex)
{
    Console.WriteLine($"JSON序列化失败: {ex.Message}");
}
</code></pre>
<h4>6.4.4、<strong>第三方库</strong></h4>
<h5><strong>1. 使用 <code>protobuf-net</code> 库</strong></h5>
<ul>
<li><strong>优点</strong>：高效、紧凑、跨语言（需定义协议）。</li>
</ul>
<pre><code class="language-bash"># 安装 NuGet 包：protobuf-net
</code></pre>
<h5><strong>2. 使用 <code>MessagePack-CSharp</code></strong></h5>
<ul>
<li>面向性能敏感场景（如游戏、高频通信）。</li>
</ul>
<pre><code class="language-bash"># 安装 NuGet 包：MessagePack
</code></pre>
<h3>6.5. 异步IO操作</h3>
<h4>6.5.1 异步模式</h4>
<ul>
<li>async/await模式
<ul>
<li>异步文件操作</li>
<li>异步流操作</li>
<li>异步网络IO</li>
</ul>
</li>
</ul>
<pre><code class="language-csharp">// 异步文件操作示例
public class FileOperationExample
{
    public static async Task FileOperationsAsync()
    {
        string filePath = "test.txt";
        string content = "Hello Async World!";

        try
        {
            // 异步写入文件
            await File.WriteAllTextAsync(filePath, content);
            Console.WriteLine("文件异步写入完成");

            // 异步读取文件
            string readContent = await File.ReadAllTextAsync(filePath);
            Console.WriteLine($"异步读取的内容: {readContent}");

            // 使用FileStream进行大文件异步操作
            using var fileStream = new FileStream(filePath, FileMode.Open);
            byte[] buffer = new byte[1024];
            int bytesRead;

            while ((bytesRead = await fileStream.ReadAsync(buffer, 0, buffer.Length)) > 0)
            {
                // 处理读取的数据
                Console.WriteLine($"读取了 {bytesRead} 字节");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"文件操作异常: {ex.Message}");
        }
    }
}

// 异步流操作示例
public class StreamOperationExample
{
    public static async Task StreamCopyAsync()
    {
        string sourceFile = "source.txt";
        string destFile = "destination.txt";

        try
        {
            using var sourceStream = new FileStream(sourceFile, FileMode.Open);
            using var destStream = new FileStream(destFile, FileMode.Create);

            // 异步复制流
            await sourceStream.CopyToAsync(destStream);
            Console.WriteLine("流异步复制完成");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"流操作异常: {ex.Message}");
        }
    }
}

// 异步网络IO示例
public class NetworkIOExample
{
    public static async Task NetworkOperationsAsync()
    {
        try
        {
            using var client = new HttpClient();
            
            // 异步HTTP GET请求
            string url = "https://api.example.com/data";
            string response = await client.GetStringAsync(url);
            Console.WriteLine($"收到响应: {response}");

            // 异步HTTP POST请求
            var content = new StringContent("{\"data\": \"test\"}", Encoding.UTF8, "application/json");
            var postResponse = await client.PostAsync(url, content);
            
            if (postResponse.IsSuccessStatusCode)
            {
                string result = await postResponse.Content.ReadAsStringAsync();
                Console.WriteLine($"POST响应: {result}");
            }
        }
        catch (HttpRequestException ex)
        {
            Console.WriteLine($"网络请求异常: {ex.Message}");
        }
    }
}

// 调用示例
public class Program
{
    public static async Task Main()
    {
        await FileOperationExample.FileOperationsAsync();
        await StreamOperationExample.StreamCopyAsync();
        await NetworkIOExample.NetworkOperationsAsync();
    }
}
</code></pre>
<hr>
<h2><strong>7 委托与事件</strong></h2>
<h3><strong>7.1 委托</strong></h3>
<h4><strong>1. 委托的本质是一种类型</strong></h4>
<p>委托是一种类型--- 方法的类型   引用类型
委托是代表方法的类型，说明委托所定义的变量中存放的是方法</p>
<h4><strong>2. 委托的使用</strong></h4>
<h5><strong>2.1 委托五步法</strong></h5>
<p>​	1.定义委托对象 关键字<strong>delegate</strong>			2.创建需要委托的方法		3.定义委托对象</p>
<p>​	4.委托对象绑定方法		5.调用委托</p>
<pre><code class="language-csharp">public class Program
{
    //1 定义委托对象
    delegate void MyDelegate(string message);
    public static void Main()
    {
        //3 定义委托对象 
        MyDelegate myDelegate = null;
        //4 委托对象绑定方法
        //myDelegate =new MyDelegate(PrintMessage);// 方式1绑定
        myDelegate=PrintMessage;  //方式2绑定

        //5 调用委托
        // myDelegate.Invoke("Hello, Delegate!");//方式1调用
        myDelegate("Hello, Delegate!"); //方式2调用,Invoke省略
    }

    // 2 创建需要委托的方法
    public static void PrintMessage(string message)
    {
        Console.WriteLine(message);
    }
}
</code></pre>
<h5><strong>2.2 多播委托</strong></h5>
<p>一个委托可以绑定多个方法：</p>
<pre><code class="language-csharp">public class Program
{
    public static void Main()
    {
        MyDelegate myDelegate = PrintMessage;
        myDelegate += PrintAnotherMessage; // 绑定第二个方法

        // 调用委托，两个方法都会执行
        myDelegate("Hello, Multicast Delegate!");
    }

    public static void PrintMessage(string message)
    {
        Console.WriteLine("Method 1: " + message);
    }

    public static void PrintAnotherMessage(string message)
    {
        Console.WriteLine("Method 2: " + message);
    }
}
</code></pre>
<h5><strong>2.3 匿名方法和 Lambda 表达式</strong></h5>
<p>可以使用匿名方法或 Lambda 表达式简化委托的定义：</p>
<pre><code class="language-csharp">public class Program
{
    public static void Main()
    {
        // 使用匿名方法
        MyDelegate myDelegate = delegate(string message)
        {
            Console.WriteLine("Anonymous Method: " + message);
        };

        // 使用 Lambda 表达式
        MyDelegate myDelegate2 = (message) => Console.WriteLine("Lambda: " + message);

        myDelegate("Hello!");
        myDelegate2("Hello!");
    }
}
</code></pre>
<h5>2*3.4 同步委托 异步委托**</h5>
<p>同步委托调用是委托执行的默认方式
异步委托调用方式<code>BeginInvoke</code> 和 <code>EndInvoke</code> 方法</p>
<hr>
<h4><strong>3. 内置委托</strong></h4>
<p>C# 提供了几种常用的内置委托，无需手动定义：</p>
<h5><strong>3.1 <code>Action</code></strong></h5>
<p>用于指向无返回值的方法，最高参数有16个：</p>
<pre><code class="language-csharp">Action&#x3C;string> action = (message) => Console.WriteLine(message);
action("Hello, Action!");
</code></pre>
<h5><strong>3.2 <code>Func</code></strong></h5>
<p>用于指向有返回值的方法，最高参数有16个：</p>
<pre><code class="language-csharp">Func&#x3C;int, int, int> add = (a, b) => a + b;
Console.WriteLine(add(2, 3)); // 输出 5
</code></pre>
<h5><strong>3.3 <code>Predicate</code></strong></h5>
<p>用于指向返回 <code>bool</code> 的方法：</p>
<pre><code class="language-csharp">Predicate&#x3C;int> isEven = (num) => num % 2 == 0;
Console.WriteLine(isEven(4)); // 输出 True
</code></pre>
<hr>
<h4><strong>4. 委托的作用</strong></h4>
<ul>
<li>减少代码的冗余，<strong>多播方式</strong>可以处理很多冗余。可以<strong>批量处理</strong>类似但不同的方法，如快速替换。</li>
</ul>
<pre><code class="language-csharp">  public void ProcessData(Action&#x3C;string> callback)
  {
      string result = "Data processed";
      callback(result);
  }
</code></pre>
<ul>
<li>当对象不方便访问的使用委托(窗体传值)。</li>
<li>委托的<strong>回调方式</strong>可以把方法作为实参传递</li>
</ul>
<hr>
<h3><strong>7.2 事件</strong></h3>
<h4>详解：</h4>
<p>发布者（Publisher）：触发事件的对象（例如：按钮点击）。
订阅者（Subscriber）：监听事件并执行处理方法的对象。
**底层依赖：事件基于<em>委托（Delegate）<em>实现，是一种类型安全的回调机制。</em></em>
<strong>外部代码只能通过+=和-=进行订阅/取消订阅，保障数据安全性。</strong>
<strong>仅允许在声明事件的类内部触发事件（.Invoke()或直接调用）。</strong></p>
<h4>事件声明</h4>
<pre><code class="language-csharp">// 标准模式：public event EventHandler EventName;   关键字event
// 使用泛型传递数据：public event EventHandler&#x3C;CustomEventArgs> EventName;
// 触发条件检查 ?.Invoke()避免空引用异常
public class Button
{
    public event EventHandler Click;

    public void OnClick()
    {
        Click?.Invoke(this, EventArgs.Empty);
    }
}

Button button = new Button();
button.Click += (sender, e) => Console.WriteLine("Button clicked!");
button.OnClick();
</code></pre>
<hr>
<h2><strong>8 反射</strong></h2>
<h3>1. 什么是反射？</h3>
<p><strong>反射（Reflection）</strong> 是 C# 中一种强大的机制，它允许程序在运行时<strong>动态获取元数据</strong>【类型信息、创建对象、调用方法或访问属性】。简单来说，反射让程序能够“自省”，即动态地检查和操作程序自身的结构和行为。</p>
<hr>
<h3><strong>2. 反射的用途</strong></h3>
<p>反射在以下场景中非常有用：</p>
<ol>
<li><strong>动态加载程序集</strong>：在运行时加载外部 DLL 文件并调用其中的类型和方法。满足<strong>开闭原则</strong></li>
<li><strong>插件系统</strong>：实现插件架构，动态加载和调用插件。</li>
<li><strong>序列化和反序列化</strong>：在运行时动态读取和写入对象的属性。</li>
<li><strong>单元测试框架</strong>：动态调用测试方法。</li>
<li><strong>依赖注入</strong>：在运行时解析和创建对象实例。</li>
</ol>
<hr>
<h3><strong>3. 反射的基本用法</strong></h3>
<p>反射的核心是通过 <code>System.Reflection</code> 命名空间中的类来实现的，核心类包括<strong>Type</strong>(类型类)、<strong>Activator</strong>(激活类)、<strong>Assembly</strong>(程序集)，方法主要包括 <code>Type</code>、<code>MethodInfo</code>、<code>PropertyInfo</code>、<code>FieldInfo</code> 等。</p>
<h4><strong>3.1 获取类型信息</strong></h4>
<p>通过 <code>typeof</code> 、<code>GetType</code>、<code>Assembly.Load()</code> 获取类型信息：</p>
<pre><code class="language-csharp">Type type = typeof(MyClass); // 获取类型
Type type2 = obj.GetType();  // 通过实例获取类型

//程序集方式 任选一个
1 Assembly assembly =Assembly.Load("MyLibrary") //需要填写程序集的名字  程序集文件须要跟你的exe程序在一个目录下 
2 Assembly assembly =Assembly.LoadFrom("./MyLibrary.dll") //绝对/相对都可以          
3 Assembly assembly =Assembly.LoadFile("D:/MyLibrary.dll")//绝对路径
    
Type type= assembly.GetType("命名空间.类名"); //必须要带全名称   
</code></pre>
<h4><strong>3.2 反射对象</strong></h4>
<pre><code class="language-csharp">object instance = Activator.CreateInstance(type);//无参
object instance =Activator.CreateInstance(type,new object[] {值1,值2})//有参  
object instance =assembly.CreateInstance()//无参构造方法   有参数重载的
</code></pre>
<h4><strong>3.3 反射方法</strong></h4>
<p>通过 <code>GetMethod</code> 获取方法，并通过 <code>Invoke</code> 调用：</p>
<pre><code class="language-csharp">MethodInfo method = type.GetMethod("MyMethod");
method.Invoke(instance, new object[] { "Hello, Reflection!" });
</code></pre>
<h4><strong>3.4 反射属性 获取和设置</strong></h4>
<p>通过 <code>GetProperty</code> 获取属性，并通过 <code>GetValue</code> 和 <code>SetValue</code> 读取或设置值：</p>
<pre><code class="language-csharp">PropertyInfo property = type.GetProperty("MyProperty");
property.SetValue(instance, 42); // 设置属性值
Console.WriteLine(property.GetValue(instance)); // 获取属性值
</code></pre>
<h4><strong>3.5 反射构造函数</strong></h4>
<pre><code class="language-C#">ConstructorInfo constructorInfo= type.GetConstructor(new Type[] { typeof(string) });
constructorInfo.Invoke(new object[] {"我是构造出来的"})   
</code></pre>
<h4><strong>3.6 权限问题</strong></h4>
<p>权限问题---需要设置一个枚举  <code>BindingFlags</code>，比如：
BindingFlags.Instance|BindingFlags.NonPublic         BindingFlags.Static|BindingFlags.NonPublic</p>
<hr>
<h2><strong>9 进程、线程</strong></h2>
<h3>0、进程、线程的关系</h3>
<p>想象一下你在经营一家餐厅的厨房（这就是一个进程），这个厨房是一个独立的工作空间，有自己的灶台、调料、厨具等资源（进程的独立内存空间和资源）。</p>
<p>在这个厨房里：</p>
<ol>
<li>
<p>厨师就是线程</p>
<ul>
<li>一个厨房（进程）可以有多个厨师（线程）同时工作</li>
<li>所有厨师共享这个厨房的资源（线程共享进程的内存空间）</li>
<li>每个厨师有自己的工作台和刀具（线程私有的堆栈空间）</li>
</ul>
</li>
<li>
<p>炒一道菜的过程</p>
<ul>
<li>主厨（主线程）可以分配任务给其他厨师（创建新线程）</li>
<li>一个厨师可以同时看着两个锅（线程并发）</li>
<li>多个厨师可以同时炒不同的菜（多线程并行）</li>
</ul>
</li>
<li>
<p>资源共享和协调</p>
<ul>
<li>厨师们共用同一个调料架（共享资源）</li>
<li>使用同一个灶台时需要互相协调（线程同步）</li>
<li>两个厨师不能同时使用同一个铲子（互斥锁）</li>
</ul>
</li>
<li>
<p>效率和安全</p>
<ul>
<li>多个厨师同时工作可以提高效率（多线程提高性能）</li>
<li>但太多厨师反而会互相干扰（线程过多反而降低性能）</li>
<li>需要协调好使用公共区域的顺序（避免死锁）</li>
</ul>
</li>
<li>
<p>关系类比</p>
<ul>
<li>开一家新餐厅 = 启动新进程</li>
<li>招聘新厨师 = 创建新线程</li>
<li>餐厅关门 = 进程结束（所有厨师都要下班）</li>
<li>厨师下班 = 线程结束（但餐厅可以继续营业）</li>
</ul>
</li>
</ol>
<h3><strong>1. 进程（Process）</strong></h3>
<h4><strong>1.1 基本概念</strong></h4>
<ul>
<li><strong>定义</strong>：操作系统加载运行电脑上的可执行程序（.exe)的基本单元，运行时会在内存中开辟一块内存空间，
把这块内存空间称为进程，也就是说是进行中的程序，为你要运行的程序提供了对应的运行的物理空间</li>
<li><strong>构成</strong>：
<ul>
<li>内核对象    地址空间（用来提供线程运行环境的）</li>
</ul>
</li>
</ul>
<h4>1.2 常用属性与方法</h4>
<p>常用属性：</p>
<p>| <strong>类/方法</strong> | <strong>用途</strong> | <strong>示例</strong> |
|------------|---------|----------|
| ProcessName | 获取进程名称 |  |
| ID | 获取进程唯一标识符 |  |
| Threads | 进程中的线程集合 |  |
| MachineName | 获取运行进程的计算机名称 |  |</p>
<p>常用方法：</p>
<p>| <strong>类/方法</strong> | <strong>用途</strong> | <strong>示例</strong> |
|------------|---------|----------|
| <strong><code>ProcessStartInfo</code></strong> | 配置进程启动参数 | 设置启动参数、工作目录、是否隐藏窗口等 |
| <strong><code>Process</code></strong> | 管理本地或远程进程 | <code>Process.Start("notepad.exe")</code> |
| <code>Process.Start()</code> | 启动新进程 | <code>Process.Start("calc.exe")</code> |
| <code>Process.Kill()</code> | 强制终止进程 | <code>proc.Kill();</code> |
| <code>Process.WaitForExit()</code> | 阻塞当前线程直到进程退出 | <code>proc.WaitForExit(5000);</code>（等待5秒） |
| <code>Process.GetProcesses()</code> | 获取当前运行的所有进程 | <code>Process.GetProcessesByName("chrome")</code> |
| Process.GetCurrentProcess() | 获取当前运行的进程 |  |</p>
<h4><strong>1.3 进程操作</strong></h4>
<pre><code class="language-csharp">// 获取当前进程
Process currentProcess = Process.GetCurrentProcess();
Console.WriteLine(currentProcess.ProcessName)  //获取进程名称
Console.WriteLine(currentProcess.ID)  //获取进程唯一标识符
Console.WriteLine(currentProcess.Threads)  //获取进程的线程集合
Console.WriteLine(currentProcess.MachineName)  //获取运行进程的计算机名称


// 启动新进程
Process.Start("notepad.exe");

// 启动进程并传递参数
ProcessStartInfo startInfo = new ProcessStartInfo();
startInfo.FileName = "notepad.exe";
startInfo.Arguments = "file.txt";
Process.Start(startInfo);

// 获取所有进程
Process[] processes = Process.GetProcesses();

// 结束进程
// 查找并结束所有记事本进程
foreach (var proc in Process.GetProcessesByName("notepad")) {
    proc.Kill();
}
</code></pre>
<h3>2. 线程（Thread）</h3>
<h4>2.1 基本概念</h4>
<ul>
<li>定义 ：线程是进程中的执行单元，一个进程可以包含多个线程</li>
<li>特点 ：
<ul>
<li>共享进程的内存空间</li>
<li>具有自己的堆栈和局部变量</li>
<li>可以并发执行</li>
</ul>
</li>
</ul>
<h4>2.2 三种线程类</h4>
<ul>
<li>
<p>Thread 线程类</p>
<ul>
<li>属性
<ul>
<li>IsBackground 获取或设置后台线程</li>
<li>ManagedThreadId 获取当前线程的唯一标识符</li>
<li>Name  获取或设置线程的名称</li>
<li>CurrentThread 获取当前正在运行的线程。该属性为静态属性</li>
<li>ThreadState 获取当前线程的状态</li>
<li>IsAlive 当前线程的执行状态。如果此线程己启动并且尚未正常终止或中断，则为true</li>
</ul>
</li>
<li>方法
<ul>
<li>开启:Start; 阻塞:Join; 停止:Abort --会有异常; 睡眠:Sleep; 挂起:Suspend[弃用]; 唤醒:Resume[弃用]</li>
</ul>
</li>
</ul>
</li>
<li>
<p>ThreadPool 线程池类</p>
</li>
</ul>
<pre><code class="language-csharp">// 使用线程池执行任务
ThreadPool.QueueUserWorkItem(state => {
    Console.WriteLine("在线程池中执行任务");
});
ThreadPool.QueueUserWorkItem(state => {
    Console.WriteLine("在线程池中执行任务2");
});
ThreadPool.QueueUserWorkItem(state => {
    Console.WriteLine("在线程池中执行任务3");
});

// 使用Task执行异步操作
public async Task&#x3C;string> DownloadAsync(string url)
{
    using (HttpClient client = new HttpClient())
    {
        return await client.GetStringAsync(url);
    }
}
//ThreadPool的优点在于它能够有效地复用线程资源，减少线程的创建和销毁开销，提高系统的吞吐量。ThreadPool由.NET运行时管理，提供了更高级别的抽象和自动化。
</code></pre>
<ul>
<li>Task 线程类（任务类）--推荐
<ul>
<li>创建
1】实例化 new  Task(方法) 需要调用Start才会启动
2】 Task.Run ----------  自动运行
3】Task.Factory.StartNew---开启 自动运行</li>
<li>阻塞
当前所在的线程直到完成 Wait、WaitAll、WaitAny</li>
<li>后继线程 ContinueWith
Task.WhenAll().ContinueWith(()=>{})</li>
<li>长任务：重载一个Task的构造方法
多一个参数设置成TaskCreationOptions.LongRunning</li>
<li>添加到父任务
将子任务可以添加为父任务，子任务是从属于父任务，如果子任务没有结束，父任务也不会结束（放在Run里面不行）</li>
</ul>
</li>
</ul>
<h4>2.3 前台线程和后台线程</h4>
<p>通过设置<code>IsBackground</code>属性可以设置为前台或后台线程，后台线程在所有前台线程结束后自动结束。前台线程会阻止应用程序的进程终止，直到所有前台线程都完成执行。默认情况下，前台线程是应用程序的主要执行线程。</p>
<h4>2.4取消类</h4>
<ul>
<li>属性 --IsCancellationRequested--默认是false  是否取消</li>
<li>方法-- Cancel  --将IsCancellationRequested设置成true<br>
CancelAfter  指定多少毫秒后取消---等待多少毫秒不影响主线
cts.Token.Register(()=>{});    取消回调-</li>
</ul>
<h4>2.6 线程同步与调度</h4>
<h6>线程同步与调度</h6>
<h5>2.6.0 winform中 跨线程访问</h5>
<ul>
<li>Invoke实现对控件的访问，从而达到跨线程访问</li>
<li>Control类还有一个属性（取消跨线程访问-不建议取消）</li>
<li>另外 Task的Start的方式   task.Start(TaskScheduler.FromCurrentSynchronizationContext())的方式-任务调度器</li>
<li>task.ContinueWith也有TaskScheduler.FromCurrentSynchronizationContext()</li>
</ul>
<p>备注：Application.DoEvents() ---放在线程的循环中以用来响应Windows的消息放在卡顿或者假死
注意：不要在Invoke放任何等待代码（这里面只放控件刷新改变值的代码）更不要放Sleep</p>
<h5>2.6.1 事件同步信号：自动、手动</h5>
<pre><code class="language-csharp">//手动同步事件=> 构造函数传入参数  true --有信号 不阻塞   false--无信号 阻塞
System.Threading.ManualResetEvent manualResetEvent = new System.Threading.ManualResetEvent(false);
//自动同步事件 => 构造函数传入参数  true --有信号 不阻塞   false--无信号 阻塞
System.Threading.AutoResetEvent autoResetEvent = new System.Threading.AutoResetEvent(false);

... 其他代码
new Thread(() => 
 {
     for (int i = 0; i &#x3C;= 100; i+=5)
     {
         //使用手动同步事件=>阻塞当前线程(也可以解除对线程的阻塞)
         manualResetEvent.WaitOne();
         
         //使用自动同步事件=>阻塞当前线程(也可以解除对线程的阻塞)
         //autoResetEvent.WaitOne();
         
         //更新进度条
         this.progressBar1.Value = i;
         //线程休眠
         Thread.Sleep(200);
     }
 }) { IsBackground=true}.Start();
... 其他代码
    
... 其他代码
//解除对线程的阻塞
manualResetEvent.Set();
//阻塞当前线程
manualResetEvent.Reset();  

// 自动同步事件=>Set
autoResetEvent.Set();
.....
</code></pre>
<h5>2.6.2 线程锁</h5>
<ol>
<li>lock-----语法糖--常用简单，lock实际Monitor的语法糖</li>
<li>Monitor监视锁-----同进程
Monitor.Enter(obj);//进入监视锁     Monitor.Exit(obj);//退出锁
Monitor.Wait(obj)释放锁阻塞当前线程   Monitor.Pulse(obj) 唤醒等待线程</li>
<li>Mutex互斥锁---跨进程<br>
mutex.WaitOne();//进入锁     mutex.ReleaseMutex();//释放锁</li>
</ol>
<pre><code class="language-csharp">//lock 锁
... 其他代码
decimal Balance=1000;    
public void WithDraw(string name,int amount){
  lock (this)
	{
    	//判断余额是否足够
    	if (this.Balance >= amount)
    	{
        	//模拟取款需要的时间
        	Thread.Sleep(1000);
        	//更新余额
        	this.Balance -= amount;
        	//提示取款成功
        	Console.WriteLine(name + "取款成功，余额为：" + this.Balance);
    	}
    	else
    	{
        	Console.WriteLine(name + "余额不足，取款失败！");
    	}                
	}    
}

... 其他代码
new Thread(() => account.WithDraw("小明", 800)) { IsBackground=true}.Start();
new Thread(() => account.WithDraw("小红", 800)) { IsBackground = true }.Start();    
    
</code></pre>
<h6><strong>1.  <code>Monitor</code> 类介绍</strong></h6>
<ul>
<li>
<p><strong><code>lock</code></strong> 是 <code>Monitor</code> 的语法糖：</p>
<pre><code class="language-csharp">object obj = new object();
lock (obj) 
{
    // 临界区代码
}

// 等效于 ↓↓↓

bool lockTaken = false;
try 
{
    Monitor.Enter(obj, ref lockTaken);  // 原子性获取锁
    // 临界区代码
}
finally 
{
    if (lockTaken)
        Monitor.Exit(obj);  // 确保释放锁（避免死锁）
}
</code></pre>
</li>
<li>
<p>**<code>Monitor.TryEnter</code> 避免死锁</p>
</li>
</ul>
<pre><code class="language-csharp">object lockObj = new object();
bool lockTaken = false;

// 尝试获取锁，最多等待 500ms
if (Monitor.TryEnter(lockObj, 500, ref lockTaken))
{
    try
    {
        // 临界区代码
    }
    finally
    {
        if (lockTaken)
            Monitor.Exit(lockObj);
    }
}
else
{
    // 未能获取锁时的处理（如记录日志或回滚操作）
}
</code></pre>
<ul>
<li><code>Monitor.Wait()</code> 和 <code>Pulse()</code> 实现线程协作</li>
</ul>
<pre><code class="language-csharp">object syncObj = new object();

// 线程A
lock (syncObj)
{
    // 等待线程B的通知
    Monitor.Wait(syncObj); // 释放锁并阻塞，直到被 Pulse 唤醒
}

// 线程B
lock (syncObj)
{
    // 处理任务后唤醒线程A
    Monitor.Pulse(syncObj); // 或使用 PulseAll 唤醒所有等待线程
}
</code></pre>
<hr>
<h2><strong>10 async和await异步编程</strong></h2>
<h3><strong>1 基本用法</strong></h3>
<p>使用 <code>async</code> 和 <code>await</code> 关键字实现异步编程：</p>
<h3><strong>2 返回值</strong></h3>
<p>返回值类型只能是 void 、Task、Task 中的一个</p>
<pre><code class="language-csharp">//返回 Task&#x3C;T>
static async Task&#x3C;int> CalculateAsync1()
{
    await Task.Delay(1000);
    return 42;
}
//返回 Task，需要写return，只需要写await。不建议使用void。 

static async Task CalculateAsync2()
{
    await Task.Delay(1000);
}
</code></pre>
<hr>
<h3><strong>3. 取消异步任务（CancellationToken）</strong></h3>
<p>异步任务可以通过 <code>CancellationToken</code> 取消。</p>
<pre><code class="language-csharp">using System;
using System.Threading;
using System.Threading.Tasks;

class Program
{
    static async Task Main()
    {
        // 创建 CancellationTokenSource
        var cts = new CancellationTokenSource();

        // 启动异步任务
        var task = DoSomethingAsync(cts.Token);

        // 等待用户输入以取消任务
        Console.WriteLine("Press 'C' to cancel the task...");
        if (Console.ReadKey().KeyChar == 'c')
            cts.Cancel();

        try
        {
            await task; // 等待任务完成（或取消）
        }
        catch (TaskCanceledException)
        {
            Console.WriteLine("Task was canceled.");
        }
    }

    static async Task DoSomethingAsync(CancellationToken token)
    {
        for (int i = 0; i &#x3C; 10; i++)
        {
            token.ThrowIfCancellationRequested(); // 检查是否取消
            Console.WriteLine("Working... " + i);
            await Task.Delay(500, token); // 支持取消的延迟
        }
    }
}
</code></pre>
<h3><strong>4. 并行</strong></h3>
<p>AsParallel</p>
<pre><code class="language-C#">List&#x3C;int> list = Enumerable.Range(1, 100).AsParallel().Where(n =>isPrime(n)).ToList();

static bool isPrime(int n)
{
    if (n &#x3C; 2) return false;
    for (int i = 2; i &#x3C; n; i++)
    {
        if (n % i == 0)
        {
           return false;
        }

    }
     Console.WriteLine("素数：{0}",n);
     return true;
}
</code></pre>
<p>Parallel.For  Parallel.ForEach</p>
<pre><code class="language-C#">static void ParallelTest2() {
    Parallel.For(1, 30, (i) =>
    {
       Console.WriteLine("task  {0}",i);
       Task.Delay(2000).Wait();
     });
     Console.WriteLine("主线程结束");
}  

static void ParallelTest3() {
   List&#x3C;string> listStr=new List&#x3C;string>(){"a","b","c","d","e","f","g","h","i","j"}; 
   Parallel.ForEach(listStr, (str) =>
      {
        Console.WriteLine("task  {0}",str);
        Task.Delay(2000).Wait();
       });
   Console.WriteLine("主线程结束");
}
</code></pre>
<hr>
<h2><strong>11. LINQ、SqlServer</strong></h2>
<h3>11.1 LINQ</h3>
<h4><strong>一、LINQ 核心原理</strong></h4>
<ol>
<li>
<p><strong>核心理念</strong>：</p>
<ul>
<li>使用统一的语法操作 <strong>多种数据源</strong>（集合、数据库、XML等）</li>
<li>基于**延迟执行（Deferred Execution）**机制（查询定义与实际执行分离）</li>
</ul>
<p>LINQ 扩展方法定义在静态类 <code>System.Linq.Enumerable</code> 中，且<strong>所有方法都针对 <code>IEnumerable&#x3C;T></code> 设计</strong>,包括list、array、dictionary、stack、queue</p>
</li>
<li>
<p><strong>两种语法风格</strong>：</p>
<ul>
<li><strong>查询表达式（Query Syntax）</strong>：接近SQL的声明式风格</li>
</ul>
<pre><code class="language-csharp">var query = from p in products
            where p.Price > 100
            select p.Name;
</code></pre>
<ul>
<li><strong>方法语法（Method Syntax）</strong>：利用链式扩展方法（推荐用于复杂操作）</li>
</ul>
<pre><code class="language-csharp">var query = products.Where(p => p.Price > 100).Select(p => p.Name);
</code></pre>
</li>
<li>
<p><strong>核心命名空间</strong>：</p>
<pre><code class="language-csharp">using System.Linq;           // 基本LINQ操作
using System.Linq.Expressions; // 表达式树
</code></pre>
</li>
</ol>
<hr>
<h4><strong>二、基础LINQ操作</strong></h4>
<h5><strong>1. 数据源准备</strong></h5>
<pre><code class="language-csharp">public class Product
{
    public string Name { get; set; }
    public decimal Price { get; set; }
    public string Category { get; set; }
}

List&#x3C;Product> products = new List&#x3C;Product>
{
    new Product { Name = "Laptop", Price = 1200, Category = "Electronics" },
    new Product { Name = "Coffee", Price = 5, Category = "Food" },
    new Product { Name = "Phone", Price = 800, Category = "Electronics" }
};
</code></pre>
<h5><strong>2. 筛选数据（Where）</strong></h5>
<pre><code class="language-csharp">// 查询表达式
var exprQuery = from p in products 
                where p.Price > 100 &#x26;&#x26; p.Category == "Electronics"
                select p;

// 方法语法（Lambda表达式）
var methodQuery = products.Where(p => p.Price > 100 &#x26;&#x26; p.Category == "Electronics");
</code></pre>
<h5><strong>3. 排序（OrderBy, ThenBy）</strong></h5>
<pre><code class="language-csharp">// 按价格升序，再按名称降序
var sorted = products.OrderBy(p => p.Price)
                     .ThenByDescending(p => p.Name);

// 查询表达式
var exprSort = from p in products
               orderby p.Price ascending, p.Name descending
               select p;
</code></pre>
<h5><strong>4. 分组（GroupBy）</strong></h5>
<pre><code class="language-csharp">// 按类别分组（方法语法）
var groups = products.GroupBy(p => p.Category);

// 查询表达式
var exprGroup = from p in products
                group p by p.Category into g
                select new { Category = g.Key, Items = g };
</code></pre>
<h5><strong>5. 连接（Join）</strong></h5>
<pre><code class="language-csharp">var orders = new List&#x3C;Order> { /* 订单数据 */ };

// 内连接
var joinQuery = from p in products
                join o in orders on p.Name equals o.ProductName
                select new { p.Name, o.OrderDate };

// 方法语法
var methodJoin = products.Join(orders,
                      p => p.Name,
                      o => o.ProductName,
                      (p, o) => new { p.Name, o.OrderDate });
</code></pre>
<hr>
<h4><strong>三、标准查询操作符</strong></h4>
<p>| <strong>类别</strong>        | <strong>操作符</strong>                                                     | <strong>说明</strong>                              |
|-----------------|---------------------------------------------------------------|---------------------------------------|
| <strong>筛选</strong>        | <code>Where</code>、<code>OfType&#x3C;T></code>                                         | 条件过滤                             |
| <strong>投影</strong>        | <code>Select</code>、<code>SelectMany</code>                                       | 数据转换                             |
| <strong>排序</strong>        | <code>OrderBy</code>、<code>OrderByDescending</code>、<code>Reverse</code>                    | 结果排序                             |
| <strong>分组</strong>        | <code>GroupBy</code>、<code>ToLookup</code>                                        | 创建分组                             |
| <strong>连接</strong>        | <code>Join</code>、<code>GroupJoin</code>、<code>Zip</code>                                   | 组合数据源                          |
| <strong>聚合</strong>        | <code>Count</code>、<code>Sum</code>、<code>Average</code>、<code>Min</code>、<code>Max</code>、<code>Aggregate</code>          | 数值计算                             |
| <strong>转换</strong>        | <code>ToArray</code>、<code>ToList</code>、<code>ToDictionary</code>、<code>Cast&#x3C;T></code>、<code>AsEnumerable</code> | 类型转换                             |
| <strong>元素操作</strong>    | <code>First</code>、<code>Last</code>、<code>ElementAt</code>、<code>Single</code>、<code>DefaultIfEmpty</code>      | 获取特定元素                         |
| <strong>集合操作</strong>    | <code>Distinct</code>、<code>Union</code>、<code>Intersect</code>、<code>Except</code>                   | 集合运算                             |
| <strong>分页</strong>        | <code>Skip</code>、<code>Take</code>                                               | 分页处理                             |
| <strong>条件检查</strong>    | <code>Any</code>、<code>All</code>、<code>Contains</code>                                      | 条件验证                             |
| <strong>生成序列</strong>    | <code>Range</code>、<code>Repeat</code>、<code>Empty</code>                                    | 动态生成数据                        |</p>
<hr>
<h4><strong>四、重要技巧与示例</strong></h4>
<h5><strong>1. 延迟执行 vs 即时执行</strong></h5>
<pre><code class="language-csharp">var deferredQuery = products.Where(p => p.Price > 100); // 定义查询但未执行
var immediateList = deferredQuery.ToList();             // 立即执行并物化为列表

products.Add(new Product { Price = 200 }); 
Console.WriteLine(immediateList.Count);    // 结果不变（已物化）
Console.WriteLine(deferredQuery.Count());  // 包含新数据（延迟执行）
</code></pre>
<h5><strong>2. 动态条件构建</strong></h5>
<pre><code class="language-csharp">IQueryable&#x3C;Product> query = dbContext.Products.AsQueryable();

if (filterByCategory)
    query = query.Where(p => p.Category == selectedCategory);

if (minPrice > 0)
    query = query.Where(p => p.Price >= minPrice);

var finalResults = query.ToList(); // 动态组合条件
</code></pre>
<h5><strong>3. Lambda表达式与Func委托</strong></h5>
<pre><code class="language-csharp">Func&#x3C;Product, bool> filter = p => p.Price > 100;
var query = products.Where(filter);
</code></pre>
<h5><strong>4. 匿名类型与投影</strong></h5>
<pre><code class="language-csharp">var productInfo = products.Select(p => new 
{
    p.Name,
    PriceWithTax = p.Price * 1.1M,
    IsExpensive = p.Price > 1000
});
</code></pre>
<h5><strong>5. 处理Null值</strong></h5>
<pre><code class="language-csharp">var safeQuery = products.Where(p => p.Category != null)
                        .Select(p => p.Name.ToUpper());
</code></pre>
<hr>
<h4><strong>五、LINQ to Entities（Entity Framework Core）</strong></h4>
<pre><code class="language-csharp">// 结合EF Core的数据库查询
using (var context = new AppDbContext())
{
    var query = context.Products
        .Where(p => p.Price > 100)
        .OrderByDescending(p => p.CreatedDate)
        .Select(p => new { p.Name, p.Price })
        .ToList();
  
    // 转换为SQL：
    // SELECT [p].[Name], [p].[Price]
    // FROM [Products] AS [p]
    // WHERE [p].[Price] > 100
    // ORDER BY [p].[CreatedDate] DESC
}
</code></pre>
<hr>
<h4><strong>六、性能优化</strong></h4>
<ol>
<li><strong>数据库端过滤</strong>：确保条件在<code>Where</code>中传递到数据库（避免客户端过滤）</li>
<li><strong>避免N+1查询</strong>：使用<code>Include</code>或投影预先加载关联数据
<pre><code class="language-csharp">// 优化前（N+1问题）
var orders = context.Orders.ToList();
foreach (var o in orders)
    Console.WriteLine(o.Customer.Name);

// 优化后（一次性加载关联数据）
var optimized = context.Orders.Include(o => o.Customer).ToList();
</code></pre>
</li>
<li><strong>分页建议</strong>：始终在服务端进行分页（结合<code>Skip</code>和<code>Take</code>）
<pre><code class="language-csharp">var pageData = context.Products
                     .OrderBy(p => p.Name)
                     .Skip((pageIndex - 1) * pageSize)
                     .Take(pageSize)
                     .ToList();
</code></pre>
</li>
</ol>
<hr>
<h4><strong>七、常见场景对照表</strong></h4>
<p>| <strong>SQL操作</strong>         | <strong>LINQ等价实现</strong>                              |
|---------------------|----------------------------------------------|
| <code>SELECT * FROM Table</code> | <code>dbContext.Table.ToList()</code>                  |
| <code>WHERE</code>             | <code>.Where(p => p.Condition)</code>                  |
| <code>ORDER BY</code>          | <code>.OrderBy()</code> / <code>.OrderByDescending()</code>       |
| <code>JOIN</code>              | <code>.Join()</code> 或导航属性                       |
| <code>GROUP BY</code>          | <code>.GroupBy()</code>                               |
| <code>HAVING</code>            | <code>.Select(...).Where(groupCondition)</code>       |
| <code>TOP N</code>             | <code>.Take(N)</code>                                 |</p>
<h3>11.2 SqlServer</h3>
<h4><strong>一、命名空间与NuGet包</strong></h4>
<ol>
<li>
<p><strong>基础依赖</strong>：使用 <code>System.Data.SqlClient</code>（旧版）或 <strong><code>Microsoft.Data.SqlClient</code></strong>（新版推荐）</p>
<pre><code class="language-bash"># NuGet安装命令
dotnet add package Microsoft.Data.SqlClient
</code></pre>
</li>
<li>
<p><strong>重要命名空间</strong>：</p>
<pre><code class="language-csharp">using Microsoft.Data.SqlClient; // 核心API
using System.Data;              // DataTable、DataSet等通用类型
</code></pre>
</li>
</ol>
<hr>
<h4><strong>二、核心操作流程</strong></h4>
<h5><strong>1. 连接数据库</strong></h5>
<pre><code class="language-csharp">// 连接字符串（推荐从配置文件读取）
string connectionString = "Server=myserver;Database=mydb;Integrated Security=True;TrustServerCertificate=True";

using (var connection = new SqlConnection(connectionString))
{
    connection.Open();
    // 后续操作...
}
</code></pre>
<p><strong>连接字符串关键参数</strong>：
| <strong>参数</strong>              | <strong>说明</strong>                                      |
|-----------------------|----------------------------------------------|
| <code>Server</code>              | 服务器地址（如 <code>localhost</code>、<code>192.168.1.10</code>） |
| <code>Database</code>            | 数据库名称                                   |
| <code>User ID</code> / <code>Password</code>| SQL账号密码（若用混合验证）                  |
| <code>Integrated Security</code> | 使用Windows身份验证（设置为<code>True</code>或<code>SSPI</code>）  |
| <code>TrustServerCertificate</code> | 开发环境跳过SSL验证（设为<code>True</code>）          |</p>
<hr>
<h5><strong>2. 执行SQL命令</strong></h5>
<h6><strong>a. 查询数据（</strong><code>ExecuteReader返回SqlDataReader</code><strong>）</strong></h6>
<pre><code class="language-csharp">string sql = "SELECT Id, Name FROM Users WHERE Age > @age";
using (var command = new SqlCommand(sql, connection))
{
    command.Parameters.AddWithValue("@age", 18);
    using (var reader = command.ExecuteReader())
    {
        while (reader.Read())
        {
            int id = reader.GetInt32(0);
            string name = reader.GetString(1);
            Console.WriteLine($"ID: {id}, Name: {name}");
        }
    }
}
</code></pre>
<h6><strong>b. 插入/更新数据（</strong><code>ExecuteNonQuery</code><strong>）</strong></h6>
<pre><code class="language-csharp">string insertSql = @"INSERT INTO Users (Name, Age) 
                     VALUES (@name, @age)";
using (var command = new SqlCommand(insertSql, connection))
{
    command.Parameters.AddWithValue("@name", "Alice");
    command.Parameters.AddWithValue("@age", 25);
    int rowsAffected = command.ExecuteNonQuery(); // 返回受影响的行数
}
</code></pre>
<h6><strong>c. 事务处理 SqlTransaction</strong></h6>
<pre><code class="language-csharp">using (var transaction = connection.BeginTransaction())
{
    try
    {
        var command1 = new SqlCommand("UPDATE Account SET Balance -= 100 WHERE Id = 1", connection, transaction);
        var command2 = new SqlCommand("UPDATE Account SET Balance += 100 WHERE Id = 2", connection, transaction);
        command1.ExecuteNonQuery();
        command2.ExecuteNonQuery();
        transaction.Commit(); // 提交事务
    }
    catch
    {
        transaction.Rollback(); // 回滚事务
        throw;
    }
}
</code></pre>
<hr>
<h5><strong>3. 数据集操作（</strong><code>SqlDataAdapter</code><strong>）</strong></h5>
<pre><code class="language-csharp">var adapter = new SqlDataAdapter("SELECT * FROM Products", connection);
var dataset = new DataSet();
adapter.Fill(dataset, "Products"); // 填充数据集

// 修改数据并更新回数据库
DataTable table = dataset.Tables["Products"];
table.Rows[0]["Price"] = 99.99;

var builder = new SqlCommandBuilder(adapter); // 自动生成更新命令
adapter.Update(dataset, "Products");
</code></pre>
<hr>
<h4><strong>三、进阶技巧</strong></h4>
<h5><strong>1. 参数化查询最佳实践</strong></h5>
<ul>
<li><strong>避免SQL注入</strong>：始终用 <code>SqlParameter</code> 代替字符串拼接</li>
<li><strong>明确参数类型</strong>：推荐使用 <code>Add()</code> 代替 <code>AddWithValue()</code></li>
</ul>
<pre><code class="language-csharp">var param = new SqlParameter("@date", SqlDbType.DateTime);
param.Value = DateTime.Now;
command.Parameters.Add(param);
</code></pre>
<h5><strong>2. 批量插入（</strong><code>SqlBulkCopy</code><strong>）</strong></h5>
<pre><code class="language-csharp">using (var bulkCopy = new SqlBulkCopy(connection))
{
    bulkCopy.DestinationTableName = "Orders";
    bulkCopy.WriteToServer(dataTable); // 高速批量插入（DataTable或IDataReader）
}
</code></pre>
<h5><strong>3. 异步操作（.NET 5+）</strong></h5>
<pre><code class="language-csharp">await using (var connection = new SqlConnection(connectionString))
{
    await connection.OpenAsync();
    var command = new SqlCommand("WAITFOR DELAY '00:00:02';", connection);
    await command.ExecuteNonQueryAsync(); // 异步等待
}
</code></pre>
<h5><strong>4. 存储过程调用</strong></h5>
<pre><code class="language-csharp">using (var command = new SqlCommand("usp_GetUserInfo", connection))
{
    command.CommandType = CommandType.StoredProcedure;
    command.Parameters.AddWithValue("@userId", 123);
    using (var reader = command.ExecuteReader())
    {
        // 处理结果...
    }
}
</code></pre>
<hr>
<h4><strong>四、错误处理与资源管理</strong></h4>
<pre><code class="language-csharp">try
{
    using (var connection = new SqlConnection(connectionString))
    {
        connection.Open();
        // 执行命令...
    }
}
catch (SqlException ex) // 捕获SQL特定异常
{
    Console.WriteLine($"数据库错误: {ex.Message}");
    foreach (SqlError error in ex.Errors)
    {
        Console.WriteLine($"错误代码: {error.Number}, 消息: {error.Message}");
    }
}
catch (Exception ex)
{
    Console.WriteLine($"通用异常: {ex.Message}");
}
</code></pre>
<hr>
<h4><strong>五、Entity Framework Core集成（可选）</strong></h4>
<p>若需更高层抽象，推荐使用 <strong>ORM工具</strong>（如EF Core）：</p>
<pre><code class="language-csharp">// 定义DbContext
public class AppDbContext : DbContext
{
    public DbSet&#x3C;User> Users { get; set; }
    protected override void OnConfiguring(DbContextOptionsBuilder options)
        => options.UseSqlServer("连接字符串");
}

// 示例查询
using (var context = new AppDbContext())
{
    var user = await context.Users
                    .Where(u => u.Age > 18)
                    .FirstOrDefaultAsync();
}
</code></pre>
<hr>
<h2><strong>12 网络通信</strong></h2>
<p>看网络通信笔记</p>
<hr>
<h2><strong>13 表达式</strong></h2>
<h3><strong>1. Lambda 表达式</strong></h3>
<pre><code class="language-csharp">// 隐式类型（表达式形式）
Func&#x3C;int, int> square = x => x * x;
Console.WriteLine(square(5)); // 输出 25

// 显式语句块（带大括号）
Action&#x3C;string> log = message => 
{
    Console.WriteLine($"[LOG] {DateTime.Now}: {message}");
};
log("Hello!");
</code></pre>
<hr>
<h3><strong>2. 空条件运算符 (<code>?.</code> 和 <code>?[]</code>)</strong></h3>
<pre><code class="language-csharp">// 避免 NullReferenceException
string name = person?.Name;          // 如果 person 为 null，返回 null
int length = person?.Name?.Length ?? 0; // 链式安全访问 + 空合并运算符

// 安全访问集合
List&#x3C;int> numbers = null;
int? first = numbers?[0];            // 如果 numbers 为 null，返回 null
</code></pre>
<hr>
<h3><strong>3. 空合并运算符 (<code>??</code> 和 <code>??=</code>)</strong></h3>
<pre><code class="language-csharp">string name = inputName ?? "Anonymous"; // 如果 inputName 为 null，返回 "Anonymous"

// 简化 null 检查赋值
List&#x3C;int> list = null;
list ??= new List&#x3C;int>(); // 如果 list 为 null，初始化新对象
</code></pre>
<hr>
<h3><strong>4. 模式匹配 switch表达式</strong></h3>
<pre><code class="language-csharp">
// Switch 表达式 (C# 8+)
string message = shape switch
{
    Circle c => $"Circle with radius {c.Radius}",
    Rectangle r => $"Rectangle {r.Width}x{r.Height}",
    _ => "Unknown shape"
};

// 关系模式 (C# 9+)
string grade = score switch
{
    >= 90 => "A",
    >= 80 => "B",
    >= 60 => "C",
    _ => "F"
};
</code></pre>
<hr>
<h3><strong>5. 对象与集合初始化表达式</strong></h3>
<pre><code class="language-csharp">// 对象初始化
var person = new Person 
{ 
    Name = "Alice", 
    Age = 30 
};

// 集合初始化
var numbers = new List&#x3C;int> { 1, 2, 3 };
var dict = new Dictionary&#x3C;string, int>
{
    ["one"] = 1,
    ["two"] = 2
};
</code></pre>
<hr>
<h3><strong>6. 字符串插值 (<code>$</code>)</strong></h3>
<pre><code class="language-csharp">string name = "Bob";
int age = 25;
Console.WriteLine($"{name} is {age} years old."); // 输出 "Bob is 25 years old."
</code></pre>
<hr>
<h3><strong>7. 索引与范围运算符 (<code>^</code> 和 <code>..</code>) (C# 8+)</strong></h3>
<p>[[^]start]..[[^]end],  含头不含尾,^是倒数的意思</p>
<pre><code class="language-csharp">int[] arr = { 0, 1, 2, 3, 4, 5 };
int last = arr[^1];      // 5（倒数第一个）
int[] sub = arr[1..4];   // {1, 2, 3}（区间左闭右开）
int[] all = arr[..];     // 整个数组的拷贝
</code></pre>
<hr>
<h3><strong>8. LINQ 表达式</strong></h3>
<pre><code class="language-csharp">var result = from p in people
             where p.Age > 18
             orderby p.Name
             select new { p.Name, p.Age };

// 方法链式写法（等同效果）
var result = people
    .Where(p => p.Age > 18)
    .OrderBy(p => p.Name)
    .Select(p => new { p.Name, p.Age });
</code></pre>
<hr>
<h3><strong>9. 异步表达式 (<code>async</code>/<code>await</code>)</strong></h3>
<pre><code class="language-csharp">public async Task DownloadFileAsync()
{
    using var client = new HttpClient();
    string content = await client.GetStringAsync("https://example.com");
    await File.WriteAllTextAsync("file.txt", content);
}
</code></pre>
<hr>
<h3><strong>10. 析构与元组</strong></h3>
<pre><code class="language-csharp">// 元组初始化与析构
var tuple = (Name: "Alice", Age: 30);
(string name, int age) = tuple;

// 方法返回元组
public (int, string) GetData() => (42, "Answer");

// 接收返回值（直接析构）
var (number, text) = GetData();
</code></pre>
<hr>
<h3><strong>11. 记录类型 (C# 9+)</strong></h3>
<pre><code class="language-csharp">public record Person(string Name, int Age); // 不可变记录

var person1 = new Person("Bob", 25);
var person2 = person1 with { Age = 26 }; // 通过 with 表达式创建副本
</code></pre>
<hr>
<h3><strong>12. 异常筛选器 (<code>when</code> 子句, C# 6+)</strong></h3>
<pre><code class="language-csharp">try { /* 可能抛异常的操作 */ }
catch (HttpRequestException ex) when (ex.StatusCode == 404)
{
    Console.WriteLine("Resource not found!");
}
</code></pre>
<hr>
<h3><strong>13. 全局命名空间 (C# 10+)</strong></h3>
<pre><code class="language-csharp">global using System; // 整个项目生效的全局引用
</code></pre>
<hr>
<h3><strong>14. 静态匿名函数 (<code>static</code> in Lambda, C# 9+)</strong></h3>
<pre><code class="language-csharp">// 禁止捕获外部变量，避免意外闭包
Func&#x3C;int, int> multiplier = static x => x * 2;
</code></pre>
<hr>
<h3><strong>15. 可空引用类型 (C# 8+ <code>?</code> 标记)</strong></h3>
<pre><code class="language-csharp">string? nullableString = null; // 明确声明允许 null
string nonNullable = "Hello"; // 默认不可为 null（编译器警告）
</code></pre>
<hr>
<h3><strong>16. 类型测试is typeof与强制转换表达式</strong></h3>
<pre><code class="language-csharp">// 类型模式 is
if (obj is int i)
{
    Console.WriteLine($"It's an integer: {i}");
}

// typeof 运算符的实参必须是类型或类型形参的名称
Console.WriteLine(typeof(Dictionary&#x3C;,>));
	
public class Animal { }
	
public class Giraffe : Animal { }
	
public static class TypeOfExample
{
	public static void Main()
	{
	    object b = new Giraffe();
	    Console.WriteLine(b is Animal);  // output: True
	    Console.WriteLine(b.GetType() == typeof(Animal));  
	    // output: False
	
	    Console.WriteLine(b is Giraffe);  // output: True
	    Console.WriteLine(b.GetType() == typeof(Giraffe));  
	    // output: 		True
	}
}
// 强制转换 (T)E 的强制转换表达式将表达式 E 的结果显式转换为类型 T
double x = 1234.7;
int a = (int)x;
Console.WriteLine(a);   // output: 1234
</code></pre>
<hr>
<h3><strong>17. with</strong></h3>
<pre><code class="language-csharp">public record NamedPoint(string Name, int X, int Y);
public static void Main()
{
	var p1 = new NamedPoint("A", 0, 0);
	Console.WriteLine($"{nameof(p1)}: {p1}");  
	// output: p1: NamedPoint { Name = A, X = 0, Y = 0 }
	    
	var p2 = p1 with { Name = "B", X = 5 };
	Console.WriteLine($"{nameof(p2)}: {p2}");  
	// output: p2: NamedPoint { Name = B, X = 5, Y = 0 }
}
</code></pre>
<hr>
<h3><strong>附：操作优先级备忘</strong></h3>
<p>| <strong>运算符</strong> | <strong>例子</strong>        | <strong>描述</strong>          |
| ---------- | --------------- | ----------------- |
| <code>?.</code> <code>?[]</code> | <code>obj?.Method()</code> | 空条件运算符      |
| <code>??</code> <code>??=</code> | <code>a ?? b</code>        | 空合并运算符      |
| <code>=></code>       | <code>x => x + 1</code>    | Lambda 箭头运算符 |
| <code>is</code> <code>as</code>  | <code>if (x is int)</code> | 类型检查/转换     |</p>
<hr>
<h2><strong>14 正则</strong></h2>
<h3><strong>1. 正则表达式与通配符对比</strong></h3>
<p>| <strong>类型</strong> | <strong>通配符（如文件匹配）</strong>       | <strong>正则表达式</strong>                            |
| -------- | ------------------------------ | ----------------------------------------- |
| 匹配范围 | 简单文件路径（<code>*.txt</code>）        | 复杂文本模式（邮件、电话号、URL等）       |
| 标准语法 | <code>?</code>（单字符）、<code>*</code>（任意字符） | 元字符组合（如<code>\d</code>、<code>[a-z]</code>、<code>^</code>、<code>$</code>等） |
| 场景举例 | 文件搜索：<code>Document?.docx</code>     | 数据验证：<code>^\w+@\w+\.\w+$</code>                |</p>
<hr>
<h3><strong>2. 正则表达式核心语法</strong></h3>
<p>| <strong>类别</strong>       | <strong>语法/符号</strong>        | <strong>功能说明</strong>                   | <strong>示例</strong>                            |
| -------------- | -------------------- | ------------------------------ | ----------------------------------- |
| <strong>基础匹配</strong>   | <code>.</code>                  | 匹配任意单字符（除换行符）     | <code>a.c</code> → "abc", "a@c"                |
| <strong>转义符</strong>     | <code>\</code>                  | 转义特殊字符（如<code>\.</code>匹配点号） | <code>\\d</code> → 匹配字符串"\d"              |
| <strong>字符类</strong>     | <code>[abc]</code>              | 匹配括号内任意字符             | <code>[aeiou]</code> → 匹配任意元音字母        |
|                | <code>[^abc]</code>             | 匹配不在括号内的字符           | <code>[^0-9]</code> → 匹配非数字字符           |
|                | <code>[a-z]</code>              | 匹配字符范围                   | <code>[A-Fa-f]</code> → 匹配十六进制字符       |
| <strong>预定义字符</strong> | <code>\d</code>                 | 数字（等价于<code>[0-9]</code>）          | <code>\d\d</code> → "01", "99"                 |
|                | <code>\w</code>                 | 单词字符（字母/数字/下划线）   | <code>\w+</code> → 匹配整个单词                |
|                | <code>\s</code>                 | 空白字符（空格、制表符等）     | <code>\s+</code> → 匹配连续空格                |
| <strong>量词</strong>       | <code>*</code>                  | 前导元素出现 <strong>0次或多次</strong>     | <code>ab*c</code> → "ac", "abbc"               |
|                | <code>+</code>                  | 前导元素出现 <strong>1次或多次</strong>     | <code>\d+</code> → "5", "123"                  |
|                | <code>?</code>                  | 前导元素出现 <strong>0次或1次</strong>      | <code>colou?r</code> → "color", "colour"       |
|                | <code>{n}</code>/<code>{n,}</code>/<code>{n,m}</code> | 精确次数/最少n次/范围次数      | <code>\d{3,5}</code> → "123", "45678"          |
| <strong>分组与捕获</strong> | <code>(exp)</code>              | 捕获分组并分配编号             | <code>(\d{3})-(\d{4})</code> → 分组1: 区号     |
|                | <code>(?:exp)</code>            | 非捕获分组（仅分组，不记录）   | <code>(?:http\|ftp)://</code> → 不捕获协议类型 |
| <strong>锚点</strong>       | <code>^</code>                  | 匹配字符串开始                 | <code>^\d+</code> → 字符串必须以数字开头       |
|                | <code>$</code>                  | 匹配字符串结束                 | <code>\w+$</code> → 字符串必须以单词字符结尾   |
| <strong>逻辑或</strong>     | <code>\|</code>                 | 匹配左侧或右侧表达式           | <code>cat\|dog</code> → "cat"或"dog"           |</p>
<hr>
<h3><strong>3. 在C#中的操作（System.Text.RegularExpressions）</strong></h3>
<p>| <strong>操作类型</strong> | <strong>方法/属性</strong>                                | <strong>功能说明</strong>                              | <strong>代码示例</strong>                                       |
| ------------ | -------------------------------------------- | ----------------------------------------- | -------------------------------------------------- |
| <strong>匹配验证</strong> | <code>Regex.IsMatch(input, pattern)</code>              | 判断字符串是否匹配模式                    | <code>if (Regex.IsMatch(phone, @"^\d{3}-\d{8}$"))</code>      |
| <strong>提取匹配</strong> | <code>Regex.Match()</code>                              | 提取第一个匹配结果（返回<code>Match</code>对象）     | <code>Match m = Regex.Match(text, @"\d+")</code>              |
|              | <code>Regex.Matches()</code>                            | 提取所有匹配结果（返回<code>MatchCollection</code>） | <code>foreach (Match m in Regex.Matches(...))</code>          |
| <strong>替换文本</strong> | <code>Regex.Replace(input, pattern, replacement)</code> | 替换匹配内容                              | <code>string clean = Regex.Replace(input, @"\s+", " ")</code> |
| <strong>分割文本</strong> | <code>Regex.Split(input, pattern)</code>                | 按正则表达式分割字符串                    | <code>string[] parts = Regex.Split(...)</code>                |
| <strong>选项控制</strong> | <code>RegexOptions.IgnoreCase</code>                    | 忽略大小写（作为参数传入）                | <code>new Regex(pattern, RegexOptions.IgnoreCase)</code>      |</p>
<hr>
<h3><strong>4. 常用正则表达式示例</strong></h3>
<p>| <strong>场景</strong>         | <strong>正则模式</strong>                                    | <strong>说明</strong>                           |
| ---------------- | ----------------------------------------------- | ---------------------------------- |
| 中国大陆手机号   | <code>^1[3-9]\d{9}$</code>                                 | 11位数字，以13-19开头              |
| 邮箱验证         | <code>^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</code> | 简化版通用邮箱格式                 |
| 提取HTML标签内容 | <code>&#x3C;\s*([a-z]+)[^>]*>(.*?)&#x3C;/\1></code>                  | 分组捕获标签名和内容（非贪婪匹配） |
| 中文匹配         | <code>[\u4e00-\u9fa5]+</code>                              | 匹配连续中文字符                   |
| URL提取          | <code>(https?://)?([\w学-]+\.)+[\w-]+(/[\w-?=&#x26;]*)?</code>  | 匹配HTTP/HTTPS链接                 |</p>
<hr>
<h3><strong>5. 注意事项</strong></h3>
<ol>
<li>
<p><strong>贪婪与懒惰</strong></p>
<ul>
<li><strong>贪婪量词</strong>（默认）：<code>*</code>、<code>+</code> → 尽可能多匹配（如<code>&#x3C;.*></code>会匹配到最后一个<code>></code>）</li>
<li><strong>懒惰量词</strong>：<code>*?</code>、<code>+?</code> → 尽可能少匹配（如<code>&#x3C;.*?></code>正确匹配单个HTML标签）</li>
</ul>
</li>
<li>
<p><strong>性能优化</strong></p>
<ul>
<li>频繁使用的正则表达式 → 用<code>Regex</code>构造函数<strong>预编译</strong>（<code>RegexOptions.Compiled</code>）</li>
<li>避免回溯爆炸 → 优先使用具体字符集（如用<code>\d</code>替代<code>[0-9]</code>）</li>
</ul>
</li>
<li>
<p><strong>特殊符号转义</strong></p>
<pre><code class="language-csharp">// C#字符串中需对反斜杠转义
string pattern = @"^\d+$";  // 推荐逐字字符串
// 或
string pattern = "^\\d+$";  // 标准字符串写法
</code></pre>
</li>
</ol>
<hr>
<h4><strong>使用案例</strong></h4>
<pre><code class="language-csharp">// 提取所有电话号码
string text = "联系人：张三 13812345678，李四 13987654321";
var matches = Regex.Matches(text, @"1[3-9]\d{9}");
foreach (Match m in matches) {
    Console.WriteLine($"找到号码：{m.Value}");
}

// 替换敏感词
string censored = Regex.Replace(
    input: "这篇文章包含TMD敏感词", 
    pattern: @"TMD|MMP", 
    replacement: "***", 
    options: RegexOptions.IgnoreCase
);
</code></pre>
<hr>
<h2><strong>15 其他</strong></h2>
<h3><strong>打包软件</strong></h3>
<p>04.11项目  创建setup项目</p>
<ul>
<li>打包好的软件；软件icon；  卸载软件msiexec.exe （C:\Windows\System32）</li>
<li>配置桌面快捷方式，并且配置icon；菜单快捷方式，并且配置icon；卸载的快捷方式，可配置icon；</li>
<li>卸载的参数要设置/x 软件代码；</li>
<li>配置对应的系统x86 x64</li>
<li>生成代码</li>
</ul>
<h3><strong>加密 混淆工具</strong></h3>
<p>virboxprotector   virboxprotector_3.5.0.21419_windows</p>
</div></div></article></div></main><!--$--><!--/$--></div><footer class="bg-neutral-50 border-t border-neutral-200 dark:bg-slate-800"><div class="container mx-auto px-5"><div class="py-10 flex flex-col lg:flex-row items-center"><h3 class="text-4xl lg:text-[2.5rem] font-bold tracking-tighter leading-tight text-center lg:text-left mb-10 lg:mb-0 lg:pr-4 lg:w-1/2">廿一之家~wildfire.</h3></div></div></footer><script src="/staticBlob/_next/static/chunks/e40cdc54537c3204.js" id="_R_" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[65393,[\"/staticBlob/_next/static/chunks/476073a848cd7881.js\"],\"ThemeSwitcher\"]\n3:I[22871,[\"/staticBlob/_next/static/chunks/fec5ea6183d0e55b.js\",\"/staticBlob/_next/static/chunks/3b60e5197848a126.js\"],\"default\"]\n4:I[59801,[\"/staticBlob/_next/static/chunks/fec5ea6183d0e55b.js\",\"/staticBlob/_next/static/chunks/3b60e5197848a126.js\"],\"default\"]\n6:I[98427,[\"/staticBlob/_next/static/chunks/fec5ea6183d0e55b.js\",\"/staticBlob/_next/static/chunks/3b60e5197848a126.js\"],\"OutletBoundary\"]\n7:\"$Sreact.suspense\"\n9:I[98427,[\"/staticBlob/_next/static/chunks/fec5ea6183d0e55b.js\",\"/staticBlob/_next/static/chunks/3b60e5197848a126.js\"],\"ViewportBoundary\"]\nb:I[98427,[\"/staticBlob/_next/static/chunks/fec5ea6183d0e55b.js\",\"/staticBlob/_next/static/chunks/3b60e5197848a126.js\"],\"MetadataBoundary\"]\nd:I[32257,[\"/staticBlob/_next/static/chunks/fec5ea6183d0e55b.js\",\"/staticBlob/_next/static/chunks/3b60e5197848a126.js\"],\"default\"]\n:HL[\"/staticBlob/_next/static/chunks/4e9cac203c4a1bb6.css\",\"style\"]\n:HL[\"/staticBlob/_next/static/chunks/4f1026ea77de124d.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"hJpZ9_1FZihJr8kZsrHcw\",\"c\":[\"\",\"blog\",\"CShape\"],\"q\":\"\",\"i\":false,\"f\":[[[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"CShape\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/staticBlob/_next/static/chunks/4e9cac203c4a1bb6.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"script\",\"script-0\",{\"src\":\"/staticBlob/_next/static/chunks/476073a848cd7881.js\",\"async\":true,\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"suppressHydrationWarning\":true,\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"rel\":\"apple-touch-icon\",\"sizes\":\"180x180\",\"href\":\"/favicon/apple-touch-icon.png\"}],[\"$\",\"link\",null,{\"rel\":\"icon\",\"type\":\"image/png\",\"sizes\":\"32x32\",\"href\":\"/favicon/favicon-32x32.png\"}],[\"$\",\"link\",null,{\"rel\":\"icon\",\"type\":\"image/png\",\"sizes\":\"16x16\",\"href\":\"/favicon/favicon-16x16.png\"}],[\"$\",\"link\",null,{\"rel\":\"manifest\",\"href\":\"/favicon/site.webmanifest\"}],[\"$\",\"link\",null,{\"rel\":\"mask-icon\",\"href\":\"/favicon/safari-pinned-tab.svg\",\"color\":\"#000000\"}],[\"$\",\"link\",null,{\"rel\":\"shortcut icon\",\"href\":\"/favicon/favicon.ico\"}],[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#000000\"}],[\"$\",\"meta\",null,{\"name\":\"msapplication-config\",\"content\":\"/favicon/browserconfig.xml\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#000\"}],[\"$\",\"link\",null,{\"rel\":\"alternate\",\"type\":\"application/rss+xml\",\"href\":\"/feed.xml\"}]]}],[\"$\",\"body\",null,{\"className\":\"dark:bg-slate-900 dark:text-slate-400\",\"children\":[[\"$\",\"$L2\",null,{}],[\"$\",\"div\",null,{\"className\":\"min-h-screen\",\"children\":[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"section\",null,{\"children\":[[\"$\",\"h1\",null,{\"className\":\"mb-8 text-2xl font-semibold tracking-tighter\",\"children\":\"404 - 页面没有找到\"}],[\"$\",\"p\",null,{\"className\":\"mb-4\",\"children\":\"您正在寻找的页面不存在。\"}]]}],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}],[\"$\",\"footer\",null,{\"className\":\"bg-neutral-50 border-t border-neutral-200 dark:bg-slate-800\",\"children\":[\"$\",\"div\",null,{\"className\":\"container mx-auto px-5\",\"children\":[\"$\",\"div\",null,{\"className\":\"py-10 flex flex-col lg:flex-row items-center\",\"children\":[\"$\",\"h3\",null,{\"className\":\"text-4xl lg:text-[2.5rem] font-bold tracking-tighter leading-tight text-center lg:text-left mb-10 lg:mb-0 lg:pr-4 lg:w-1/2\",\"children\":\"廿一之家~wildfire.\"}]}]}]}]]}]]}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[\"$L5\",[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/staticBlob/_next/static/chunks/4f1026ea77de124d.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"script\",\"script-0\",{\"src\":\"/staticBlob/_next/static/chunks/1a1cfcf10bcd6f78.js\",\"async\":true,\"nonce\":\"$undefined\"}]],[\"$\",\"$L6\",null,{\"children\":[\"$\",\"$7\",null,{\"name\":\"Next.MetadataOutlet\",\"children\":\"$@8\"}]}]]}],{},null,false,false]},null,false,false]},null,false,false]},null,false,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$L9\",null,{\"children\":\"$La\"}],[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$Lb\",null,{\"children\":[\"$\",\"$7\",null,{\"name\":\"Next.Metadata\",\"children\":\"$Lc\"}]}]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$d\",[]],\"S\":true}\n"])</script><script>self.__next_f.push([1,"e:I[35762,[\"/staticBlob/_next/static/chunks/476073a848cd7881.js\",\"/staticBlob/_next/static/chunks/1a1cfcf10bcd6f78.js\"],\"\"]\nf:I[35743,[\"/staticBlob/_next/static/chunks/476073a848cd7881.js\",\"/staticBlob/_next/static/chunks/1a1cfcf10bcd6f78.js\"],\"Image\"]\n:HL[\"/assets/blog/authors/jj.jpeg\",\"image\"]\n10:T20cfe,"])</script><script>self.__next_f.push([1,"\u003cp\u003e笔记.\u003c/p\u003e\n\u003ch1\u003e\u003cstrong\u003eC# 总结\u003c/strong\u003e\u003c/h1\u003e\n\u003chr\u003e\n\u003ch2\u003e基础\u003c/h2\u003e\n\u003ch3\u003evisual studio 2022\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cpre\u003e\u003ccode\u003ehttps://visualstudio.microsoft.com/zh-hans/vs/\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e安装 配置 基础信息  ildasm反编译工具\u003c/li\u003e\n\u003cli\u003e\n\u003cpre\u003e\u003ccode\u003e创建项目后生成一个文件夹中各个文件的含义：\n\u003c/code\u003e\u003c/pre\u003e\n.sln--解决方案文件   .csproj-项目文件    .cs--源文件   .config-配置文件   bin文件夹--可执行文件exe\nobj--中间目标文件   Properties文件夹--程序集信息文件AssemblyInfo.cs\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003evs2022常用快捷键\u003c/h4\u003e\n\u003cp\u003eshift+tab\ttab\t\tshift+up/down \t\t\tctrt+d\t\t\tshift+ctrl+l\t\talt+up/down\t\t\tctrl+k+d\u003c/p\u003e\n\u003cp\u003e反编译 ildasm\u003c/p\u003e\n\u003ch3\u003e.net 组成部分\u003c/h3\u003e\n\u003ch4\u003e.net 与.netframwork\u003c/h4\u003e\n\u003cp\u003e​\t.net是微软公司开发的跨平台、多编程语言的软件开发框架\u003c/p\u003e\n\u003cp\u003e​\t.netframwork是.net的一部分\u003c/p\u003e\n\u003ch4\u003e.netframwork：\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e类库\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e框架类库FCL（FrameWork Class language）\u003c/li\u003e\n\u003cli\u003e基础类库 BCL （Base Class Library）包含我们在程序中用到的核心功能：命名空间、类、枚举、集合、文件io、线程、进程、反射、网络等\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e公共语言运行时CLR  (Common Language Runtime)、\u003c/p\u003e\n\u003cp\u003e微软中间语言MSIL  (Microsoft intermediate Language)：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e实时编译 JIT （Just-In-Time）\u003c/li\u003e\n\u003cli\u003e垃圾回收 GC （\u003cstrong\u003eGarbage Collection\u003c/strong\u003e）\u003c/li\u003e\n\u003cli\u003e异常处理\u003c/li\u003e\n\u003cli\u003e内存管理\u003c/li\u003e\n\u003cli\u003e跨语言调试（为什么能做到，中间语言也有自己的规范：）\n\u003cul\u003e\n\u003cli\u003eCTS:Common Type System:通用类型系统-\u003e解决不同语言的数据类型问题\u003c/li\u003e\n\u003cli\u003eCLS:Common Language Specification:公共语言规范-\u003e解决不同语言的语法规范问题\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e​\u003c/p\u003e\n\u003cp\u003e![netframwork构成](D:\\project\\视觉\\笔记\\01 C#\\netframwork构成.png)\u003c/p\u003e\n\u003cp\u003e![程序运行机制](D:\\project\\视觉\\笔记\\01 C#\\程序运行机制.png)\u003c/p\u003e\n\u003ch3\u003e\u003cstrong\u003eC# 编译过程流程图\u003c/strong\u003e\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-mermaid\"\u003eflowchart TD\n    A[编写 C# 源代码] --\u003e B[C# 编译器 csc]\n    B --\u003e C[生成中间语言 IL]\n    C --\u003e D[生成程序集 .exe 或 .dll]\n    D --\u003e E[CLR 加载程序集]\n    E --\u003e F[JIT 编译 IL 为本机代码]\n    F --\u003e G[执行机器码]\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e\u003cstrong\u003e1. 基础语法\u003c/strong\u003e\u003c/h2\u003e\n\u003ch3\u003e\u003cstrong\u003e1.1 变量与数据类型\u003c/strong\u003e\u003c/h3\u003e\n\u003ch4\u003e变量三要素：\u003c/h4\u003e\n\u003cp\u003e​\t定义、赋值、使用\u003c/p\u003e\n\u003ch4\u003e变量分类：\u003c/h4\u003e\n\u003cp\u003e​\t内存有四个区：堆、栈、静态区、常量区\u003c/p\u003e\n\u003ch5\u003e\u003cstrong\u003e数值型\u003c/strong\u003e：在栈中\u003c/h5\u003e\n\u003cp\u003e栈中存的是简单数据\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e整型数值：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e有符号：有正数、负数\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003esbyte(8位/1字节);  \tshort(16位/2字节);  \tint(32位/4字节);   \tlong(64位/8个字节)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e无符号：\u003cstrong\u003e只有有正数\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003ebyte(8位/1字节); \tushort(16位/2字节）\tuint(32位/4字节) \tulong(64位/8个字节\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e浮点型数值：\u003c/p\u003e\n\u003cp\u003e​\tfloat(32位/4字节)\t\t\t单精度;\u003c/p\u003e\n\u003cp\u003e​\tdouble(64位/8字节)\t\t   双精度;\u003c/p\u003e\n\u003cp\u003e​\tdecimal(128位/16字节) \t    高精度适合财务计算;\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ebool布尔，(8位/1字节);  char字符(16位/2字节);\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eenum枚举,默认底层类型是 \u003ccode\u003eint\u003c/code\u003e;  可以通过显式指定底层类型来改变 \u003ccode\u003eenum\u003c/code\u003e 的大小\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003estruct结构体, 其大小取决于它的字段类型和内存对齐规则。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch5\u003e\u003cstrong\u003e引用类型\u003c/strong\u003e：在堆中\u003c/h5\u003e\n\u003cp\u003e堆中存的是复杂数据\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eclass 类 \t  \t\t  array 数组\t\tdelegate 委托\u003c/li\u003e\n\u003cli\u003einterface 接口\t \tstring 字符串    \tdynamic 动态类\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch5\u003e\u003cstrong\u003e隐式转换、变量常量\u003c/strong\u003e：\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e显示声明  int a=12;\u003c/li\u003e\n\u003cli\u003e隐式声明  var a=12;\u003c/li\u003e\n\u003cli\u003e常量 const string str = \"string\";\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch5\u003e\u003cstrong\u003e二进制、字节位数\u003c/strong\u003e：\u003c/h5\u003e\n\u003ch6\u003e字节\u003c/h6\u003e\n\u003col\u003e\n\u003cli\u003e最小计算机存储单位为字节(bit)，一个字节有八位如（00000001）\u003c/li\u003e\n\u003cli\u003e汉字两个字节，16位。\u003c/li\u003e\n\u003cli\u003esizeof()//获取字节数\u003c/li\u003e\n\u003cli\u003e位数是相对二进制来说的\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch6\u003e进制转换\u003c/h6\u003e\n\u003cp\u003eConvert.ToString() 可以快速转换   BitCovert 字节转换\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e二进制 ↔ 八进制     3位\u0026#x3C;-\u003e1位\n二进制 ↔ 十六进制   4位\u0026#x3C;-\u003e1位\n二进制 ↔ 十进制   每个位数的结果相加\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e\u003cstrong\u003e1.2 运算符\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e算术运算符\u003c/strong\u003e：\u003ccode\u003e+\u003c/code\u003e, \u003ccode\u003e-\u003c/code\u003e, \u003ccode\u003e*\u003c/code\u003e, \u003ccode\u003e/\u003c/code\u003e, \u003ccode\u003e%\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e比较运算符\u003c/strong\u003e：\u003ccode\u003e==\u003c/code\u003e, \u003ccode\u003e!=\u003c/code\u003e, \u003ccode\u003e\u003e\u003c/code\u003e, \u003ccode\u003e\u0026#x3C;\u003c/code\u003e, \u003ccode\u003e\u003e=\u003c/code\u003e, \u003ccode\u003e\u0026#x3C;=\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e逻辑运算符\u003c/strong\u003e：\u003ccode\u003e\u0026#x26;\u0026#x26;条件与\u003c/code\u003e, \u003ccode\u003e||条件或\u003c/code\u003e, \u003ccode\u003e!逻辑非\u003c/code\u003e，\u003ccode\u003e\u0026#x26; 逻辑与 AND\u003c/code\u003e,\u003ccode\u003e^逻辑异或\u003c/code\u003e,\u003ccode\u003e|逻辑或 OR \u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e赋值运算符\u003c/strong\u003e：\u003ccode\u003e=\u003c/code\u003e, \u003ccode\u003e+=\u003c/code\u003e, \u003ccode\u003e-=\u003c/code\u003e, \u003ccode\u003e*=\u003c/code\u003e, \u003ccode\u003e/=\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e++  --  区分前++ 后++ 的区别   --一样，前++先运算再取值，后++ 先取值后运算\u003c/li\u003e\n\u003cli\u003enull 与布尔值逻辑运算\n\u003cul\u003e\n\u003cli\u003e| x     | y     | x\u0026#x26;y   | x|y |\n| ----- | ----- | ----- | ---- |\n| true  | null  | null  | true |\n| false | null  | false | null |\n| null  | true  | null  | true |\n| null  | flase | false | null |\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e\u003cstrong\u003e1.3 字符串\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e注意\u003c/strong\u003e：尽管 string 为引用类型，但是定义相等运算符 == 和 != 是为了比较 string 对象（而不是引用）的值。\u003c/li\u003e\n\u003cli\u003e转义  \\\u003c/li\u003e\n\u003cli\u003e拼接方式：\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003e  //1. 字符串内插 {\u0026#x3C;interpolationExpression 结果的表达式\u003e[,\u0026#x3C;alignment 正数是右对齐；负数左对齐\u003e][:\u0026#x3C;formatString 格式化方式\u003e]}\n  //2. @ 逐字字符串文本\n  //3. \"\"\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e跟StringBuilder区别：string会生成一个新的内存存储，StringBuilder是在堆上修改。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e\u003cstrong\u003e1.4 流程、分支、循环语句\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e条件语句\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003e//1.if else \t2. if elseif else \t3.switch case\nif (age \u003e 18)\n{\n    Console.WriteLine(\"Adult\");\n}\nelse\n{\n    Console.WriteLine(\"Teenager\");\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e循环语句\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003e//1.for  2.foreach   3.while\t4.do while\n//await foreach\n//continue  break  return goto语句将控制权转交给带有标签的语句\n\nfor(int i=0;i\u0026#x3C;length;i++){if(a==b){goto Found;}}\nFound:\n\tConsole.Write(\"2322\")\n\nint a=0;\nwhile(a\u0026#x3C;9){ \n  a++\n}\n\nswitch(xx){ case \"\":xx break;  default:break;}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e\u003cstrong\u003e1.5 方法\u003c/strong\u003e\u003c/h3\u003e\n\u003ch4\u003e1. 方法定义\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e访问修饰符  public private  protect\u003c/li\u003e\n\u003cli\u003e返回类型：值类型、引用类型、void 无返回值类型\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-C#\"\u003e访问权限 返回值类型 方法名(形参列表)\n{\n\t方法体语句;\n}\n\nclass Count{\n    public static int Add(int a, int b)\n\t{\n\t\treturn a + b;\n\t}\n \tpublic static int Other(int a, int b,params int[] c)\n\t{\n\t\t\n\t}\n    \n    // 乱写的案例\n    public static void Test(){\n        int a=1;\n        int b=2;\n        Add(a,b);\n\t\tAdd(ref a,ref b);\n        Add(out int 3,out int 5)\n        Other(a,b,4,5,6);\n        Other(a,b,new int[]{7,8,9});\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e2.形参ref、out、params：\u003c/h4\u003e\n\u003cp\u003e​\tref(引用传递)、 out(返回多个值)、 params(可变参数)、 默认参数(用=传递)\u003c/p\u003e\n\u003ch4\u003e3. 重载\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003e方法重载就是：方法的名称一样，但是方法签名不同\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e方法签名由两部分组成：1.方法的形参列表 2.方法的名称\u003c/p\u003e\n\u003cp\u003e如果方法名一致，只要方法的形参列表不完全一致，编译器就会认为这是不同的方法签名。编译器会根 据输入的参数去调用不同方法\u003c/p\u003e\n\u003ch5\u003e3.1 普通重载：\u003c/h5\u003e\n\u003cpre\u003e\u003ccode class=\"language-C#\"\u003eclass Count{\n    public static int Add(int a, int b)\n\t{\n\t\treturn a + b;\n\t}\n\tpublic static int Add(string a, string b)\n\t{\n\t\treturn Convert.ToInt32(a) + Convert.ToInt32(b);\n\t}\n    \n    public static void Test(){\n        Add(1,2)\n\t\tAdd(\"1\",\"2\")\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch5\u003e3.2 运算符重载 operator：\u003c/h5\u003e\n\u003cpre\u003e\u003ccode class=\"language-C#\"\u003eclass Point{\n\tpublic double X { get; set; }\n\tpublic double Y { get; set; }\n\tpublic Point(double x, double y)\n\t{\n\t\tX = x;\n\t\tY = y;\n\t}\n\n    public static Point operator +(Point point1, Point point2){\n\t\treturn new Point(point1.X + point2.X, point1.Y + point2.Y);\n\t}\n}\n\n\n...\nPoint point1 = new Point(1, 2);\nPoint point2 = new Point(3, 4);\n//调用运算符重载：+\nPoint point3 = point1 + point2;\n...  \n\u003c/code\u003e\u003c/pre\u003e\n\u003ch6\u003e3.2-1注意点：\u003c/h6\u003e\n\u003cp\u003e可以重载的运算符\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e算术运算符 | + 、 - 、 * 、 / 、 ++ 、 --   |\u003c/li\u003e\n\u003cli\u003e关系运算符 | \u003e 、 \u0026#x3C; 、 \u003e= 、 \u0026#x3C;= 、 == 、 != |\u003c/li\u003e\n\u003cli\u003e逻辑运算符 | \u0026#x26; 、|、！、^                   |\u003c/li\u003e\n\u003cli\u003e位运算符   | ~                               |\u003c/li\u003e\n\u003c/ul\u003e\n\u003col\u003e\n\u003cli\u003e.不可以被重载运算符有:赋值运算符[ = ],逻辑运算符中的[ \u0026#x26;\u0026#x26; 、 || ]\u003c/li\u003e\n\u003cli\u003e关系运算符如果想重载，那么必须要\u003cstrong\u003e成对的重载\u003c/strong\u003e，例如重载了 \u003e ，则必须重载 \u0026#x3C;；有==就一定要有!=\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4\u003e4.递归：\u003c/h4\u003e\n\u003cp\u003e自己调用自己，记得退出条件\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e\u003cstrong\u003e2 各种数据操作\u003c/strong\u003e\u003c/h2\u003e\n\u003ch3\u003e\u003cstrong\u003e2.1 String常用函数\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eLength 获取字符串长度\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e+\u003c/code\u003e  连接字符串     \u003ccode\u003e+\u003c/code\u003e多次拼接效率低，大文本用\u003ccode\u003eStringBuilder\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003epublic char this[int index] { get; }  直接用索引获取字符\u003c/li\u003e\n\u003cli\u003eSubstring(int start, [int length])  截取字符串\u003c/li\u003e\n\u003cli\u003eSplit(params char[]) 分割 分隔符分割为字符串数组\u003c/li\u003e\n\u003cli\u003eString.Join(string separator, IEnumerable) 联结 常用于数组转字符串\u003c/li\u003e\n\u003cli\u003eReplace(old, new) 替换字符串内容 \u003cstrong\u003e区分大小写\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eString.Format(string format, params object[] args)\u003c/code\u003e(静态)  | 格式化字符串 使用\u003ccode\u003e{0:C}\u003c/code\u003e等占位符\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eTrim()\u003c/code\u003e / \u003ccode\u003eTrimStart()\u003c/code\u003e / \u003ccode\u003eTrimEnd()\u003c/code\u003e  去空格 去除首尾空白字符\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eContains(string)\u003c/code\u003e 包含 判断是否包含子串\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eStartsWith\u003c/code\u003e / \u003ccode\u003eEndsWith\u003c/code\u003e 查找开头/结尾匹配\u003c/li\u003e\n\u003cli\u003eCompare()/ Equals()  比较  参数规则都很多\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIndexOf\u003c/code\u003e / \u003ccode\u003eLastIndexOf\u003c/code\u003e 查找字符/子串位置           未找到时返回-1\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eToUpper()\u003c/code\u003e / \u003ccode\u003eToLower()\u003c/code\u003e 转全大写/全小写\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eToString()\u003c/code\u003e  类型转换 转为字符串（所有类型通用）\u003c/li\u003e\n\u003cli\u003eString.IsNullOrEmpty(String)  是否为null或空\u003c/li\u003e\n\u003cli\u003eString.IsNullOrWhiteSpace(String)  是否为null或空格\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e2.2 StringBuilder\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eAppend 添加字符串\u003c/li\u003e\n\u003cli\u003eInsert 插入字符串\u003c/li\u003e\n\u003cli\u003eRemove  移除字符串\u003c/li\u003e\n\u003cli\u003eReplace 替换字符串\u003c/li\u003e\n\u003cli\u003eClear 清空\u003c/li\u003e\n\u003cli\u003eEquals 比较\u003c/li\u003e\n\u003cli\u003eToString 转换为String\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e\u003cstrong\u003e2.3  enum 枚举\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eGetValues() 列举元素\u003c/li\u003e\n\u003cli\u003eGetNames() 列举名称\u003c/li\u003e\n\u003cli\u003e其他转换如下：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003epublic enum Weak{一,二,三,四,五,六,日}\n//取值\nWeak day = 周.二;\nConsole.WriteLine(day);\n\n// 遍历\nforeach (Weak i in Enum.GetValues(typeof(Weak))){Console.WriteLine(i);}\nforeach (string i in Enum.GetNames(typeof(Weak))){Console.WriteLine(i);}\nfor (int i = 0; i \u0026#x3C; 7; i++){\n     Weak dayofWeek = (Weak)i;\n     Console.WriteLine(dayofWeek);\n }\n\n//枚举转字符串\nstring dayOfWeek2 = day.ToString();\nConsole.WriteLine(dayOfWeek2);\n\n//字符串转枚举\nstring dayofWeek2 = \"四\";\nWeak dayOfWeek4 = (Weak)Enum.Parse(typeof(Weak), dayOfWeek2);\nConsole.WriteLine(dayofWeek2);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e\u003cstrong\u003e2.4 struct 结构体\u003c/strong\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e结构体是值类型  用struct修饰 ，类是引用类型  用class修饰\u003c/li\u003e\n\u003cli\u003e结构体中的成员（字段，属性）在定义的时候不能直接赋值(常量除外)，类的成员在定义的时候是可以直接赋值的\u003c/li\u003e\n\u003cli\u003e结构体也有一个默认无参构造方法，但是这个构造方法不能被覆盖的，你在定义结构体的构造方法的时候必须是有参的，而且必须全部对结构体的字段和属性赋值，类的默认无参构造方法是可以被覆盖的\u003c/li\u003e\n\u003cli\u003e结构体在定义的变量的时候，你如果访问的是字段，你可以直接定义变量后调用。如果其它成员最好new\u003cbr\u003e\n当你new的时候，还是栈中开启内存，并且调用结构体的构造方法 ，类实例化必须new 堆中开启\u003c/li\u003e\n\u003cli\u003e结构体不能有析构方法\u003c/li\u003e\n\u003cli\u003e结构体是不能继承结构体的，结构体不能继承类，但是可以继承接口（多个接口），类可以继承类，类不能继承结构体，类可以继承接口（多个）\u003c/li\u003e\n\u003cli\u003epartial同样可以修饰结构体 sealed不能修饰结构体，static不能修饰结构体但是可以修饰结构体成员\u003c/li\u003e\n\u003cli\u003e结构体变量作为索引器或者属性的时候，不能对成员直接赋值\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003epublic struct Person\n{\n    public string _name;\n    public int _age{get;set;};\n    public void _print(){Console.WriteLine(\"haha\")};\n}\n\nPerson p1 = new Person();\np1._name = \"张三\";\np1._age = 18;\np1._print();\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e\u003cstrong\u003e2.5 日期与时间操作 (System.DateTime)\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eDateTime.Now\u003c/code\u003e  获取当前时间\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eDateTime.Parse(string)\u003c/code\u003e   解析时间\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eToString(\"yyyy-MM-dd HH:mm:ss\")\u003c/code\u003e 格式化输出\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003e// 格式化日期时间示例\nDateTime now = DateTime.Now;\nstring timestamp = now.ToString(\"yyyy-MM-dd HH:mm:ss.fff\"); // 带毫秒时间戳\n\n// 计算时间差示例\nDateTime start = DateTime.UtcNow;\n// （业务操作...）\nTimeSpan duration = DateTime.UtcNow - start;\nConsole.WriteLine($\"耗时：{duration.TotalMilliseconds}ms\");\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch3\u003e\u003cstrong\u003e2.6 随机数生成 (System.Random)\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eRandom.Next()\u003c/code\u003e 生成非负随机整数 （0~\u003ccode\u003eInt32.MaxValue-1\u003c/code\u003e）\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eRandom.Next(maxValue)\u003c/code\u003e 生成[0, maxValue)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eRandom.Next(minValue, maxValue)\u003c/code\u003e 生成指定区间的整数 包含min，不包含max\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-c#\"\u003e// 生成6位随机验证码\nRandom rand = new Random();\nstring code = rand.Next(100000, 999999).ToString();\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e\u003cstrong\u003e2.7 数学操作 (System.Math)\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eAbs(x)\u003c/code\u003e 绝对值\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSign(x)\u003c/code\u003e   返回数值符号（-1,0,1）\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eMax(a,b)\u003c/code\u003e / \u003ccode\u003eMin(a,b)\u003c/code\u003e  返回两者较大/较小值\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePow(x, y)\u003c/code\u003e 计算x的y次方\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSqrt(x)\u003c/code\u003e 平方根\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eLog(x)\u003c/code\u003e / \u003ccode\u003eLog10(x)\u003c/code\u003e  | 自然对数/以10为底的对数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSin(x)\u003c/code\u003e / \u003ccode\u003eCos(x)\u003c/code\u003e / \u003ccode\u003eTan(x)\u003c/code\u003e | 三角函数计算\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eAsin(x)\u003c/code\u003e / \u003ccode\u003eAcos(x)\u003c/code\u003e / \u003ccode\u003eAtan(x)\u003c/code\u003e | 反三角函数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eRound(x, [digits])\u003c/code\u003e   | 四舍五入（可指定小数位）\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eTruncate(x)\u003c/code\u003e          | 截断小数部分\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e现代数学运算\u003c/strong\u003e → 对于复杂计算推荐使用 \u003ccode\u003eSystem.Numerics\u003c/code\u003e 命名空间中的类型（如\u003ccode\u003eVector3\u003c/code\u003e）\u003c/p\u003e\n\u003ch3\u003e\u003cstrong\u003e2.8 数组\u003c/strong\u003e\u003c/h3\u003e\n\u003ch4\u003e1 定长数组\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003enew T[size]\u003c/code\u003e            | 声明固定大小数组\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eLength\u003c/code\u003e / \u003ccode\u003eGetLength(n)\u003c/code\u003e | 获取数组长度/多维长度\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCopy(Array source, Array dest, int length)\u003c/code\u003e | 复制数组元素  可直接内存复制，效率高\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eReverse()\u003c/code\u003e              | 反转数组元素顺序                         | 支持部分区间反转\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSort()\u003c/code\u003e                 | 数组排序\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIndexOf\u003c/code\u003e / \u003ccode\u003eLastIndexOf\u003c/code\u003e | 查找元素索引\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eExists\u003c/code\u003e / \u003ccode\u003eFind\u003c/code\u003e / \u003ccode\u003eFindAll\u003c/code\u003e (需\u003ccode\u003eusing System.Collections.Generic\u003c/code\u003e) | 条件查找元素              | 使用委托/Predicate\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eToArray()\u003c/code\u003e (LINQ扩展方法) | 其他集合转数组          需引入`System.Linq\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003eint[] A; \nA = new int[3] { 1, 2, 3 };//定义数组长度，并对数组的每一个元素进行赋值\n\n//数组声明:第二种方式\nint[] B = new int[3];//定义数组长度，并对数组的每一个元素进行赋值\nB[0] = 1;\n\n//数组声明:第三种方式\nint[] C = { 1, 2, 3 };\n\n//多维数组\nint[,] B = new int[3, 4];\n\n//交错数组\nint[][] E = new int[3][] { new int[] { 1, 2, 3 }, new int[] { 4, 5 }, new int[] {\n6, 7, 8 } };\n\n//Length 是所有的长度 GetLength\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e\u003cstrong\u003e2 List\u0026#x3C;T\u003e 泛型数组\u003c/strong\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e添加元素\u003c/strong\u003e   | \u003ccode\u003elist.Add(4)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e批量添加\u003c/strong\u003e   | \u003ccode\u003elist.AddRange(new[] {4, 5})\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e插入元素\u003c/strong\u003e   | \u003ccode\u003elist.Insert(0, 0) → [0, 1, 2, 3]\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e删除元素\u003c/strong\u003e   | \u003ccode\u003elist.Remove(3)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e查找元素\u003c/strong\u003e   | \u003ccode\u003elist.Exists(x =\u003e x \u003e 2)\u003c/code\u003e\u003ccode\u003elist.Find(x =\u003e x % 2 == 0)\u0026#x3C;br/\u003e IndexOf FindIndex FindLast FindAll\u003c/code\u003e | 条件检查与元素查找\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e清空\u003c/strong\u003e       | \u003ccode\u003elist.Clear() \u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e排序列表\u003c/strong\u003e   | \u003ccode\u003elist.Sort() → [1, 2, 3]\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e批量删除\u003c/strong\u003e   | \u003ccode\u003elist.RemoveAll(x =\u003e x \u003e 2)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e列表转数组\u003c/strong\u003e | \u003ccode\u003eint[] arr = list.ToArray()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e切片\u003c/strong\u003e       | Slice (int start, int length)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e常用属性：Capacity获取最大容量、Count获取当前元素个数、this[int Index]通过索引器访问元素\u003c/p\u003e\n\u003cp\u003e常用方法：Add、AddRange、Clear、Contains、Find、FindAll、IndexOf、Insert、InsertRange、ToArray\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003eList\u0026#x3C;string\u003e fruits = new List\u0026#x3C;string\u003e { \"Apple\", \"Banana\", \"Cherry\" };\nfruits.Add(\"Orange\");\nConsole.WriteLine(fruits[1]); // 输出 Banana\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e\u003cstrong\u003e3 ArrayList 集合\u003c/strong\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e容量管理\u003c/strong\u003e   | \u003ccode\u003eCapacity\u003c/code\u003e                          | 获取或设置当前容量（初始默认 \u003ccode\u003e4\u003c/code\u003e，动态扩容时容量翻倍）。⚠️ 设置过小可能丢失数据，建议优先用 \u003ccode\u003eTrimToSize\u003c/code\u003e。 |\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eTrimToSize()\u003c/code\u003e                      | 将容量压缩到实际元素数量 \u003ccode\u003eCount\u003c/code\u003e。⚠️ 频繁调用可能降低性能。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e元素数量\u003c/strong\u003e   | \u003ccode\u003eCount\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e添加元素\u003c/strong\u003e   | \u003ccode\u003eAdd(object value)\u003c/code\u003e⚠️ 值类型会\u003cstrong\u003e装箱\u003c/strong\u003e，需注意类型转换异常。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eAddRange(ICollection c)\u003c/code\u003e           | 批量添加集合元素。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eInsert(int index, object value)\u003c/code\u003e   | 在指定位置插入元素。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eRemove(object value)\u003c/code\u003e              | 删除第一个匹配的元\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eRemoveAt(int index)\u003c/code\u003e               | 删除指定位置的元素。⚠️ 越界会抛出 \u003ccode\u003eArgumentOutOfRangeException\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eRemoveRange(int index, int count)\u003c/code\u003e | 删除从指定位置开始的连续多个元素。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eClear()\u003c/code\u003e                           | 清空所有元素（容量 \u003ccode\u003eCapacity\u003c/code\u003e 保持不变）\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eContains(object value)\u003c/code\u003e            | 判断是否包含元素。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIndexOf(object value)\u003c/code\u003e             | 返回第一个匹配元素\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eLastIndexOf(object value)\u003c/code\u003e         | 返回最后一个匹配元素的索引。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSort()\u003c/code\u003e                            | 对所有元素排序（依赖元素的 \u003ccode\u003eIComparable\u003c/code\u003e 接口）混合类型时可能抛出 \u003ccode\u003eInvalidOperationException\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSort(IComparer comparer)\u003c/code\u003e          | 使用自定义比较器排序\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eReverse()\u003c/code\u003e                         | 反转所有元素的顺序。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ethis[int index]\u003c/code\u003e                   | 通过索引访问或修改元素。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eToArray()\u003c/code\u003e                         | 转换为 \u003ccode\u003eobject[]\u003c/code\u003e 数组。⚠️ 值类型元素需手动拆箱。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eToArray(Type type)\u003c/code\u003e                | 转换为指定类型数组（如 \u003ccode\u003eToArray(typeof(int))\u003c/code\u003e） 类型错误会抛出 \u003ccode\u003eInvalidCastException\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eClone()\u003c/code\u003e                           | 浅拷贝创建一个新 \u003ccode\u003eArrayList\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e常用属性：Capacity获取最大容量、Count获取当前元素个数、this[int Index]通过索引器访问元素\u003c/p\u003e\n\u003cp\u003e常用方法：Add、AddRange、Clear、Insert、Remove、RemoveAt\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003eList\u0026#x3C;string\u003e fruits = new List\u0026#x3C;string\u003e { \"Apple\", \"Banana\", \"Cherry\" };\nfruits.Add(\"Orange\");\nConsole.WriteLine(fruits[1]); // 输出 Banana\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e\u003cstrong\u003e4. 各个数组差异比较\u003c/strong\u003e\u003c/h4\u003e\n\u003ch5\u003e\u003cstrong\u003e1. 基本特性比较\u003c/strong\u003e\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eint[]\u003c/code\u003e\u003c/strong\u003e 数组是固定长度；**\u003ccode\u003eList\u0026#x3C;T\u003e\u003c/code\u003e\u003cstrong\u003e可以自动扩容；\u003c/strong\u003e\u003ccode\u003eArrayList\u003c/code\u003e**可以自动扩容\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eArrayList\u003c/code\u003e\u003cstrong\u003e支持任意类型；\u003c/strong\u003e\u003ccode\u003eint[]\u003c/code\u003e\u003c/strong\u003e 、\u003cstrong\u003e\u003ccode\u003eList\u0026#x3C;T\u003e\u003c/code\u003e\u003c/strong\u003e 只能约束的类型\u003c/li\u003e\n\u003cli\u003e都支持linq\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eint[]\u003c/code\u003e\u003c/strong\u003e 性能速度最快，**\u003ccode\u003eArrayList\u003c/code\u003e**有装拆箱性能损耗\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e\u003cstrong\u003e2.9 Dictionary字典\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e添加键值对\u003c/strong\u003e         | \u003ccode\u003edict.Add(\"Key\", 100)\u003c/code\u003e\u003ccode\u003edict[\"Key\"] = 100\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e删除键值对\u003c/strong\u003e         | \u003ccode\u003edict.Remove(\"Key\")\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e检查包含键/值\u003c/strong\u003e      | \u003ccode\u003edict.ContainsKey(\"Key\")\u003c/code\u003e\u003ccode\u003edict.ContainsValue(100)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e安全获取值\u003c/strong\u003e         | \u003ccode\u003eif (dict.TryGetValue(\"Key\", out int val)) { ... }\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e遍历字典\u003c/strong\u003e           | \u003ccode\u003eforeach (var kvp in dict) { kvp.Key, kvp.Value }\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e字典转列表\u003c/strong\u003e         | \u003ccode\u003eList\u0026#x3C;string\u003e keys = dict.Keys.ToList();\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e清空字典\u003c/strong\u003e           | \u003ccode\u003edict.Clear()\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003eDictionary\u0026#x3C;string, int\u003e ages = new Dictionary\u0026#x3C;string, int\u003e\n{\n    { \"Alice\", 25 },\n    { \"Bob\", 30 }\n};\nConsole.WriteLine(ages[\"Alice\"]); // 输出 25\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch3\u003e\u003cstrong\u003e3.0 队列(Queue)操作\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eEnqueue(T)\u003c/code\u003e      | 入队（添加到队尾）\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eDequeue()\u003c/code\u003e       | 移除并返回队首元素  \u003cstrong\u003e队列为空时抛异常\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePeek()\u003c/code\u003e          | 查看队首元素但不移除\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCount\u003c/code\u003e           | 获取元素数量\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eClear()\u003c/code\u003e         | 清空队列\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eContains(T)\u003c/code\u003e     | 判断元素是否存在\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eToArray()\u003c/code\u003e       | 将队列转为数组\u003c/li\u003e\n\u003c/ul\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e集合初始化语法\u003c/strong\u003e → \u003ccode\u003eQueue\u0026#x3C;int\u003e q = new Queue\u0026#x3C;int\u003e(new[] {1,2,3});\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e数组与集合转换\u003c/strong\u003e → 使用LINQ提供的\u003ccode\u003eToList()\u003c/code\u003e、\u003ccode\u003eToArray()\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e\u003cstrong\u003e3.1 栈 Stack\u0026#x3C;T\u003e\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePush(T)\u003c/code\u003e         | 入栈（添加到栈顶）\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePop()\u003c/code\u003e           | 移除并返回栈顶元素                       | \u003cstrong\u003e栈为空时抛异常\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePeek()\u003c/code\u003e          | 查看栈顶元素但不移除\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCount\u003c/code\u003e           | 获取元素数量\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eClear()\u003c/code\u003e         | 清空栈\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eContains(T)\u003c/code\u003e     | 判断元素是否存在                         | 效率为O(n)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eToArray()\u003c/code\u003e       | 将栈转为数组                             | 元素顺序为出栈顺序（倒序）\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e\u003cstrong\u003e3. 面向对象编程\u003c/strong\u003e\u003c/h2\u003e\n\u003ch3\u003e\u003cstrong\u003e1 类与对象\u003c/strong\u003e\u003c/h3\u003e\n\u003ch4\u003e\u003cstrong\u003e1.1类的定义\u003c/strong\u003e：\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003e访问权限 class 类名{\n\t类成员\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e**1.2类的实例化 **：\u003c/h4\u003e\n\u003cp\u003e实例化的本质，其实一共就干了三件事情:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e在堆中申请一块内存空间\u003c/li\u003e\n\u003cli\u003e在这块内存空间按照类的定义进行分配\u003c/li\u003e\n\u003cli\u003e调用类的构造函数\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003e语法定义格式：\n类名 对象名 = new 类名()\nPerson person = new Person { Name = \"Alice\", Age = 30 };\n\n在使用new的时候才会去开辟内存空间而且是在堆中申请的，类是引用类型：地址在栈上，内容在堆中。\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e2 构造方法\\函数：\u003c/h4\u003e\n\u003ch5\u003e2.1定义：\u003c/h5\u003e\n\u003cp\u003e​\t在构建对象的时候，会自动调用的方法，所以叫构造方法。\u003cstrong\u003e构造方法可以有return也可以没有return，但不能返回值，构造方法时没有返回值的。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e​\u003c/p\u003e\n\u003ch4\u003e3 this的作用：\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e指向当前类的对象\u003c/li\u003e\n\u003cli\u003e显式调用另外一个构造函数\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-C#\"\u003eclass Person\n{\n\tpublic string _name;\n\tpublic int _age;\n\tpublic string _address;\n\n\tpublic Person():this(\"小白\",18)// 调用其他构造\n\t{\n\t\tConsole.WriteLine(\"我是无参的构造函数：Person()\");\n\t}\n\tpublic Person(string name,int age)\n\t{\n\t\tConsole.WriteLine(\"我是有参构造函数：Person(string name,int age)\");\n\t\tthis._name = name;\n\t\tthis._age = age;\n\t}\n\tpublic Person(string name, int age, string address) : this(name, age)\n\t{\n\t\tConsole.WriteLine(\"我是有参构造函数：Person(string name, int age, string address)\");\n\t\t_address = address;\n\t}\n}\ninternal class Program\n{\n\tstatic void Main(string[] args)\n\t{\n\t\tPerson person1 = new Person();\n\t\tPerson person2 = new Person(\"嘉嘉\",18,\"深圳市-龙华\");\n\t\tConsole.ReadKey();\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e4 析构方法/析构函数：\u003c/h4\u003e\n\u003cp\u003e所谓的析构方法就是类对象，生命周期结束时。会自动调用的方法,\u003cstrong\u003e在类名前加波浪符号~\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-C#\"\u003epublic class TEST\n{\n\tpublic TEST()\n\t{\n\t\tConsole.WriteLine(\"默认无参构造函数\");\n\t}\n\t~TEST()\n\t{\n\t\tConsole.WriteLine(\"析构函数被调用\");\n\t}\n}\ninternal class Program\n{\n\tstatic void Main(string[] args)\n\t{\n\t\tTEST test= new TEST();\n\t//Console.ReadKey();\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e\u003cstrong\u003e2 命名空间\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e命名空间就是你要声明的命名空间名字。命名空间整格式是 using 命名空间;\u003c/p\u003e\n\u003ch4\u003e用法：\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e同一命名空间下\u003c/li\u003e\n\u003cli\u003e不同命名空间怎么引入\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e\u003cstrong\u003e3 静态非静态\u003c/strong\u003e\u003c/h3\u003e\n\u003ch4\u003estatic关键字：\u003c/h4\u003e\n\u003cp\u003e​\t修饰属性、方法、类\u003c/p\u003e\n\u003cp\u003e​\t**核心点：**只要是被static所修饰的。\u003cstrong\u003e就会在启动的这个程序整个生命周期都是存在的\u003c/strong\u003e。会消耗大量的内存，影响程序的性能。\u003c/p\u003e\n\u003ch4\u003e注意点：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e静态方法中只能调用静态的成员，不允许调用非静态的成员\u003c/li\u003e\n\u003cli\u003e静态构造函数只会被调用一次，在类的静态成员被调用的时候会至多触发一次\u003c/li\u003e\n\u003cli\u003e如果想在静态方法中调用非静态的字段就必须申请内存(new)，在通过对象访问成员。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e静态类中的成员必须全部都是静态成员\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e4 类属性\u003c/h3\u003e\n\u003ch4\u003eget\\set 取值赋值\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e自动属性：默认都有\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-C#\"\u003eclass Person\n{\n\tpublic string Name{get;set;}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e只读、只写\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-C#\"\u003eclass Person\n{\n\tpublic string Name{get;}//只读\n}\nclass Person\n{\n\tpublic string Name{set;}//只写\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e操作：关键字value\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-C#\"\u003eclass Person\n{\n\t public string Name\n \t{\n     \tget {\n            //....do something\n         \treturn Name;\n    \t}\n     \tset\n     \t{\n         \t//....do something\n        \tName = value;\n     \t}\n }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e索引器\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003e语法：\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n访问权限 数据类型 this[[索引数据类型] 索引变量]\n{\n\tget\n\t{\n\t\treturn 变量;\n\t}\n\tset\n\t{\n\t\t变量=value;\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-C#\"\u003eclass Person\n{\n    char[] _show = { '就', '是', '有', '这', '种', '操', '作', '!' };\n\tchar[] _infoArray = { '鸡', '你', '太', '美', '！'};\n\n\t public char this[int type,int index] //可以指定任意类型字段\n \t{\n     \tget {\n           switch(type){\n               case 1:\n                  // retrun _show[index]; //也可以做一些判断数组越界之类的\n\t\t\t\t\treturn index\u003e_show.Length?\"获取的数据超出范围\": _show[index]\n               case 2:\n                   retrun _infoArray[index];\n           }\n    \t}\n     \tset\n     \t{\n         \t//....同上面\n     \t}\n }\n}\n//用法\nPerson p1=new Person();\np1[0,1]//取值\np1[1,1]=xxx//赋值\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e\u003cstrong\u003e5 分布类/部分类\u003c/strong\u003e\u003c/h3\u003e\n\u003ch4\u003e关键字partial\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-C#\"\u003e//a 文件\npartial class Person\n{\n\tpublic string Name{\n\t\tget { return _name; }\n\t\tset { _name = value; }\n\t}\n\tpublic int Age;\n}\n//b 文件，可以不在不同地方同用一个类\npartial class Person\n{\n\tpublic  void getName(){\n        return this._name;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e**注意点：**必须在同一命名空间下\u003c/p\u003e\n\u003ch3\u003e\u003cstrong\u003e6 类与成员的访问权限、行为修饰符\u003c/strong\u003e\u003c/h3\u003e\n\u003ch4\u003e\u003cstrong\u003e1. 访问修饰符\u003c/strong\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e类访问权限\u003c/strong\u003e\n| \u003cstrong\u003e修饰符\u003c/strong\u003e     | \u003cstrong\u003e范围\u003c/strong\u003e                                      | \u003cstrong\u003e示例\u003c/strong\u003e                           |\n|----------------|----------------------------------------------|------------------------------------|\n| \u003ccode\u003epublic\u003c/code\u003e       | 任何代码均可访问                              | \u003ccode\u003epublic class MyClass { ... }\u003c/code\u003e     |\n| \u003ccode\u003einternal\u003c/code\u003e | 在本项目里面可以访问 | \u003ccode\u003einternal class Helper\u003c/code\u003e        |\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e类成员访问权限\u003c/strong\u003e\n| \u003cstrong\u003e修饰符\u003c/strong\u003e     | \u003cstrong\u003e范围\u003c/strong\u003e                                      | \u003cstrong\u003e示例\u003c/strong\u003e                           |\n|----------------|----------------------------------------------|------------------------------------|\n| \u003ccode\u003epublic\u003c/code\u003e       | 任何代码均可访问                              | public string name; |\n| \u003ccode\u003eprivate\u003c/code\u003e      | 仅定义该成员的类内部可用（默认类成员修饰符） | private int age; |\n| \u003ccode\u003eprotected\u003c/code\u003e    | 类内部及其派生类可用                          | protected string address; |\n| \u003ccode\u003einternal\u003c/code\u003e     | 内部的，仅限于本类访问               | internal string PhoneNumber |\n| \u003ccode\u003eprotected internal\u003c/code\u003e | 同一程序集或派生类（逻辑或）            | protected internal string Email; |\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e\u003cstrong\u003e2. 类与成员行为修饰符\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e| \u003cstrong\u003e修饰符\u003c/strong\u003e | \u003cstrong\u003e用途\u003c/strong\u003e                                   | \u003cstrong\u003e示例\u003c/strong\u003e                           |\n| ---------- | ------------------------------------------ | ---------------------------------- |\n| \u003ccode\u003esealed\u003c/code\u003e   | 密封类，禁止类被继承或方法被重写           | \u003ccode\u003epublic sealed class FinalClass\u003c/code\u003e   |\n| \u003ccode\u003estatic\u003c/code\u003e   | 定义静态类或成员（无需实例化直接调用）     | \u003ccode\u003epublic static class MathUtils\u003c/code\u003e    |\n| \u003ccode\u003eabstract\u003c/code\u003e | 定义抽象类或抽象方法                       | \u003ccode\u003epublic abstract class BaseModel\u003c/code\u003e  |\n| \u003ccode\u003evirtual\u003c/code\u003e  | 允许方法被子类重写                         | \u003ccode\u003epublic virtual void Calculate()\u003c/code\u003e  |\n| \u003ccode\u003eoverride\u003c/code\u003e | 重写基类虚方法或抽象方法                   | \u003ccode\u003epublic override void Calculate()\u003c/code\u003e |\n| \u003ccode\u003enew\u003c/code\u003e      | 隐藏基类同名成员                           | \u003ccode\u003epublic new void Execute()\u003c/code\u003e        |\n| \u003ccode\u003epartial\u003c/code\u003e  | 拆分类到多个文件（常用于自动生成代码扩展） | \u003ccode\u003epublic partial class DataModel\u003c/code\u003e   |\u003c/p\u003e\n\u003ch3\u003e\u003cstrong\u003e7 只读 readonly\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e定义类的成员   ---修饰字段（const也是修饰字段）\n权限  readonly 类型名字  字段名=值;\u003c/p\u003e\n\u003cp\u003e对比const:\n1 readony修饰在类中，const修饰可以在类中，也可以在main中（修饰局部变量）\n2 它们都修饰字段\n3 const编译性常量  readonly 运行时常量（推荐使用--性能高点）\n4 const修饰的字段定义的时候必须赋初始值，后面不能改。readonly 定义的时候可以赋值也可以不赋值，readonly修饰的字段可以在构造方法中再次修改一次，这里修改了后面就不能修改了\n5 readonly可以static修饰的 ，但是如果你定义成静态的readonly，在构造方法初始化的话你必须在静态构造方法中初始化。const是不可以用static修饰\u003c/p\u003e\n\u003ch3\u003e\u003cstrong\u003e8 继承（Inheritance）\u003c/strong\u003e\u003c/h3\u003e\n\u003ch4\u003e\u003cstrong\u003e1. 基本概念\u003c/strong\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e继承的本质\u003c/strong\u003e：子类（派生类）自动获取父类（基类）的 \u003cstrong\u003e字段、方法\u003c/strong\u003e（非私有成员），并可扩展或修改行为。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e语法\u003c/strong\u003e：使用 \u003ccode\u003e:\u003c/code\u003e 符号声明继承关系。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003epublic class Animal  // 基类\n{\n    public string Name { get; set; }\n    public void Eat() =\u003e Console.WriteLine(\"吃食物\");\n}\n\npublic class Dog : Animal  // 子类继承Animal\n{\n    public void Bark() =\u003e Console.WriteLine(\"汪汪！\");\n}\n\n// 使用\nvar dog = new Dog();\ndog.Eat();  // 继承自Animal类的方法\ndog.Bark(); // Dog类自身的方法\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e\u003cstrong\u003e2. 继承链的规则\u003c/strong\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e单根性\u003c/strong\u003e：C#不支持类的多继承（一个类只能有一个直接基类）。重点核心\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e可传递性\u003c/strong\u003e：允许链式继承（如 \u003ccode\u003eA → B → C\u003c/code\u003e），C会有A的共有与受保护成员。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eobject类\u003c/strong\u003e：所有类的隐式基类（最终基类）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e\u003cstrong\u003e3. 构造函数的执行顺序\u003c/strong\u003e\u003c/h4\u003e\n\u003ch5\u003e3.1 实例化子类的本质\u003c/h5\u003e\n\u003cp\u003e基类构造函数优先执行（默认调用无参构造函数），也就是说会先构造父类然后才到子类。\u003c/p\u003e\n\u003ch5\u003e3.2 base的两个作用：\u003c/h5\u003e\n\u003cp\u003e\u003cstrong\u003e1调用父类中的构造方法、2调用了父类的方法\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003epublic class Animal \n{\n    public Animal(string name) =\u003e Name = name;\n    public void Print(){Console.WriteLine(\"Animal\")}\n}\n\npublic class Dog : Animal \n{\n    public Dog(string name, string breed) : base(name) // 1 传递name到基类构造函数\n    {\n        Breed = breed;\n    }\n    public void Print(){base.Print();};//2 调用了父类的方法\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e4.\u003cstrong\u003e里氏转换\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e如下面的例子：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-C#\"\u003eclass Friut{}\nclass Apple:Friut{\n\tpublic void AppleEat(){\n        Console.WriteLine(\"我是苹果的吃法！\");\n    }\n}\nclass Banana:Friut{\n\tpublic void BananaEat(){\n        Console.WriteLine(\"我是香蕉的吃法！\");\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch5\u003e普通写法与里氏转换：\u003c/h5\u003e\n\u003cp\u003e里氏转换：\u003cstrong\u003e父类可以装上一个子类对象，从而提高程序的拓展性\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-C#\"\u003e//正常写法：需要每个子类都声明\nApple a=new Apple();\na.AppleEat();\nBanana b=new Banana();\nb.BananaEat();\n\n//里氏转换方式\nFriut[] friuts={new Apple(),new Banana()};\n(Apple(friuts[0])).AppleEat();\n(Banana(friuts[1])).BananaEat();\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch5\u003eis关键字、as关键字\u003c/h5\u003e\n\u003cp\u003e上面强制转换不优雅，用is或as关键来\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-C#\"\u003eforeach (var friut in friuts)\n{\n   //方式1 is关键字写法，并且赋值变量\n   if (friut is Apple a){a.AppleEat();}\n   if (friut is Banana b){b.BananaEat();}\n    \n   //方法2 as写法，as转换类型，如果转换不了就为null\n   (friut as Apple)?.AppleEat();\n   (friut as Banana)?.BananaEat();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch3\u003e\u003cstrong\u003e9 多态性（Polymorphism）\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e多态性的本质\u003c/strong\u003e：实现与拓展不同的功能；子类（派生类）自动获取父类（基类）的 \u003cstrong\u003e字段、方法\u003c/strong\u003e（非私有成员），它允许将子类对象视为父类对象，从而在运行时确定具体调用哪个类的方法。\u003c/p\u003e\n\u003ch4\u003e\u003cstrong\u003e1. 虚方法（Virtual Methods）\u003c/strong\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e用途\u003c/strong\u003e：允许子类重写父类方法实现。（\u003cstrong\u003e选择性\u003c/strong\u003e，可以重写可以不重写）\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e关键字\u003c/strong\u003e：\u003ccode\u003evirtual\u003c/code\u003e（父类声明方法）+ \u003ccode\u003eoverride\u003c/code\u003e（子类重写）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003epublic class Animal \n{\n    public virtual void MakeSound() =\u003e Console.WriteLine(\"默认声音\");\n}\n\npublic class Dog : Animal \n{\n    public override void MakeSound() =\u003e Console.WriteLine(\"汪汪！\");\n}\n\n// 使用多态\nAnimal animal = new Dog();\nanimal.MakeSound(); // 输出\"汪汪！\" （动态绑定）\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e\u003cstrong\u003e2. 抽象类、抽象方法（Abstract）\u003c/strong\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e抽象类\u003c/strong\u003e：不能被实例化，只能作为基类。（\u003cstrong\u003e强制性\u003c/strong\u003e）\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e抽象方法\u003c/strong\u003e：\u003cstrong\u003e仅定义签名，无实现\u003c/strong\u003e，必须被子类重写。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003epublic abstract class Shape \n{\n    public abstract double GetArea();  // 抽象方法\n}\n\npublic class Circle : Shape \n{\n    public double Radius { get; set; }\n    public override double GetArea() =\u003e Math.PI * Radius * Radius;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e\u003cstrong\u003e3. 接口（Interfaces）\u003c/strong\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e与抽象类的区别\u003c/strong\u003e：接口只包含方法签名和属性，无实现，支持多重继承。 (\u003cstrong\u003e扩展性\u003c/strong\u003e)\u003c/li\u003e\n\u003cli\u003e可以很好的隔离不同类之间的联系，减少类和类之间耦合性\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003epublic interface IFlyable \n{\n    void Fly();  // 默认隐式为 public\n}\n\npublic class Bird : Animal, IFlyable  // 多接口继承\n{\n    public void Fly() =\u003e Console.WriteLine(\"飞行中\");\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch3\u003e\u003cstrong\u003e10 类的运算符重载\u003c/strong\u003e\u003c/h3\u003e\n\u003ch4\u003e1. 运算符重载\u003c/h4\u003e\n\u003cp\u003e​\t查看方法的运算符重载，一样的。\u003c/p\u003e\n\u003ch4\u003e\u003cstrong\u003e2. implicit\u003c/strong\u003e隐式转换、explicit显式转换\u003c/h4\u003e\n\u003cp\u003e下面是一个米--》千米，千米--》米的例子：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-C#\"\u003epublic class Meter\n{\n\tpublic double Value { get; set; }\n\tpublic Meter(double value){Value = value;}\n\t//定义从Meter到Kilometer的隐式转换\n    public static implicit operator Kilometer(Meter meter){\n\t\treturn new Kilometer(meter.Value/1000.0);\n\t}\n    //定义从Meter到Kilometer的显式转换\n    public static explicit operator Kilometer(Meter meter){\n\t\treturn new Kilometer(meter.Value/1000.0);\n\t}\n}\n\npublic class KiloMeter\n{\n\tpublic double Value { get; set; }\n\tpublic Meter(double value){Value = value;}\n\t//定义从Meter到Kilometer的隐式转换\n    public static implicit operator Kilometer(Meter meter){\n\t\treturn new Kilometer(meter.Value/1000.0);\n\t}\n    //定义从Meter到Kilometer的显式转换\n    public static explicit operator Kilometer(Meter meter){\n\t\treturn new Kilometer(meter.Value/1000.0);\n\t}\n}\n\nMeter m=new Meter(1000);\nKiloMeter km=m;// 隐式转换\nKiloMeter km=(KiloMeter)m;// 显式转换\n\nKiloMeter km=new KiloMeter(1);\nMeter m=km;// 隐式转换\nMeter m=(Meter)km;// 显式转换\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch3\u003e\u003cstrong\u003e11 装箱拆箱、泛型\u003c/strong\u003e\u003c/h3\u003e\n\u003ch4\u003e1.装箱拆箱\u003c/h4\u003e\n\u003cp\u003e所有类型的基类是object，也就是说object类可以转任意类型；\n装箱: 将值类型转换为引用类型；拆箱: 将引用类型转换为值类型\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-C#\"\u003e//引用类型\nobject obj = null;\n//值类型\nint num = 10;\n//装箱： 将值类型转换为引用类型\nobj = num;\nConsole.WriteLine(\"装箱:\" + obj);\n\n//引用类型\nobject obj2 = 20;\n//值类型\nint num2;\n//拆箱： 将引用类型转换为值类型\n num2 = (int)obj2;\nConsole.WriteLine(\"拆箱:\" + num2);\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch5\u003e装拆箱的问题：\u003c/h5\u003e\n\u003cp\u003e性能损耗太严重\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-C#\"\u003eobject[] objArray = new object[100000000];\nint[] intArray = new int[100000000];\nStopwatch sw = new Stopwatch();\nsw.Start(); \nobject obj = 1;\nfor (int i = 0; i \u0026#x3C; intArray.Length; i++)\n{\n    intArray[i] = (int)obj;//拆箱\n}\nsw.Stop();\nConsole.WriteLine(\"共消耗:{0}\",sw.Elapsed);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e2.泛型\u003c/h4\u003e\n\u003cp\u003e频繁装箱拆箱操作太损耗性能。但有些地方却又不能提前声明类型，这需要泛型。泛型可以把类型延迟到使用的时候注入。\u003c/p\u003e\n\u003ch5\u003e泛型约束\u003c/h5\u003e\n\u003cp\u003e泛型约束（where T : constraint）中的约束类型必须是接口、非密封类或者另一个类型参数.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-C#\"\u003eclass MyClass\u0026#x3C;T\u003e where T : struct \n{\n    // T 必须是值类型,只能限制到struct 这一层 \n    //int、string、float、double些是密封类（通过使用sealed关键字），这意味着它不能被继承，因此不能被用作泛型约束\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-C#\"\u003eclass TestClass\u0026#x3C;T, P\u003ewhere T : class, new() where P : struct\n {\n     public void Show(T t, P p)\n     {\n         Console.WriteLine(\"Hello, \" + t.ToString() + \" \" + p.ToString());\n     }\n }\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch5\u003e常用的约束：\u003c/h5\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e类型约束\u003c/strong\u003e（\u003ccode\u003ewhere T : MyBaseClass\u003c/code\u003e）\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e接口约束\u003c/strong\u003e（\u003ccode\u003ewhere T : IMyInterface\u003c/code\u003e）\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e值类型约束\u003c/strong\u003e（\u003ccode\u003ewhere T : struct\u003c/code\u003e）\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e引用类型约束\u003c/strong\u003e（\u003ccode\u003ewhere T : class\u003c/code\u003e）\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e无参构造函数约束\u003c/strong\u003e（\u003ccode\u003ewhere T : new()\u003c/code\u003e）\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e多种约束\u003c/strong\u003e（\u003ccode\u003ewhere T : MyBaseClass, IMyInterface, new()\u003c/code\u003e）\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4\u003e3 协变out、逆变in\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003e协变：IFoo\u0026#x3C;父类\u003e = IFoo\u0026#x3C;子类\u003e；\u003c/strong\u003e 本该** 输出** 传父类的地方传子类,** out 关键字**\n\u003cstrong\u003e逆变：IBar\u0026#x3C;子类\u003e = IBar\u0026#x3C;父类\u003e；\u003cstrong\u003e本该\u003c/strong\u003e 输入\u003c/strong\u003e 传子类的地方传父类，** in 关键字**\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e只能针对泛型接口或者委托\u003c/strong\u003e，\u003cstrong\u003e不能针对泛型类\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-C#\"\u003e//协变 out 输出位置\n    interface IFoo\u0026#x3C;out T\u003e { T GetName(); }\n    class Foo:IFoo\u0026#x3C;string\u003e{\n    \tpublic string GetName(){return GetType().Name;}\n    }\n\t....\n\tIFoo\u0026#x3C;string\u003e fooStr=new Foo();\n\tIFoo\u0026#x3C;object\u003e fooObj=fooStr;//\n\tConsole.WriteLine(fooObj.GetName());  //因为要输出object类型，实际下会进行隐式转换：(Object)(new Foo().GetName())\n\n//逆变  in  输入位置\n    interface IBar\u0026#x3C;in T\u003e { void Print(T Content); }\n    class Bar:IBar\u0026#x3C;object\u003e{\n    \tpublic void Print(object Content){Console.WriteLine(Content);}\n    }\n\t....\n\tIBar\u0026#x3C;object\u003e barObj=new Bar();\n\tIBar\u0026#x3C;string\u003e barStr=barObj;//\n\tbarStr.Print(\"haha\");  //因为要输入object类型，实际下会对输入的字符串进行隐式转换：new Bar().Print((object)(\"haha\"))\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch3\u003e\u003cstrong\u003e11 关键特性对比与陷阱\u003c/strong\u003e\u003c/h3\u003e\n\u003ch4\u003e\u003cstrong\u003e1. \u003ccode\u003eoverride\u003c/code\u003e vs \u003ccode\u003enew\u003c/code\u003e修饰符\u003c/strong\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eoverride\u003c/code\u003e\u003c/strong\u003e：完全替换基类方法（多态生效）。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003enew\u003c/code\u003e\u003c/strong\u003e：隐藏基类方法（若通过基类引用调用，仍执行基类版本）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003epublic class Base \n{\n    public void Show() =\u003e Console.WriteLine(\"Base\");\n}\n\npublic class Derived : Base \n{\n    public new void Show() =\u003e Console.WriteLine(\"Derived\"); // 隐藏而非重写\n}\n\n// 测试\nBase obj = new Derived();\nobj.Show(); // 输出\"Base\" （静态绑定）\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e\u003cstrong\u003e2. 抽象类 vs 接口\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e| \u003cstrong\u003e特性\u003c/strong\u003e               | \u003cstrong\u003e抽象类\u003c/strong\u003e                          | \u003cstrong\u003e接口\u003c/strong\u003e                          |\n|------------------------|-------------------------------------|-----------------------------------|\n| 实现方法               | 可以包含具体方法                    | 默认无实现（C# 8开始支持默认实现）|\n| 成员类型               | 可包含字段、构造函数                | 仅方法、属性、索引器、事件        |\n| 多继承                 | 不支持                              | 支持多继承                        |\n| 设计侧重点             | “是什么”（Is-a 关系）               | “能做什么”（行为契约）            |\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e\u003cstrong\u003e5 异常处理\u003c/strong\u003e\u003c/h2\u003e\n\u003ch3\u003e5.1 \u003cstrong\u003e捕获异常\u003c/strong\u003e\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003etry\n{\n    int result = 10 / 0;\n}\ncatch (DivideByZeroException ex)\n{\n    Console.WriteLine(\"Error: \" + ex.Message);\n}\nfinally\n{\n    Console.WriteLine(\"Finally block executed\");\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e5.2 \u003cstrong\u003e抛出异常\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003ethrow new ArgumentException(\"invalid param\");\u003c/code\u003e 返回指定的异常类型和错误消息。\u003c/p\u003e\n\u003ch3\u003e5.3 \u003cstrong\u003e自定义异常\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e自定义异常类（继承 \u003ccode\u003eException\u003c/code\u003e）\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e`public class MyException : Exception { ... }`\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e\u003cstrong\u003e6 文件操作\u003c/strong\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e核心命名空间\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003eusing System.IO;        // 基础文件操作\nusing System.Text;      // 编码处理\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e6.1. 文件系统操作\u003c/h3\u003e\n\u003ch4\u003e6.1.1 File类\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e常用静态方法\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eCreate/Delete：创建/删除文件\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003etry\n{\n    // 创建文件\n    string filePath = Path.Combine(Environment.CurrentDirectory, \"test.txt\");\n    using (File.Create(filePath)) { }\n    Console.WriteLine($\"文件已创建: {filePath}\");\n\n    // 删除文件\n    if (File.Exists(filePath))\n    {\n        File.Delete(filePath);\n        Console.WriteLine(\"文件已删除\");\n    }\n}\ncatch (IOException ex)\n{\n    Console.WriteLine($\"文件操作失败: {ex.Message}\");\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eCopy/Move：复制/移动文件\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003etry\n{\n    string sourceFile = \"source.txt\";\n    string destFile = \"dest.txt\";\n    string movedFile = \"moved.txt\";\n\n    // 创建示例文件\n    File.WriteAllText(sourceFile, \"Hello World!\");\n\n    // 复制文件（如果目标存在则覆盖）\n    File.Copy(sourceFile, destFile, true);\n    Console.WriteLine($\"文件已复制到: {destFile}\");\n\n    // 移动文件\n    File.Move(destFile, movedFile);\n    Console.WriteLine($\"文件已移动到: {movedFile}\");\n}\ncatch (Exception ex)\n{\n    Console.WriteLine($\"操作失败: {ex.Message}\");\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eExists：检查文件是否存在\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003estring filePath = @\"C:\\example\\test.txt\";\nif (File.Exists(filePath))\n{\n    Console.WriteLine(\"文件存在\");\n}\nelse\n{\n    Console.WriteLine(\"文件不存在\");\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eGetAttributes/SetAttributes：获取/设置文件属性\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003etry\n{\n    string filePath = \"test.txt\";\n    \n    // 创建文件并设置属性\n    using (File.Create(filePath)) { }\n    \n    // 设置文件属性（只读和隐藏）\n    File.SetAttributes(filePath, FileAttributes.ReadOnly | FileAttributes.Hidden);\n\n    // 获取文件属性\n    FileAttributes attrs = File.GetAttributes(filePath);\n    Console.WriteLine($\"文件属性: {attrs}\");\n\n    // 检查是否为只读\n    bool isReadOnly = (attrs \u0026#x26; FileAttributes.ReadOnly) == FileAttributes.ReadOnly;\n    Console.WriteLine($\"是否只读: {isReadOnly}\");\n}\ncatch (Exception ex)\n{\n    Console.WriteLine($\"属性操作失败: {ex.Message}\");\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eReadAllText/WriteAllText：读取/写入文本文件\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003etry\n{\n    string filePath = \"test.txt\";\n    string content = \"你好，世界！\\nHello, World!\";\n\n    // 写入文本（UTF-8编码）\n    File.WriteAllText(filePath, content, Encoding.UTF8);\n    Console.WriteLine(\"文本已写入\");\n\n    // 读取文本\n    string readContent = File.ReadAllText(filePath, Encoding.UTF8);\n    Console.WriteLine($\"读取的内容:\\n{readContent}\");\n}\ncatch (Exception ex)\n{\n    Console.WriteLine($\"文本操作失败: {ex.Message}\");\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eReadAllBytes/WriteAllBytes：读取/写入二进制文件\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003etry\n{\n    string filePath = \"binary.dat\";\n    \n    // 创建示例二进制数据\n    byte[] dataToWrite = new byte[] { 0x48, 0x65, 0x6C, 0x6C, 0x6F }; // \"Hello\" in ASCII\n\n    // 写入二进制数据\n    File.WriteAllBytes(filePath, dataToWrite);\n    Console.WriteLine(\"二进制数据已写入\");\n\n    // 读取二进制数据\n    byte[] dataRead = File.ReadAllBytes(filePath);\n    Console.WriteLine($\"读取的数据: {BitConverter.ToString(dataRead)}\");\n}\ncatch (Exception ex)\n{\n    Console.WriteLine($\"二进制操作失败: {ex.Message}\");\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eReadAllLines/WriteAllLines：按行读取/写入文本\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003etry\n{\n    string filePath = \"lines.txt\";\n    string[] linesToWrite = new string[]\n    {\n        \"第一行\",\n        \"第二行\",\n        \"第三行\"\n    };\n\n    // 写入多行文本\n    File.WriteAllLines(filePath, linesToWrite, Encoding.UTF8);\n    Console.WriteLine(\"多行文本已写入\");\n\n    // 读取所有行\n    string[] linesRead = File.ReadAllLines(filePath, Encoding.UTF8);\n    Console.WriteLine(\"读取的行:\");\n    foreach (string line in linesRead)\n    {\n        Console.WriteLine(line);\n    }\n}\ncatch (Exception ex)\n{\n    Console.WriteLine($\"行操作失败: {ex.Message}\");\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e6.1.2 Directory类\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e常用静态方法\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreateDirectory：创建目录\u003c/li\u003e\n\u003cli\u003eDelete：删除目录\u003c/li\u003e\n\u003cli\u003eExists：检查目录是否存在\u003c/li\u003e\n\u003cli\u003eGetFiles/GetDirectories：获取文件/子目录列表\u003c/li\u003e\n\u003cli\u003eMove：移动目录\u003c/li\u003e\n\u003cli\u003eGetCurrentDirectory/SetCurrentDirectory：获取/设置当前目录\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003etry\n{\n    // 创建目录\n    string dirPath = Path.Combine(Environment.CurrentDirectory, \"testDir\");\n    Directory.CreateDirectory(dirPath);\n    Console.WriteLine($\"目录已创建: {dirPath}\");\n\n    // 创建子目录\n    string subDirPath = Path.Combine(dirPath, \"subDir\");\n    Directory.CreateDirectory(subDirPath);\n    Console.WriteLine($\"子目录已创建: {subDirPath}\");\n\n    // 检查目录是否存在\n    if (Directory.Exists(dirPath))\n    {\n        Console.WriteLine(\"目录存在\");\n\n        // 获取目录中的所有文件\n        string[] files = Directory.GetFiles(dirPath, \"*\", SearchOption.AllDirectories);\n        Console.WriteLine(\"目录中的文件:\");\n        foreach (string file in files)\n        {\n            Console.WriteLine($\"- {Path.GetFileName(file)}\");\n        }\n\n        // 获取所有子目录\n        string[] subdirs = Directory.GetDirectories(dirPath, \"*\", SearchOption.AllDirectories);\n        Console.WriteLine(\"子目录:\");\n        foreach (string dir in subdirs)\n        {\n            Console.WriteLine($\"- {Path.GetFileName(dir)}\");\n        }\n\n        // 移动目录\n        string newPath = Path.Combine(Environment.CurrentDirectory, \"movedDir\");\n        if (!Directory.Exists(newPath))\n        {\n            Directory.Move(dirPath, newPath);\n            Console.WriteLine($\"目录已移动到: {newPath}\");\n        }\n\n        // 删除目录（包括其内容）\n        Directory.Delete(newPath, true);\n        Console.WriteLine(\"目录已删除\");\n    }\n\n    // 获取和设置当前目录\n    string currentDir = Directory.GetCurrentDirectory();\n    Console.WriteLine($\"当前目录: {currentDir}\");\n\n    // 设置当前目录（谨慎使用）\n    Directory.SetCurrentDirectory(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments));\n    Console.WriteLine($\"当前目录已更改为: {Directory.GetCurrentDirectory()}\");\n}\ncatch (Exception ex)\n{\n    Console.WriteLine($\"目录操作失败: {ex.Message}\");\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e6.1.3 Path类\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e路径操作\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCombine：合并路径\u003c/li\u003e\n\u003cli\u003eGetDirectoryName：获取目录名\u003c/li\u003e\n\u003cli\u003eGetFileName：获取文件名\u003c/li\u003e\n\u003cli\u003eGetExtension：获取扩展名\u003c/li\u003e\n\u003cli\u003eGetFullPath：获取完整路径\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003etry\n{\n    // 合并路径示例\n    string baseDir = @\"C:\\Projects\";\n    string projectName = \"MyApp\";\n    string fileName = \"config.json\";\n    \n    // 使用Path.Combine合并路径（推荐方式）\n    string fullPath = Path.Combine(baseDir, projectName, fileName);\n    Console.WriteLine($\"合并后的完整路径: {fullPath}\");\n    \n    // 获取目录名示例\n    string directoryName = Path.GetDirectoryName(fullPath);\n    Console.WriteLine($\"目录名: {directoryName}\");\n    \n    // 获取文件名示例（带扩展名）\n    string fileNameWithExt = Path.GetFileName(fullPath);\n    Console.WriteLine($\"文件名（带扩展名）: {fileNameWithExt}\");\n    \n    // 获取文件名（不带扩展名）\n    string fileNameWithoutExt = Path.GetFileNameWithoutExtension(fullPath);\n    Console.WriteLine($\"文件名（不带扩展名）: {fileNameWithoutExt}\");\n    \n    // 获取扩展名示例\n    string extension = Path.GetExtension(fullPath);\n    Console.WriteLine($\"扩展名: {extension}\");\n    \n    // 获取完整路径示例\n    string relativePath = @\"..\\Logs\\app.log\";\n    string absolutePath = Path.GetFullPath(relativePath);\n    Console.WriteLine($\"相对路径转完整路径: {absolutePath}\");\n    \n    // 跨平台路径处理示例\n    string crossPlatformPath = Path.Combine(\"usr\", \"local\", \"bin\");\n    Console.WriteLine($\"跨平台路径: {crossPlatformPath}\");\n    \n    // 路径规范化示例\n    string pathWithDots = @\"C:\\Projects\\..\\Documents\\MyApp\\..\\Config\";\n    string normalizedPath = Path.GetFullPath(pathWithDots);\n    Console.WriteLine($\"规范化后的路径: {normalizedPath}\");\n}\ncatch (Exception ex)\n{\n    Console.WriteLine($\"路径操作失败: {ex.Message}\");\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e6.2. 流操作\u003c/h3\u003e\n\u003ch4\u003e6.2.1 Stream抽象类\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e基本操作\n\u003cul\u003e\n\u003cli\u003eRead/Write：读取/写入字节\u003c/li\u003e\n\u003cli\u003eSeek：移动流位置\u003c/li\u003e\n\u003cli\u003eFlush：刷新缓冲区\u003c/li\u003e\n\u003cli\u003eClose/Dispose：关闭/释放资源\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003e// Stream抽象类的基本操作示例\npublic class StreamDemo\n{\n    public static void BasicStreamOperations()\n    {\n        // 创建一个文件流作为示例\n        string filePath = \"stream_demo.txt\";\n        using (FileStream stream = new FileStream(filePath, FileMode.Create))\n        {\n            try\n            {\n                // 写入数据\n                byte[] dataToWrite = Encoding.UTF8.GetBytes(\"Hello Stream!\");\n                stream.Write(dataToWrite, 0, dataToWrite.Length);\n                \n                // 刷新缓冲区，确保数据写入\n                stream.Flush();\n                \n                // 移动到流的开始位置\n                stream.Seek(0, SeekOrigin.Begin);\n                \n                // 读取数据\n                byte[] buffer = new byte[100];\n                int bytesRead = stream.Read(buffer, 0, buffer.Length);\n                string readData = Encoding.UTF8.GetString(buffer, 0, bytesRead);\n                Console.WriteLine($\"读取的数据: {readData}\");\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"流操作失败: {ex.Message}\");\n            }\n        } // 使用using语句自动调用Dispose，释放资源\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e6.2.2 常用Stream类\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eFileStream：文件流\n\u003cul\u003e\n\u003cli\u003e文件读写操作\u003c/li\u003e\n\u003cli\u003e缓冲区管理\u003c/li\u003e\n\u003cli\u003e异步操作支持\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003e// FileStream示例：异步文件操作\npublic class FileStreamDemo\n{\n    public static async Task FileOperationsAsync()\n    {\n        string filePath = \"filestream_demo.txt\";\n        using (FileStream fs = new FileStream(filePath, FileMode.Create, FileAccess.ReadWrite, FileShare.None, 4096, true))\n        {\n            try\n            {\n                // 异步写入\n                byte[] dataToWrite = Encoding.UTF8.GetBytes(\"异步写入示例数据\");\n                await fs.WriteAsync(dataToWrite, 0, dataToWrite.Length);\n                \n                // 异步读取\n                fs.Position = 0;\n                byte[] buffer = new byte[100];\n                int bytesRead = await fs.ReadAsync(buffer, 0, buffer.Length);\n                string readData = Encoding.UTF8.GetString(buffer, 0, bytesRead);\n                Console.WriteLine($\"异步读取的数据: {readData}\");\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"文件流操作失败: {ex.Message}\");\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eMemoryStream：内存流\n\u003cul\u003e\n\u003cli\u003e内存中的字节操作\u003c/li\u003e\n\u003cli\u003e临时数据处理\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003e// MemoryStream示例：内存数据处理\npublic class MemoryStreamDemo\n{\n    public static void ProcessDataInMemory()\n    {\n        using (MemoryStream ms = new MemoryStream())\n        {\n            try\n            {\n                // 写入数据到内存流\n                byte[] data = Encoding.UTF8.GetBytes(\"Memory Stream Data\");\n                ms.Write(data, 0, data.Length);\n                \n                // 获取内存流中的所有数据\n                byte[] result = ms.ToArray();\n                Console.WriteLine($\"内存流数据大小: {result.Length} 字节\");\n                \n                // 重置位置并读取\n                ms.Position = 0;\n                StreamReader reader = new StreamReader(ms);\n                string content = reader.ReadToEnd();\n                Console.WriteLine($\"读取的内容: {content}\");\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"内存流操作失败: {ex.Message}\");\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eNetworkStream：网络流\n\u003cul\u003e\n\u003cli\u003e网络通信数据传输\u003c/li\u003e\n\u003cli\u003e套接字操作\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003e// NetworkStream示例：简单的TCP客户端\npublic class NetworkStreamDemo\n{\n    public static async Task NetworkOperationsAsync()\n    {\n        using (TcpClient client = new TcpClient())\n        {\n            try\n            {\n                await client.ConnectAsync(\"example.com\", 80);\n                using (NetworkStream stream = client.GetStream())\n                {\n                    // 发送HTTP GET请求\n                    string request = \"GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n\";\n                    byte[] requestData = Encoding.ASCII.GetBytes(request);\n                    await stream.WriteAsync(requestData, 0, requestData.Length);\n                    \n                    // 读取响应\n                    byte[] buffer = new byte[1024];\n                    int bytesRead = await stream.ReadAsync(buffer, 0, buffer.Length);\n                    string response = Encoding.ASCII.GetString(buffer, 0, bytesRead);\n                    Console.WriteLine($\"服务器响应:\\n{response}\");\n                }\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"网络流操作失败: {ex.Message}\");\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eBufferedStream：缓冲流\n\u003cul\u003e\n\u003cli\u003e性能优化\u003c/li\u003e\n\u003cli\u003e缓冲区管理\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003e// BufferedStream示例：提高读写性能\npublic class BufferedStreamDemo\n{\n    public static void BufferedOperations()\n    {\n        string filePath = \"buffered_demo.txt\";\n        using (FileStream fs = new FileStream(filePath, FileMode.Create))\n        using (BufferedStream bs = new BufferedStream(fs, 4096)) // 4KB缓冲区\n        {\n            try\n            {\n                // 写入大量数据\n                byte[] largeData = new byte[1024 * 1024]; // 1MB数据\n                new Random().NextBytes(largeData); // 填充随机数据\n                \n                // 使用缓冲流写入\n                bs.Write(largeData, 0, largeData.Length);\n                bs.Flush(); // 确保所有数据都写入底层流\n                \n                // 重置位置\n                bs.Position = 0;\n                \n                // 使用缓冲流读取\n                byte[] readBuffer = new byte[8192];\n                int totalBytesRead = 0;\n                int bytesRead;\n                while ((bytesRead = bs.Read(readBuffer, 0, readBuffer.Length)) \u003e 0)\n                {\n                    totalBytesRead += bytesRead;\n                }\n                \n                Console.WriteLine($\"总共读取: {totalBytesRead} 字节\");\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"缓冲流操作失败: {ex.Message}\");\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e缓冲区管理\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e6.3. 文本操作\u003c/h3\u003e\n\u003ch4\u003e6.3.1 文本读写器\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eStreamReader/StreamWriter\n\u003cul\u003e\n\u003cli\u003e文本文件读写\u003c/li\u003e\n\u003cli\u003e编码设置\u003c/li\u003e\n\u003cli\u003e缓冲区管理\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003e// StreamReader/StreamWriter示例：文本文件读写操作\npublic class TextReaderWriterDemo\n{\n    public static async Task TextFileOperationsAsync()\n    {\n        string filePath = \"text_demo.txt\";\n        \n        // 使用StreamWriter写入文本文件\n        using (StreamWriter writer = new StreamWriter(filePath, false, Encoding.UTF8))\n        {\n            try\n            {\n                // 写入单行文本\n                await writer.WriteLineAsync(\"第一行：你好，世界！\");\n                \n                // 写入多行文本\n                string[] lines = new string[]\n                {\n                    \"第二行：StreamWriter示例\",\n                    \"第三行：支持异步操作\",\n                    \"第四行：自动处理编码\"\n                };\n                \n                foreach (string line in lines)\n                {\n                    await writer.WriteLineAsync(line);\n                }\n                \n                // 写入不带换行符的文本\n                await writer.WriteAsync(\"这是不带换行符的文本\");\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"写入操作失败: {ex.Message}\");\n            }\n        }\n        \n        // 使用StreamReader读取文本文件\n        using (StreamReader reader = new StreamReader(filePath, Encoding.UTF8))\n        {\n            try\n            {\n                // 读取所有文本\n                string allText = await reader.ReadToEndAsync();\n                Console.WriteLine(\"读取全部内容：\");\n                Console.WriteLine(allText);\n                \n                // 重置流位置\n                reader.BaseStream.Seek(0, SeekOrigin.Begin);\n                \n                // 逐行读取\n                Console.WriteLine(\"\\n逐行读取：\");\n                string line;\n                while ((line = await reader.ReadLineAsync()) != null)\n                {\n                    Console.WriteLine(line);\n                }\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"读取操作失败: {ex.Message}\");\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eStringReader/StringWriter\n\u003cul\u003e\n\u003cli\u003e字符串操作\u003c/li\u003e\n\u003cli\u003e内存文本处理\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003e// StringReader/StringWriter示例：内存中的字符串操作\npublic class StringReaderWriterDemo\n{\n    public static async Task StringOperationsAsync()\n    {\n        // 使用StringWriter构建字符串\n        using (StringWriter writer = new StringWriter())\n        {\n            try\n            {\n                // 写入文本\n                await writer.WriteLineAsync(\"StringWriter示例\");\n                await writer.WriteLineAsync(\"可以在内存中构建大型文本\");\n                await writer.WriteAsync(\"支持异步操作和格式化：\");\n                await writer.WriteLineAsync($\"{DateTime.Now:yyyy-MM-dd}\");\n                \n                // 获取构建的字符串\n                string result = writer.ToString();\n                Console.WriteLine(\"StringWriter构建的文本：\");\n                Console.WriteLine(result);\n                \n                // 使用StringReader读取文本\n                using (StringReader reader = new StringReader(result))\n                {\n                    Console.WriteLine(\"\\n使用StringReader逐行读取：\");\n                    string line;\n                    while ((line = await reader.ReadLineAsync()) != null)\n                    {\n                        Console.WriteLine($\"读取的行: {line}\");\n                    }\n                    \n                    // 重置到开始位置（需要创建新的StringReader）\n                    using (StringReader newReader = new StringReader(result))\n                    {\n                        // 读取指定字符数\n                        char[] buffer = new char[10];\n                        int charsRead = await newReader.ReadAsync(buffer, 0, buffer.Length);\n                        Console.WriteLine($\"\\n读取前{charsRead}个字符：\");\n                        Console.WriteLine(new string(buffer, 0, charsRead));\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"字符串操作失败: {ex.Message}\");\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e6.3.2 编码处理\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eEncoding类\n\u003cul\u003e\n\u003cli\u003eUTF8、Unicode、ASCII等编码\u003c/li\u003e\n\u003cli\u003e字符集转换\u003c/li\u003e\n\u003cli\u003eBOM处理\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003epublic class EncodingDemo\n{\n    public static void Main()\n    {\n        try\n        {\n            // 1. 基本编码示例\n            string text = \"Hello 你好 こんにちは\";\n            \n            // UTF8编码\n            byte[] utf8Bytes = Encoding.UTF8.GetBytes(text);\n            string utf8String = Encoding.UTF8.GetString(utf8Bytes);\n            Console.WriteLine($\"UTF8编码字节数: {utf8Bytes.Length}\");\n            \n            // Unicode编码\n            byte[] unicodeBytes = Encoding.Unicode.GetBytes(text);\n            string unicodeString = Encoding.Unicode.GetString(unicodeBytes);\n            Console.WriteLine($\"Unicode编码字节数: {unicodeBytes.Length}\");\n            \n            // ASCII编码（不支持非ASCII字符）\n            byte[] asciiBytes = Encoding.ASCII.GetBytes(text);\n            string asciiString = Encoding.ASCII.GetString(asciiBytes);\n            Console.WriteLine($\"ASCII编码字节数: {asciiBytes.Length}\");\n\n            // 2. 字符集转换\n            // UTF8转GB2312\n            Encoding gb2312 = Encoding.GetEncoding(\"gb2312\");\n            byte[] gb2312Bytes = Encoding.Convert(Encoding.UTF8, gb2312, utf8Bytes);\n            string gb2312String = gb2312.GetString(gb2312Bytes);\n            Console.WriteLine($\"GB2312编码结果: {gb2312String}\");\n\n            // 3. BOM处理\n            string fileName = \"test_with_bom.txt\";\n            \n            // 创建带BOM的UTF8文件\n            using (var stream = new FileStream(fileName, FileMode.Create))\n            using (var writer = new StreamWriter(stream, new UTF8Encoding(true)))\n            {\n                writer.Write(text);\n            }\n            \n            // 检测文件是否包含BOM\n            byte[] fileBytes = File.ReadAllBytes(fileName);\n            bool hasBom = fileBytes.Length \u003e= 3 \u0026#x26;\u0026#x26; \n                         fileBytes[0] == 0xEF \u0026#x26;\u0026#x26; \n                         fileBytes[1] == 0xBB \u0026#x26;\u0026#x26; \n                         fileBytes[2] == 0xBF;\n            Console.WriteLine($\"文件是否包含BOM: {hasBom}\");\n\n            // 不带BOM的UTF8编码\n            using (var stream = new FileStream(\"test_without_bom.txt\", FileMode.Create))\n            using (var writer = new StreamWriter(stream, new UTF8Encoding(false)))\n            {\n                writer.Write(text);\n            }\n\n            // 4. 编码检测\n            using (var stream = new FileStream(fileName, FileMode.Open))\n            {\n                // 创建检测器\n                byte[] buffer = new byte[4];\n                stream.Read(buffer, 0, 4);\n\n                // 检测编码\n                if (buffer[0] == 0xEF \u0026#x26;\u0026#x26; buffer[1] == 0xBB \u0026#x26;\u0026#x26; buffer[2] == 0xBF)\n                    Console.WriteLine(\"检测到UTF8 BOM编码\");\n                else if (buffer[0] == 0xFF \u0026#x26;\u0026#x26; buffer[1] == 0xFE)\n                    Console.WriteLine(\"检测到UTF16 Little Endian编码\");\n                else if (buffer[0] == 0xFE \u0026#x26;\u0026#x26; buffer[1] == 0xFF)\n                    Console.WriteLine(\"检测到UTF16 Big Endian编码\");\n                else\n                    Console.WriteLine(\"未检测到BOM标记\");\n            }\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"编码操作失败: {ex.Message}\");\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e6.4. 序列化与反序列化\u003c/h3\u003e\n\u003ch4\u003e6.4.1 二进制序列化\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eBinaryFormatter\n\u003cul\u003e\n\u003cli\u003e对象序列化\u003c/li\u003e\n\u003cli\u003e性能考虑\u003c/li\u003e\n\u003cli\u003e安全性注意事项\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003e[Serializable]\npublic class Person\n{\n    public string Name { get; set; }\n    public int Age { get; set; }\n    [NonSerialized]\n    private string secretData;\n}\n\ntry\n{\n    // 创建对象\n    var person = new Person { Name = \"张三\", Age = 25 };\n    string filePath = \"person.bin\";\n\n    // 序列化对象\n    using (var fs = new FileStream(filePath, FileMode.Create))\n    {\n        var formatter = new BinaryFormatter();\n        formatter.Serialize(fs, person);\n    }\n    Console.WriteLine(\"对象已序列化到文件\");\n\n    // 反序列化对象\n    using (var fs = new FileStream(filePath, FileMode.Open))\n    {\n        var formatter = new BinaryFormatter();\n        var deserializedPerson = (Person)formatter.Deserialize(fs);\n        Console.WriteLine($\"反序列化结果: {deserializedPerson.Name}, {deserializedPerson.Age}\");\n    }\n}\ncatch (Exception ex)\n{\n    Console.WriteLine($\"序列化操作失败: {ex.Message}\");\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e6.4.2 XML序列化\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eXmlSerializer\n\u003cul\u003e\n\u003cli\u003eXML文档处理\u003c/li\u003e\n\u003cli\u003e特性标记\u003c/li\u003e\n\u003cli\u003e自定义序列化\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003e[XmlRoot(\"Person\")]\npublic class Person\n{\n    [XmlElement(\"FullName\")]\n    public string Name { get; set; }\n\n    [XmlAttribute(\"age\")]\n    public int Age { get; set; }\n\n    [XmlIgnore]\n    public string TemporaryData { get; set; }\n}\n\ntry\n{\n    // 创建对象\n    var person = new Person { Name = \"李四\", Age = 30 };\n    string xmlFile = \"person.xml\";\n\n    // 序列化为XML\n    var serializer = new XmlSerializer(typeof(Person));\n    using (var writer = new StreamWriter(xmlFile))\n    {\n        serializer.Serialize(writer, person);\n    }\n    Console.WriteLine(\"对象已序列化为XML\");\n\n    // 从XML反序列化\n    using (var reader = new StreamReader(xmlFile))\n    {\n        var deserializedPerson = (Person)serializer.Deserialize(reader);\n        Console.WriteLine($\"从XML反序列化: {deserializedPerson.Name}, {deserializedPerson.Age}\");\n    }\n}\ncatch (Exception ex)\n{\n    Console.WriteLine($\"XML序列化失败: {ex.Message}\");\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e6.4.3 JSON序列化\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eSystem.Text.Json\n\u003cul\u003e\n\u003cli\u003eJSON数据处理\u003c/li\u003e\n\u003cli\u003e序列化选项\u003c/li\u003e\n\u003cli\u003e性能优化\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003epublic class Person\n{\n    public string Name { get; set; }\n    public int Age { get; set; }\n    \n    [JsonIgnore]\n    public string SensitiveInfo { get; set; }\n}\n\ntry\n{\n    // 创建对象\n    var person = new Person { Name = \"王五\", Age = 35 };\n\n    // 配置序列化选项\n    var options = new JsonSerializerOptions\n    {\n        WriteIndented = true,\n        PropertyNamingPolicy = JsonNamingPolicy.CamelCase\n    };\n\n    // 序列化为JSON\n    string jsonString = JsonSerializer.Serialize(person, options);\n    File.WriteAllText(\"person.json\", jsonString);\n    Console.WriteLine($\"JSON序列化结果:\\n{jsonString}\");\n\n    // 从JSON反序列化\n    string jsonContent = File.ReadAllText(\"person.json\");\n    var deserializedPerson = JsonSerializer.Deserialize\u0026#x3C;Person\u003e(jsonContent, options);\n    Console.WriteLine($\"从JSON反序列化: {deserializedPerson.Name}, {deserializedPerson.Age}\");\n}\ncatch (Exception ex)\n{\n    Console.WriteLine($\"JSON序列化失败: {ex.Message}\");\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e6.4.4、\u003cstrong\u003e第三方库\u003c/strong\u003e\u003c/h4\u003e\n\u003ch5\u003e\u003cstrong\u003e1. 使用 \u003ccode\u003eprotobuf-net\u003c/code\u003e 库\u003c/strong\u003e\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e优点\u003c/strong\u003e：高效、紧凑、跨语言（需定义协议）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 安装 NuGet 包：protobuf-net\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch5\u003e\u003cstrong\u003e2. 使用 \u003ccode\u003eMessagePack-CSharp\u003c/code\u003e\u003c/strong\u003e\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e面向性能敏感场景（如游戏、高频通信）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 安装 NuGet 包：MessagePack\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e6.5. 异步IO操作\u003c/h3\u003e\n\u003ch4\u003e6.5.1 异步模式\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003easync/await模式\n\u003cul\u003e\n\u003cli\u003e异步文件操作\u003c/li\u003e\n\u003cli\u003e异步流操作\u003c/li\u003e\n\u003cli\u003e异步网络IO\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003e// 异步文件操作示例\npublic class FileOperationExample\n{\n    public static async Task FileOperationsAsync()\n    {\n        string filePath = \"test.txt\";\n        string content = \"Hello Async World!\";\n\n        try\n        {\n            // 异步写入文件\n            await File.WriteAllTextAsync(filePath, content);\n            Console.WriteLine(\"文件异步写入完成\");\n\n            // 异步读取文件\n            string readContent = await File.ReadAllTextAsync(filePath);\n            Console.WriteLine($\"异步读取的内容: {readContent}\");\n\n            // 使用FileStream进行大文件异步操作\n            using var fileStream = new FileStream(filePath, FileMode.Open);\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n\n            while ((bytesRead = await fileStream.ReadAsync(buffer, 0, buffer.Length)) \u003e 0)\n            {\n                // 处理读取的数据\n                Console.WriteLine($\"读取了 {bytesRead} 字节\");\n            }\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"文件操作异常: {ex.Message}\");\n        }\n    }\n}\n\n// 异步流操作示例\npublic class StreamOperationExample\n{\n    public static async Task StreamCopyAsync()\n    {\n        string sourceFile = \"source.txt\";\n        string destFile = \"destination.txt\";\n\n        try\n        {\n            using var sourceStream = new FileStream(sourceFile, FileMode.Open);\n            using var destStream = new FileStream(destFile, FileMode.Create);\n\n            // 异步复制流\n            await sourceStream.CopyToAsync(destStream);\n            Console.WriteLine(\"流异步复制完成\");\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"流操作异常: {ex.Message}\");\n        }\n    }\n}\n\n// 异步网络IO示例\npublic class NetworkIOExample\n{\n    public static async Task NetworkOperationsAsync()\n    {\n        try\n        {\n            using var client = new HttpClient();\n            \n            // 异步HTTP GET请求\n            string url = \"https://api.example.com/data\";\n            string response = await client.GetStringAsync(url);\n            Console.WriteLine($\"收到响应: {response}\");\n\n            // 异步HTTP POST请求\n            var content = new StringContent(\"{\\\"data\\\": \\\"test\\\"}\", Encoding.UTF8, \"application/json\");\n            var postResponse = await client.PostAsync(url, content);\n            \n            if (postResponse.IsSuccessStatusCode)\n            {\n                string result = await postResponse.Content.ReadAsStringAsync();\n                Console.WriteLine($\"POST响应: {result}\");\n            }\n        }\n        catch (HttpRequestException ex)\n        {\n            Console.WriteLine($\"网络请求异常: {ex.Message}\");\n        }\n    }\n}\n\n// 调用示例\npublic class Program\n{\n    public static async Task Main()\n    {\n        await FileOperationExample.FileOperationsAsync();\n        await StreamOperationExample.StreamCopyAsync();\n        await NetworkIOExample.NetworkOperationsAsync();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e\u003cstrong\u003e7 委托与事件\u003c/strong\u003e\u003c/h2\u003e\n\u003ch3\u003e\u003cstrong\u003e7.1 委托\u003c/strong\u003e\u003c/h3\u003e\n\u003ch4\u003e\u003cstrong\u003e1. 委托的本质是一种类型\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e委托是一种类型--- 方法的类型   引用类型\n委托是代表方法的类型，说明委托所定义的变量中存放的是方法\u003c/p\u003e\n\u003ch4\u003e\u003cstrong\u003e2. 委托的使用\u003c/strong\u003e\u003c/h4\u003e\n\u003ch5\u003e\u003cstrong\u003e2.1 委托五步法\u003c/strong\u003e\u003c/h5\u003e\n\u003cp\u003e​\t1.定义委托对象 关键字\u003cstrong\u003edelegate\u003c/strong\u003e\t\t\t2.创建需要委托的方法\t\t3.定义委托对象\u003c/p\u003e\n\u003cp\u003e​\t4.委托对象绑定方法\t\t5.调用委托\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003epublic class Program\n{\n    //1 定义委托对象\n    delegate void MyDelegate(string message);\n    public static void Main()\n    {\n        //3 定义委托对象 \n        MyDelegate myDelegate = null;\n        //4 委托对象绑定方法\n        //myDelegate =new MyDelegate(PrintMessage);// 方式1绑定\n        myDelegate=PrintMessage;  //方式2绑定\n\n        //5 调用委托\n        // myDelegate.Invoke(\"Hello, Delegate!\");//方式1调用\n        myDelegate(\"Hello, Delegate!\"); //方式2调用,Invoke省略\n    }\n\n    // 2 创建需要委托的方法\n    public static void PrintMessage(string message)\n    {\n        Console.WriteLine(message);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch5\u003e\u003cstrong\u003e2.2 多播委托\u003c/strong\u003e\u003c/h5\u003e\n\u003cp\u003e一个委托可以绑定多个方法：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003epublic class Program\n{\n    public static void Main()\n    {\n        MyDelegate myDelegate = PrintMessage;\n        myDelegate += PrintAnotherMessage; // 绑定第二个方法\n\n        // 调用委托，两个方法都会执行\n        myDelegate(\"Hello, Multicast Delegate!\");\n    }\n\n    public static void PrintMessage(string message)\n    {\n        Console.WriteLine(\"Method 1: \" + message);\n    }\n\n    public static void PrintAnotherMessage(string message)\n    {\n        Console.WriteLine(\"Method 2: \" + message);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch5\u003e\u003cstrong\u003e2.3 匿名方法和 Lambda 表达式\u003c/strong\u003e\u003c/h5\u003e\n\u003cp\u003e可以使用匿名方法或 Lambda 表达式简化委托的定义：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003epublic class Program\n{\n    public static void Main()\n    {\n        // 使用匿名方法\n        MyDelegate myDelegate = delegate(string message)\n        {\n            Console.WriteLine(\"Anonymous Method: \" + message);\n        };\n\n        // 使用 Lambda 表达式\n        MyDelegate myDelegate2 = (message) =\u003e Console.WriteLine(\"Lambda: \" + message);\n\n        myDelegate(\"Hello!\");\n        myDelegate2(\"Hello!\");\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch5\u003e2*3.4 同步委托 异步委托**\u003c/h5\u003e\n\u003cp\u003e同步委托调用是委托执行的默认方式\n异步委托调用方式\u003ccode\u003eBeginInvoke\u003c/code\u003e 和 \u003ccode\u003eEndInvoke\u003c/code\u003e 方法\u003c/p\u003e\n\u003chr\u003e\n\u003ch4\u003e\u003cstrong\u003e3. 内置委托\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003eC# 提供了几种常用的内置委托，无需手动定义：\u003c/p\u003e\n\u003ch5\u003e\u003cstrong\u003e3.1 \u003ccode\u003eAction\u003c/code\u003e\u003c/strong\u003e\u003c/h5\u003e\n\u003cp\u003e用于指向无返回值的方法，最高参数有16个：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003eAction\u0026#x3C;string\u003e action = (message) =\u003e Console.WriteLine(message);\naction(\"Hello, Action!\");\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch5\u003e\u003cstrong\u003e3.2 \u003ccode\u003eFunc\u003c/code\u003e\u003c/strong\u003e\u003c/h5\u003e\n\u003cp\u003e用于指向有返回值的方法，最高参数有16个：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003eFunc\u0026#x3C;int, int, int\u003e add = (a, b) =\u003e a + b;\nConsole.WriteLine(add(2, 3)); // 输出 5\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch5\u003e\u003cstrong\u003e3.3 \u003ccode\u003ePredicate\u003c/code\u003e\u003c/strong\u003e\u003c/h5\u003e\n\u003cp\u003e用于指向返回 \u003ccode\u003ebool\u003c/code\u003e 的方法：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003ePredicate\u0026#x3C;int\u003e isEven = (num) =\u003e num % 2 == 0;\nConsole.WriteLine(isEven(4)); // 输出 True\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch4\u003e\u003cstrong\u003e4. 委托的作用\u003c/strong\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e减少代码的冗余，\u003cstrong\u003e多播方式\u003c/strong\u003e可以处理很多冗余。可以\u003cstrong\u003e批量处理\u003c/strong\u003e类似但不同的方法，如快速替换。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003e  public void ProcessData(Action\u0026#x3C;string\u003e callback)\n  {\n      string result = \"Data processed\";\n      callback(result);\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e当对象不方便访问的使用委托(窗体传值)。\u003c/li\u003e\n\u003cli\u003e委托的\u003cstrong\u003e回调方式\u003c/strong\u003e可以把方法作为实参传递\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3\u003e\u003cstrong\u003e7.2 事件\u003c/strong\u003e\u003c/h3\u003e\n\u003ch4\u003e详解：\u003c/h4\u003e\n\u003cp\u003e发布者（Publisher）：触发事件的对象（例如：按钮点击）。\n订阅者（Subscriber）：监听事件并执行处理方法的对象。\n**底层依赖：事件基于\u003cem\u003e委托（Delegate）\u003cem\u003e实现，是一种类型安全的回调机制。\u003c/em\u003e\u003c/em\u003e\n\u003cstrong\u003e外部代码只能通过+=和-=进行订阅/取消订阅，保障数据安全性。\u003c/strong\u003e\n\u003cstrong\u003e仅允许在声明事件的类内部触发事件（.Invoke()或直接调用）。\u003c/strong\u003e\u003c/p\u003e\n\u003ch4\u003e事件声明\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003e// 标准模式：public event EventHandler EventName;   关键字event\n// 使用泛型传递数据：public event EventHandler\u0026#x3C;CustomEventArgs\u003e EventName;\n// 触发条件检查 ?.Invoke()避免空引用异常\npublic class Button\n{\n    public event EventHandler Click;\n\n    public void OnClick()\n    {\n        Click?.Invoke(this, EventArgs.Empty);\n    }\n}\n\nButton button = new Button();\nbutton.Click += (sender, e) =\u003e Console.WriteLine(\"Button clicked!\");\nbutton.OnClick();\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e\u003cstrong\u003e8 反射\u003c/strong\u003e\u003c/h2\u003e\n\u003ch3\u003e1. 什么是反射？\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e反射（Reflection）\u003c/strong\u003e 是 C# 中一种强大的机制，它允许程序在运行时\u003cstrong\u003e动态获取元数据\u003c/strong\u003e【类型信息、创建对象、调用方法或访问属性】。简单来说，反射让程序能够“自省”，即动态地检查和操作程序自身的结构和行为。\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e\u003cstrong\u003e2. 反射的用途\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e反射在以下场景中非常有用：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e动态加载程序集\u003c/strong\u003e：在运行时加载外部 DLL 文件并调用其中的类型和方法。满足\u003cstrong\u003e开闭原则\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e插件系统\u003c/strong\u003e：实现插件架构，动态加载和调用插件。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e序列化和反序列化\u003c/strong\u003e：在运行时动态读取和写入对象的属性。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e单元测试框架\u003c/strong\u003e：动态调用测试方法。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e依赖注入\u003c/strong\u003e：在运行时解析和创建对象实例。\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch3\u003e\u003cstrong\u003e3. 反射的基本用法\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e反射的核心是通过 \u003ccode\u003eSystem.Reflection\u003c/code\u003e 命名空间中的类来实现的，核心类包括\u003cstrong\u003eType\u003c/strong\u003e(类型类)、\u003cstrong\u003eActivator\u003c/strong\u003e(激活类)、\u003cstrong\u003eAssembly\u003c/strong\u003e(程序集)，方法主要包括 \u003ccode\u003eType\u003c/code\u003e、\u003ccode\u003eMethodInfo\u003c/code\u003e、\u003ccode\u003ePropertyInfo\u003c/code\u003e、\u003ccode\u003eFieldInfo\u003c/code\u003e 等。\u003c/p\u003e\n\u003ch4\u003e\u003cstrong\u003e3.1 获取类型信息\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e通过 \u003ccode\u003etypeof\u003c/code\u003e 、\u003ccode\u003eGetType\u003c/code\u003e、\u003ccode\u003eAssembly.Load()\u003c/code\u003e 获取类型信息：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003eType type = typeof(MyClass); // 获取类型\nType type2 = obj.GetType();  // 通过实例获取类型\n\n//程序集方式 任选一个\n1 Assembly assembly =Assembly.Load(\"MyLibrary\") //需要填写程序集的名字  程序集文件须要跟你的exe程序在一个目录下 \n2 Assembly assembly =Assembly.LoadFrom(\"./MyLibrary.dll\") //绝对/相对都可以          \n3 Assembly assembly =Assembly.LoadFile(\"D:/MyLibrary.dll\")//绝对路径\n    \nType type= assembly.GetType(\"命名空间.类名\"); //必须要带全名称   \n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e\u003cstrong\u003e3.2 反射对象\u003c/strong\u003e\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003eobject instance = Activator.CreateInstance(type);//无参\nobject instance =Activator.CreateInstance(type,new object[] {值1,值2})//有参  \nobject instance =assembly.CreateInstance()//无参构造方法   有参数重载的\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e\u003cstrong\u003e3.3 反射方法\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e通过 \u003ccode\u003eGetMethod\u003c/code\u003e 获取方法，并通过 \u003ccode\u003eInvoke\u003c/code\u003e 调用：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003eMethodInfo method = type.GetMethod(\"MyMethod\");\nmethod.Invoke(instance, new object[] { \"Hello, Reflection!\" });\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e\u003cstrong\u003e3.4 反射属性 获取和设置\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e通过 \u003ccode\u003eGetProperty\u003c/code\u003e 获取属性，并通过 \u003ccode\u003eGetValue\u003c/code\u003e 和 \u003ccode\u003eSetValue\u003c/code\u003e 读取或设置值：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003ePropertyInfo property = type.GetProperty(\"MyProperty\");\nproperty.SetValue(instance, 42); // 设置属性值\nConsole.WriteLine(property.GetValue(instance)); // 获取属性值\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e\u003cstrong\u003e3.5 反射构造函数\u003c/strong\u003e\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-C#\"\u003eConstructorInfo constructorInfo= type.GetConstructor(new Type[] { typeof(string) });\nconstructorInfo.Invoke(new object[] {\"我是构造出来的\"})   \n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e\u003cstrong\u003e3.6 权限问题\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e权限问题---需要设置一个枚举  \u003ccode\u003eBindingFlags\u003c/code\u003e，比如：\nBindingFlags.Instance|BindingFlags.NonPublic         BindingFlags.Static|BindingFlags.NonPublic\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e\u003cstrong\u003e9 进程、线程\u003c/strong\u003e\u003c/h2\u003e\n\u003ch3\u003e0、进程、线程的关系\u003c/h3\u003e\n\u003cp\u003e想象一下你在经营一家餐厅的厨房（这就是一个进程），这个厨房是一个独立的工作空间，有自己的灶台、调料、厨具等资源（进程的独立内存空间和资源）。\u003c/p\u003e\n\u003cp\u003e在这个厨房里：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e厨师就是线程\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e一个厨房（进程）可以有多个厨师（线程）同时工作\u003c/li\u003e\n\u003cli\u003e所有厨师共享这个厨房的资源（线程共享进程的内存空间）\u003c/li\u003e\n\u003cli\u003e每个厨师有自己的工作台和刀具（线程私有的堆栈空间）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e炒一道菜的过程\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e主厨（主线程）可以分配任务给其他厨师（创建新线程）\u003c/li\u003e\n\u003cli\u003e一个厨师可以同时看着两个锅（线程并发）\u003c/li\u003e\n\u003cli\u003e多个厨师可以同时炒不同的菜（多线程并行）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e资源共享和协调\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e厨师们共用同一个调料架（共享资源）\u003c/li\u003e\n\u003cli\u003e使用同一个灶台时需要互相协调（线程同步）\u003c/li\u003e\n\u003cli\u003e两个厨师不能同时使用同一个铲子（互斥锁）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e效率和安全\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e多个厨师同时工作可以提高效率（多线程提高性能）\u003c/li\u003e\n\u003cli\u003e但太多厨师反而会互相干扰（线程过多反而降低性能）\u003c/li\u003e\n\u003cli\u003e需要协调好使用公共区域的顺序（避免死锁）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e关系类比\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e开一家新餐厅 = 启动新进程\u003c/li\u003e\n\u003cli\u003e招聘新厨师 = 创建新线程\u003c/li\u003e\n\u003cli\u003e餐厅关门 = 进程结束（所有厨师都要下班）\u003c/li\u003e\n\u003cli\u003e厨师下班 = 线程结束（但餐厅可以继续营业）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e\u003cstrong\u003e1. 进程（Process）\u003c/strong\u003e\u003c/h3\u003e\n\u003ch4\u003e\u003cstrong\u003e1.1 基本概念\u003c/strong\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e定义\u003c/strong\u003e：操作系统加载运行电脑上的可执行程序（.exe)的基本单元，运行时会在内存中开辟一块内存空间，\n把这块内存空间称为进程，也就是说是进行中的程序，为你要运行的程序提供了对应的运行的物理空间\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e构成\u003c/strong\u003e：\n\u003cul\u003e\n\u003cli\u003e内核对象    地址空间（用来提供线程运行环境的）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e1.2 常用属性与方法\u003c/h4\u003e\n\u003cp\u003e常用属性：\u003c/p\u003e\n\u003cp\u003e| \u003cstrong\u003e类/方法\u003c/strong\u003e | \u003cstrong\u003e用途\u003c/strong\u003e | \u003cstrong\u003e示例\u003c/strong\u003e |\n|------------|---------|----------|\n| ProcessName | 获取进程名称 |  |\n| ID | 获取进程唯一标识符 |  |\n| Threads | 进程中的线程集合 |  |\n| MachineName | 获取运行进程的计算机名称 |  |\u003c/p\u003e\n\u003cp\u003e常用方法：\u003c/p\u003e\n\u003cp\u003e| \u003cstrong\u003e类/方法\u003c/strong\u003e | \u003cstrong\u003e用途\u003c/strong\u003e | \u003cstrong\u003e示例\u003c/strong\u003e |\n|------------|---------|----------|\n| \u003cstrong\u003e\u003ccode\u003eProcessStartInfo\u003c/code\u003e\u003c/strong\u003e | 配置进程启动参数 | 设置启动参数、工作目录、是否隐藏窗口等 |\n| \u003cstrong\u003e\u003ccode\u003eProcess\u003c/code\u003e\u003c/strong\u003e | 管理本地或远程进程 | \u003ccode\u003eProcess.Start(\"notepad.exe\")\u003c/code\u003e |\n| \u003ccode\u003eProcess.Start()\u003c/code\u003e | 启动新进程 | \u003ccode\u003eProcess.Start(\"calc.exe\")\u003c/code\u003e |\n| \u003ccode\u003eProcess.Kill()\u003c/code\u003e | 强制终止进程 | \u003ccode\u003eproc.Kill();\u003c/code\u003e |\n| \u003ccode\u003eProcess.WaitForExit()\u003c/code\u003e | 阻塞当前线程直到进程退出 | \u003ccode\u003eproc.WaitForExit(5000);\u003c/code\u003e（等待5秒） |\n| \u003ccode\u003eProcess.GetProcesses()\u003c/code\u003e | 获取当前运行的所有进程 | \u003ccode\u003eProcess.GetProcessesByName(\"chrome\")\u003c/code\u003e |\n| Process.GetCurrentProcess() | 获取当前运行的进程 |  |\u003c/p\u003e\n\u003ch4\u003e\u003cstrong\u003e1.3 进程操作\u003c/strong\u003e\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003e// 获取当前进程\nProcess currentProcess = Process.GetCurrentProcess();\nConsole.WriteLine(currentProcess.ProcessName)  //获取进程名称\nConsole.WriteLine(currentProcess.ID)  //获取进程唯一标识符\nConsole.WriteLine(currentProcess.Threads)  //获取进程的线程集合\nConsole.WriteLine(currentProcess.MachineName)  //获取运行进程的计算机名称\n\n\n// 启动新进程\nProcess.Start(\"notepad.exe\");\n\n// 启动进程并传递参数\nProcessStartInfo startInfo = new ProcessStartInfo();\nstartInfo.FileName = \"notepad.exe\";\nstartInfo.Arguments = \"file.txt\";\nProcess.Start(startInfo);\n\n// 获取所有进程\nProcess[] processes = Process.GetProcesses();\n\n// 结束进程\n// 查找并结束所有记事本进程\nforeach (var proc in Process.GetProcessesByName(\"notepad\")) {\n    proc.Kill();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2. 线程（Thread）\u003c/h3\u003e\n\u003ch4\u003e2.1 基本概念\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e定义 ：线程是进程中的执行单元，一个进程可以包含多个线程\u003c/li\u003e\n\u003cli\u003e特点 ：\n\u003cul\u003e\n\u003cli\u003e共享进程的内存空间\u003c/li\u003e\n\u003cli\u003e具有自己的堆栈和局部变量\u003c/li\u003e\n\u003cli\u003e可以并发执行\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e2.2 三种线程类\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eThread 线程类\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e属性\n\u003cul\u003e\n\u003cli\u003eIsBackground 获取或设置后台线程\u003c/li\u003e\n\u003cli\u003eManagedThreadId 获取当前线程的唯一标识符\u003c/li\u003e\n\u003cli\u003eName  获取或设置线程的名称\u003c/li\u003e\n\u003cli\u003eCurrentThread 获取当前正在运行的线程。该属性为静态属性\u003c/li\u003e\n\u003cli\u003eThreadState 获取当前线程的状态\u003c/li\u003e\n\u003cli\u003eIsAlive 当前线程的执行状态。如果此线程己启动并且尚未正常终止或中断，则为true\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e方法\n\u003cul\u003e\n\u003cli\u003e开启:Start; 阻塞:Join; 停止:Abort --会有异常; 睡眠:Sleep; 挂起:Suspend[弃用]; 唤醒:Resume[弃用]\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThreadPool 线程池类\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003e// 使用线程池执行任务\nThreadPool.QueueUserWorkItem(state =\u003e {\n    Console.WriteLine(\"在线程池中执行任务\");\n});\nThreadPool.QueueUserWorkItem(state =\u003e {\n    Console.WriteLine(\"在线程池中执行任务2\");\n});\nThreadPool.QueueUserWorkItem(state =\u003e {\n    Console.WriteLine(\"在线程池中执行任务3\");\n});\n\n// 使用Task执行异步操作\npublic async Task\u0026#x3C;string\u003e DownloadAsync(string url)\n{\n    using (HttpClient client = new HttpClient())\n    {\n        return await client.GetStringAsync(url);\n    }\n}\n//ThreadPool的优点在于它能够有效地复用线程资源，减少线程的创建和销毁开销，提高系统的吞吐量。ThreadPool由.NET运行时管理，提供了更高级别的抽象和自动化。\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eTask 线程类（任务类）--推荐\n\u003cul\u003e\n\u003cli\u003e创建\n1】实例化 new  Task(方法) 需要调用Start才会启动\n2】 Task.Run ----------  自动运行\n3】Task.Factory.StartNew---开启 自动运行\u003c/li\u003e\n\u003cli\u003e阻塞\n当前所在的线程直到完成 Wait、WaitAll、WaitAny\u003c/li\u003e\n\u003cli\u003e后继线程 ContinueWith\nTask.WhenAll().ContinueWith(()=\u003e{})\u003c/li\u003e\n\u003cli\u003e长任务：重载一个Task的构造方法\n多一个参数设置成TaskCreationOptions.LongRunning\u003c/li\u003e\n\u003cli\u003e添加到父任务\n将子任务可以添加为父任务，子任务是从属于父任务，如果子任务没有结束，父任务也不会结束（放在Run里面不行）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e2.3 前台线程和后台线程\u003c/h4\u003e\n\u003cp\u003e通过设置\u003ccode\u003eIsBackground\u003c/code\u003e属性可以设置为前台或后台线程，后台线程在所有前台线程结束后自动结束。前台线程会阻止应用程序的进程终止，直到所有前台线程都完成执行。默认情况下，前台线程是应用程序的主要执行线程。\u003c/p\u003e\n\u003ch4\u003e2.4取消类\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e属性 --IsCancellationRequested--默认是false  是否取消\u003c/li\u003e\n\u003cli\u003e方法-- Cancel  --将IsCancellationRequested设置成true\u003cbr\u003e\nCancelAfter  指定多少毫秒后取消---等待多少毫秒不影响主线\ncts.Token.Register(()=\u003e{});    取消回调-\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e2.6 线程同步与调度\u003c/h4\u003e\n\u003ch6\u003e线程同步与调度\u003c/h6\u003e\n\u003ch5\u003e2.6.0 winform中 跨线程访问\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003eInvoke实现对控件的访问，从而达到跨线程访问\u003c/li\u003e\n\u003cli\u003eControl类还有一个属性（取消跨线程访问-不建议取消）\u003c/li\u003e\n\u003cli\u003e另外 Task的Start的方式   task.Start(TaskScheduler.FromCurrentSynchronizationContext())的方式-任务调度器\u003c/li\u003e\n\u003cli\u003etask.ContinueWith也有TaskScheduler.FromCurrentSynchronizationContext()\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e备注：Application.DoEvents() ---放在线程的循环中以用来响应Windows的消息放在卡顿或者假死\n注意：不要在Invoke放任何等待代码（这里面只放控件刷新改变值的代码）更不要放Sleep\u003c/p\u003e\n\u003ch5\u003e2.6.1 事件同步信号：自动、手动\u003c/h5\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003e//手动同步事件=\u003e 构造函数传入参数  true --有信号 不阻塞   false--无信号 阻塞\nSystem.Threading.ManualResetEvent manualResetEvent = new System.Threading.ManualResetEvent(false);\n//自动同步事件 =\u003e 构造函数传入参数  true --有信号 不阻塞   false--无信号 阻塞\nSystem.Threading.AutoResetEvent autoResetEvent = new System.Threading.AutoResetEvent(false);\n\n... 其他代码\nnew Thread(() =\u003e \n {\n     for (int i = 0; i \u0026#x3C;= 100; i+=5)\n     {\n         //使用手动同步事件=\u003e阻塞当前线程(也可以解除对线程的阻塞)\n         manualResetEvent.WaitOne();\n         \n         //使用自动同步事件=\u003e阻塞当前线程(也可以解除对线程的阻塞)\n         //autoResetEvent.WaitOne();\n         \n         //更新进度条\n         this.progressBar1.Value = i;\n         //线程休眠\n         Thread.Sleep(200);\n     }\n }) { IsBackground=true}.Start();\n... 其他代码\n    \n... 其他代码\n//解除对线程的阻塞\nmanualResetEvent.Set();\n//阻塞当前线程\nmanualResetEvent.Reset();  \n\n// 自动同步事件=\u003eSet\nautoResetEvent.Set();\n.....\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch5\u003e2.6.2 线程锁\u003c/h5\u003e\n\u003col\u003e\n\u003cli\u003elock-----语法糖--常用简单，lock实际Monitor的语法糖\u003c/li\u003e\n\u003cli\u003eMonitor监视锁-----同进程\nMonitor.Enter(obj);//进入监视锁     Monitor.Exit(obj);//退出锁\nMonitor.Wait(obj)释放锁阻塞当前线程   Monitor.Pulse(obj) 唤醒等待线程\u003c/li\u003e\n\u003cli\u003eMutex互斥锁---跨进程\u003cbr\u003e\nmutex.WaitOne();//进入锁     mutex.ReleaseMutex();//释放锁\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003e//lock 锁\n... 其他代码\ndecimal Balance=1000;    \npublic void WithDraw(string name,int amount){\n  lock (this)\n\t{\n    \t//判断余额是否足够\n    \tif (this.Balance \u003e= amount)\n    \t{\n        \t//模拟取款需要的时间\n        \tThread.Sleep(1000);\n        \t//更新余额\n        \tthis.Balance -= amount;\n        \t//提示取款成功\n        \tConsole.WriteLine(name + \"取款成功，余额为：\" + this.Balance);\n    \t}\n    \telse\n    \t{\n        \tConsole.WriteLine(name + \"余额不足，取款失败！\");\n    \t}                \n\t}    \n}\n\n... 其他代码\nnew Thread(() =\u003e account.WithDraw(\"小明\", 800)) { IsBackground=true}.Start();\nnew Thread(() =\u003e account.WithDraw(\"小红\", 800)) { IsBackground = true }.Start();    \n    \n\u003c/code\u003e\u003c/pre\u003e\n\u003ch6\u003e\u003cstrong\u003e1.  \u003ccode\u003eMonitor\u003c/code\u003e 类介绍\u003c/strong\u003e\u003c/h6\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003elock\u003c/code\u003e\u003c/strong\u003e 是 \u003ccode\u003eMonitor\u003c/code\u003e 的语法糖：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003eobject obj = new object();\nlock (obj) \n{\n    // 临界区代码\n}\n\n// 等效于 ↓↓↓\n\nbool lockTaken = false;\ntry \n{\n    Monitor.Enter(obj, ref lockTaken);  // 原子性获取锁\n    // 临界区代码\n}\nfinally \n{\n    if (lockTaken)\n        Monitor.Exit(obj);  // 确保释放锁（避免死锁）\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e**\u003ccode\u003eMonitor.TryEnter\u003c/code\u003e 避免死锁\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003eobject lockObj = new object();\nbool lockTaken = false;\n\n// 尝试获取锁，最多等待 500ms\nif (Monitor.TryEnter(lockObj, 500, ref lockTaken))\n{\n    try\n    {\n        // 临界区代码\n    }\n    finally\n    {\n        if (lockTaken)\n            Monitor.Exit(lockObj);\n    }\n}\nelse\n{\n    // 未能获取锁时的处理（如记录日志或回滚操作）\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eMonitor.Wait()\u003c/code\u003e 和 \u003ccode\u003ePulse()\u003c/code\u003e 实现线程协作\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003eobject syncObj = new object();\n\n// 线程A\nlock (syncObj)\n{\n    // 等待线程B的通知\n    Monitor.Wait(syncObj); // 释放锁并阻塞，直到被 Pulse 唤醒\n}\n\n// 线程B\nlock (syncObj)\n{\n    // 处理任务后唤醒线程A\n    Monitor.Pulse(syncObj); // 或使用 PulseAll 唤醒所有等待线程\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e\u003cstrong\u003e10 async和await异步编程\u003c/strong\u003e\u003c/h2\u003e\n\u003ch3\u003e\u003cstrong\u003e1 基本用法\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e使用 \u003ccode\u003easync\u003c/code\u003e 和 \u003ccode\u003eawait\u003c/code\u003e 关键字实现异步编程：\u003c/p\u003e\n\u003ch3\u003e\u003cstrong\u003e2 返回值\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e返回值类型只能是 void 、Task、Task 中的一个\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003e//返回 Task\u0026#x3C;T\u003e\nstatic async Task\u0026#x3C;int\u003e CalculateAsync1()\n{\n    await Task.Delay(1000);\n    return 42;\n}\n//返回 Task，需要写return，只需要写await。不建议使用void。 \n\nstatic async Task CalculateAsync2()\n{\n    await Task.Delay(1000);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch3\u003e\u003cstrong\u003e3. 取消异步任务（CancellationToken）\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e异步任务可以通过 \u003ccode\u003eCancellationToken\u003c/code\u003e 取消。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003eusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nclass Program\n{\n    static async Task Main()\n    {\n        // 创建 CancellationTokenSource\n        var cts = new CancellationTokenSource();\n\n        // 启动异步任务\n        var task = DoSomethingAsync(cts.Token);\n\n        // 等待用户输入以取消任务\n        Console.WriteLine(\"Press 'C' to cancel the task...\");\n        if (Console.ReadKey().KeyChar == 'c')\n            cts.Cancel();\n\n        try\n        {\n            await task; // 等待任务完成（或取消）\n        }\n        catch (TaskCanceledException)\n        {\n            Console.WriteLine(\"Task was canceled.\");\n        }\n    }\n\n    static async Task DoSomethingAsync(CancellationToken token)\n    {\n        for (int i = 0; i \u0026#x3C; 10; i++)\n        {\n            token.ThrowIfCancellationRequested(); // 检查是否取消\n            Console.WriteLine(\"Working... \" + i);\n            await Task.Delay(500, token); // 支持取消的延迟\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e\u003cstrong\u003e4. 并行\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003eAsParallel\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-C#\"\u003eList\u0026#x3C;int\u003e list = Enumerable.Range(1, 100).AsParallel().Where(n =\u003eisPrime(n)).ToList();\n\nstatic bool isPrime(int n)\n{\n    if (n \u0026#x3C; 2) return false;\n    for (int i = 2; i \u0026#x3C; n; i++)\n    {\n        if (n % i == 0)\n        {\n           return false;\n        }\n\n    }\n     Console.WriteLine(\"素数：{0}\",n);\n     return true;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eParallel.For  Parallel.ForEach\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-C#\"\u003estatic void ParallelTest2() {\n    Parallel.For(1, 30, (i) =\u003e\n    {\n       Console.WriteLine(\"task  {0}\",i);\n       Task.Delay(2000).Wait();\n     });\n     Console.WriteLine(\"主线程结束\");\n}  \n\nstatic void ParallelTest3() {\n   List\u0026#x3C;string\u003e listStr=new List\u0026#x3C;string\u003e(){\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\"}; \n   Parallel.ForEach(listStr, (str) =\u003e\n      {\n        Console.WriteLine(\"task  {0}\",str);\n        Task.Delay(2000).Wait();\n       });\n   Console.WriteLine(\"主线程结束\");\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e\u003cstrong\u003e11. LINQ、SqlServer\u003c/strong\u003e\u003c/h2\u003e\n\u003ch3\u003e11.1 LINQ\u003c/h3\u003e\n\u003ch4\u003e\u003cstrong\u003e一、LINQ 核心原理\u003c/strong\u003e\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e核心理念\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e使用统一的语法操作 \u003cstrong\u003e多种数据源\u003c/strong\u003e（集合、数据库、XML等）\u003c/li\u003e\n\u003cli\u003e基于**延迟执行（Deferred Execution）**机制（查询定义与实际执行分离）\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLINQ 扩展方法定义在静态类 \u003ccode\u003eSystem.Linq.Enumerable\u003c/code\u003e 中，且\u003cstrong\u003e所有方法都针对 \u003ccode\u003eIEnumerable\u0026#x3C;T\u003e\u003c/code\u003e 设计\u003c/strong\u003e,包括list、array、dictionary、stack、queue\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e两种语法风格\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e查询表达式（Query Syntax）\u003c/strong\u003e：接近SQL的声明式风格\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003evar query = from p in products\n            where p.Price \u003e 100\n            select p.Name;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e方法语法（Method Syntax）\u003c/strong\u003e：利用链式扩展方法（推荐用于复杂操作）\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003evar query = products.Where(p =\u003e p.Price \u003e 100).Select(p =\u003e p.Name);\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e核心命名空间\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003eusing System.Linq;           // 基本LINQ操作\nusing System.Linq.Expressions; // 表达式树\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch4\u003e\u003cstrong\u003e二、基础LINQ操作\u003c/strong\u003e\u003c/h4\u003e\n\u003ch5\u003e\u003cstrong\u003e1. 数据源准备\u003c/strong\u003e\u003c/h5\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003epublic class Product\n{\n    public string Name { get; set; }\n    public decimal Price { get; set; }\n    public string Category { get; set; }\n}\n\nList\u0026#x3C;Product\u003e products = new List\u0026#x3C;Product\u003e\n{\n    new Product { Name = \"Laptop\", Price = 1200, Category = \"Electronics\" },\n    new Product { Name = \"Coffee\", Price = 5, Category = \"Food\" },\n    new Product { Name = \"Phone\", Price = 800, Category = \"Electronics\" }\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch5\u003e\u003cstrong\u003e2. 筛选数据（Where）\u003c/strong\u003e\u003c/h5\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003e// 查询表达式\nvar exprQuery = from p in products \n                where p.Price \u003e 100 \u0026#x26;\u0026#x26; p.Category == \"Electronics\"\n                select p;\n\n// 方法语法（Lambda表达式）\nvar methodQuery = products.Where(p =\u003e p.Price \u003e 100 \u0026#x26;\u0026#x26; p.Category == \"Electronics\");\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch5\u003e\u003cstrong\u003e3. 排序（OrderBy, ThenBy）\u003c/strong\u003e\u003c/h5\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003e// 按价格升序，再按名称降序\nvar sorted = products.OrderBy(p =\u003e p.Price)\n                     .ThenByDescending(p =\u003e p.Name);\n\n// 查询表达式\nvar exprSort = from p in products\n               orderby p.Price ascending, p.Name descending\n               select p;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch5\u003e\u003cstrong\u003e4. 分组（GroupBy）\u003c/strong\u003e\u003c/h5\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003e// 按类别分组（方法语法）\nvar groups = products.GroupBy(p =\u003e p.Category);\n\n// 查询表达式\nvar exprGroup = from p in products\n                group p by p.Category into g\n                select new { Category = g.Key, Items = g };\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch5\u003e\u003cstrong\u003e5. 连接（Join）\u003c/strong\u003e\u003c/h5\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003evar orders = new List\u0026#x3C;Order\u003e { /* 订单数据 */ };\n\n// 内连接\nvar joinQuery = from p in products\n                join o in orders on p.Name equals o.ProductName\n                select new { p.Name, o.OrderDate };\n\n// 方法语法\nvar methodJoin = products.Join(orders,\n                      p =\u003e p.Name,\n                      o =\u003e o.ProductName,\n                      (p, o) =\u003e new { p.Name, o.OrderDate });\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch4\u003e\u003cstrong\u003e三、标准查询操作符\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e| \u003cstrong\u003e类别\u003c/strong\u003e        | \u003cstrong\u003e操作符\u003c/strong\u003e                                                     | \u003cstrong\u003e说明\u003c/strong\u003e                              |\n|-----------------|---------------------------------------------------------------|---------------------------------------|\n| \u003cstrong\u003e筛选\u003c/strong\u003e        | \u003ccode\u003eWhere\u003c/code\u003e、\u003ccode\u003eOfType\u0026#x3C;T\u003e\u003c/code\u003e                                         | 条件过滤                             |\n| \u003cstrong\u003e投影\u003c/strong\u003e        | \u003ccode\u003eSelect\u003c/code\u003e、\u003ccode\u003eSelectMany\u003c/code\u003e                                       | 数据转换                             |\n| \u003cstrong\u003e排序\u003c/strong\u003e        | \u003ccode\u003eOrderBy\u003c/code\u003e、\u003ccode\u003eOrderByDescending\u003c/code\u003e、\u003ccode\u003eReverse\u003c/code\u003e                    | 结果排序                             |\n| \u003cstrong\u003e分组\u003c/strong\u003e        | \u003ccode\u003eGroupBy\u003c/code\u003e、\u003ccode\u003eToLookup\u003c/code\u003e                                        | 创建分组                             |\n| \u003cstrong\u003e连接\u003c/strong\u003e        | \u003ccode\u003eJoin\u003c/code\u003e、\u003ccode\u003eGroupJoin\u003c/code\u003e、\u003ccode\u003eZip\u003c/code\u003e                                   | 组合数据源                          |\n| \u003cstrong\u003e聚合\u003c/strong\u003e        | \u003ccode\u003eCount\u003c/code\u003e、\u003ccode\u003eSum\u003c/code\u003e、\u003ccode\u003eAverage\u003c/code\u003e、\u003ccode\u003eMin\u003c/code\u003e、\u003ccode\u003eMax\u003c/code\u003e、\u003ccode\u003eAggregate\u003c/code\u003e          | 数值计算                             |\n| \u003cstrong\u003e转换\u003c/strong\u003e        | \u003ccode\u003eToArray\u003c/code\u003e、\u003ccode\u003eToList\u003c/code\u003e、\u003ccode\u003eToDictionary\u003c/code\u003e、\u003ccode\u003eCast\u0026#x3C;T\u003e\u003c/code\u003e、\u003ccode\u003eAsEnumerable\u003c/code\u003e | 类型转换                             |\n| \u003cstrong\u003e元素操作\u003c/strong\u003e    | \u003ccode\u003eFirst\u003c/code\u003e、\u003ccode\u003eLast\u003c/code\u003e、\u003ccode\u003eElementAt\u003c/code\u003e、\u003ccode\u003eSingle\u003c/code\u003e、\u003ccode\u003eDefaultIfEmpty\u003c/code\u003e      | 获取特定元素                         |\n| \u003cstrong\u003e集合操作\u003c/strong\u003e    | \u003ccode\u003eDistinct\u003c/code\u003e、\u003ccode\u003eUnion\u003c/code\u003e、\u003ccode\u003eIntersect\u003c/code\u003e、\u003ccode\u003eExcept\u003c/code\u003e                   | 集合运算                             |\n| \u003cstrong\u003e分页\u003c/strong\u003e        | \u003ccode\u003eSkip\u003c/code\u003e、\u003ccode\u003eTake\u003c/code\u003e                                               | 分页处理                             |\n| \u003cstrong\u003e条件检查\u003c/strong\u003e    | \u003ccode\u003eAny\u003c/code\u003e、\u003ccode\u003eAll\u003c/code\u003e、\u003ccode\u003eContains\u003c/code\u003e                                      | 条件验证                             |\n| \u003cstrong\u003e生成序列\u003c/strong\u003e    | \u003ccode\u003eRange\u003c/code\u003e、\u003ccode\u003eRepeat\u003c/code\u003e、\u003ccode\u003eEmpty\u003c/code\u003e                                    | 动态生成数据                        |\u003c/p\u003e\n\u003chr\u003e\n\u003ch4\u003e\u003cstrong\u003e四、重要技巧与示例\u003c/strong\u003e\u003c/h4\u003e\n\u003ch5\u003e\u003cstrong\u003e1. 延迟执行 vs 即时执行\u003c/strong\u003e\u003c/h5\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003evar deferredQuery = products.Where(p =\u003e p.Price \u003e 100); // 定义查询但未执行\nvar immediateList = deferredQuery.ToList();             // 立即执行并物化为列表\n\nproducts.Add(new Product { Price = 200 }); \nConsole.WriteLine(immediateList.Count);    // 结果不变（已物化）\nConsole.WriteLine(deferredQuery.Count());  // 包含新数据（延迟执行）\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch5\u003e\u003cstrong\u003e2. 动态条件构建\u003c/strong\u003e\u003c/h5\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003eIQueryable\u0026#x3C;Product\u003e query = dbContext.Products.AsQueryable();\n\nif (filterByCategory)\n    query = query.Where(p =\u003e p.Category == selectedCategory);\n\nif (minPrice \u003e 0)\n    query = query.Where(p =\u003e p.Price \u003e= minPrice);\n\nvar finalResults = query.ToList(); // 动态组合条件\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch5\u003e\u003cstrong\u003e3. Lambda表达式与Func委托\u003c/strong\u003e\u003c/h5\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003eFunc\u0026#x3C;Product, bool\u003e filter = p =\u003e p.Price \u003e 100;\nvar query = products.Where(filter);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch5\u003e\u003cstrong\u003e4. 匿名类型与投影\u003c/strong\u003e\u003c/h5\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003evar productInfo = products.Select(p =\u003e new \n{\n    p.Name,\n    PriceWithTax = p.Price * 1.1M,\n    IsExpensive = p.Price \u003e 1000\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch5\u003e\u003cstrong\u003e5. 处理Null值\u003c/strong\u003e\u003c/h5\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003evar safeQuery = products.Where(p =\u003e p.Category != null)\n                        .Select(p =\u003e p.Name.ToUpper());\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch4\u003e\u003cstrong\u003e五、LINQ to Entities（Entity Framework Core）\u003c/strong\u003e\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003e// 结合EF Core的数据库查询\nusing (var context = new AppDbContext())\n{\n    var query = context.Products\n        .Where(p =\u003e p.Price \u003e 100)\n        .OrderByDescending(p =\u003e p.CreatedDate)\n        .Select(p =\u003e new { p.Name, p.Price })\n        .ToList();\n  \n    // 转换为SQL：\n    // SELECT [p].[Name], [p].[Price]\n    // FROM [Products] AS [p]\n    // WHERE [p].[Price] \u003e 100\n    // ORDER BY [p].[CreatedDate] DESC\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch4\u003e\u003cstrong\u003e六、性能优化\u003c/strong\u003e\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e数据库端过滤\u003c/strong\u003e：确保条件在\u003ccode\u003eWhere\u003c/code\u003e中传递到数据库（避免客户端过滤）\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e避免N+1查询\u003c/strong\u003e：使用\u003ccode\u003eInclude\u003c/code\u003e或投影预先加载关联数据\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003e// 优化前（N+1问题）\nvar orders = context.Orders.ToList();\nforeach (var o in orders)\n    Console.WriteLine(o.Customer.Name);\n\n// 优化后（一次性加载关联数据）\nvar optimized = context.Orders.Include(o =\u003e o.Customer).ToList();\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e分页建议\u003c/strong\u003e：始终在服务端进行分页（结合\u003ccode\u003eSkip\u003c/code\u003e和\u003ccode\u003eTake\u003c/code\u003e）\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003evar pageData = context.Products\n                     .OrderBy(p =\u003e p.Name)\n                     .Skip((pageIndex - 1) * pageSize)\n                     .Take(pageSize)\n                     .ToList();\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch4\u003e\u003cstrong\u003e七、常见场景对照表\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e| \u003cstrong\u003eSQL操作\u003c/strong\u003e         | \u003cstrong\u003eLINQ等价实现\u003c/strong\u003e                              |\n|---------------------|----------------------------------------------|\n| \u003ccode\u003eSELECT * FROM Table\u003c/code\u003e | \u003ccode\u003edbContext.Table.ToList()\u003c/code\u003e                  |\n| \u003ccode\u003eWHERE\u003c/code\u003e             | \u003ccode\u003e.Where(p =\u003e p.Condition)\u003c/code\u003e                  |\n| \u003ccode\u003eORDER BY\u003c/code\u003e          | \u003ccode\u003e.OrderBy()\u003c/code\u003e / \u003ccode\u003e.OrderByDescending()\u003c/code\u003e       |\n| \u003ccode\u003eJOIN\u003c/code\u003e              | \u003ccode\u003e.Join()\u003c/code\u003e 或导航属性                       |\n| \u003ccode\u003eGROUP BY\u003c/code\u003e          | \u003ccode\u003e.GroupBy()\u003c/code\u003e                               |\n| \u003ccode\u003eHAVING\u003c/code\u003e            | \u003ccode\u003e.Select(...).Where(groupCondition)\u003c/code\u003e       |\n| \u003ccode\u003eTOP N\u003c/code\u003e             | \u003ccode\u003e.Take(N)\u003c/code\u003e                                 |\u003c/p\u003e\n\u003ch3\u003e11.2 SqlServer\u003c/h3\u003e\n\u003ch4\u003e\u003cstrong\u003e一、命名空间与NuGet包\u003c/strong\u003e\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e基础依赖\u003c/strong\u003e：使用 \u003ccode\u003eSystem.Data.SqlClient\u003c/code\u003e（旧版）或 \u003cstrong\u003e\u003ccode\u003eMicrosoft.Data.SqlClient\u003c/code\u003e\u003c/strong\u003e（新版推荐）\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# NuGet安装命令\ndotnet add package Microsoft.Data.SqlClient\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e重要命名空间\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003eusing Microsoft.Data.SqlClient; // 核心API\nusing System.Data;              // DataTable、DataSet等通用类型\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch4\u003e\u003cstrong\u003e二、核心操作流程\u003c/strong\u003e\u003c/h4\u003e\n\u003ch5\u003e\u003cstrong\u003e1. 连接数据库\u003c/strong\u003e\u003c/h5\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003e// 连接字符串（推荐从配置文件读取）\nstring connectionString = \"Server=myserver;Database=mydb;Integrated Security=True;TrustServerCertificate=True\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    connection.Open();\n    // 后续操作...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e连接字符串关键参数\u003c/strong\u003e：\n| \u003cstrong\u003e参数\u003c/strong\u003e              | \u003cstrong\u003e说明\u003c/strong\u003e                                      |\n|-----------------------|----------------------------------------------|\n| \u003ccode\u003eServer\u003c/code\u003e              | 服务器地址（如 \u003ccode\u003elocalhost\u003c/code\u003e、\u003ccode\u003e192.168.1.10\u003c/code\u003e） |\n| \u003ccode\u003eDatabase\u003c/code\u003e            | 数据库名称                                   |\n| \u003ccode\u003eUser ID\u003c/code\u003e / \u003ccode\u003ePassword\u003c/code\u003e| SQL账号密码（若用混合验证）                  |\n| \u003ccode\u003eIntegrated Security\u003c/code\u003e | 使用Windows身份验证（设置为\u003ccode\u003eTrue\u003c/code\u003e或\u003ccode\u003eSSPI\u003c/code\u003e）  |\n| \u003ccode\u003eTrustServerCertificate\u003c/code\u003e | 开发环境跳过SSL验证（设为\u003ccode\u003eTrue\u003c/code\u003e）          |\u003c/p\u003e\n\u003chr\u003e\n\u003ch5\u003e\u003cstrong\u003e2. 执行SQL命令\u003c/strong\u003e\u003c/h5\u003e\n\u003ch6\u003e\u003cstrong\u003ea. 查询数据（\u003c/strong\u003e\u003ccode\u003eExecuteReader返回SqlDataReader\u003c/code\u003e\u003cstrong\u003e）\u003c/strong\u003e\u003c/h6\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003estring sql = \"SELECT Id, Name FROM Users WHERE Age \u003e @age\";\nusing (var command = new SqlCommand(sql, connection))\n{\n    command.Parameters.AddWithValue(\"@age\", 18);\n    using (var reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            int id = reader.GetInt32(0);\n            string name = reader.GetString(1);\n            Console.WriteLine($\"ID: {id}, Name: {name}\");\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch6\u003e\u003cstrong\u003eb. 插入/更新数据（\u003c/strong\u003e\u003ccode\u003eExecuteNonQuery\u003c/code\u003e\u003cstrong\u003e）\u003c/strong\u003e\u003c/h6\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003estring insertSql = @\"INSERT INTO Users (Name, Age) \n                     VALUES (@name, @age)\";\nusing (var command = new SqlCommand(insertSql, connection))\n{\n    command.Parameters.AddWithValue(\"@name\", \"Alice\");\n    command.Parameters.AddWithValue(\"@age\", 25);\n    int rowsAffected = command.ExecuteNonQuery(); // 返回受影响的行数\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch6\u003e\u003cstrong\u003ec. 事务处理 SqlTransaction\u003c/strong\u003e\u003c/h6\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003eusing (var transaction = connection.BeginTransaction())\n{\n    try\n    {\n        var command1 = new SqlCommand(\"UPDATE Account SET Balance -= 100 WHERE Id = 1\", connection, transaction);\n        var command2 = new SqlCommand(\"UPDATE Account SET Balance += 100 WHERE Id = 2\", connection, transaction);\n        command1.ExecuteNonQuery();\n        command2.ExecuteNonQuery();\n        transaction.Commit(); // 提交事务\n    }\n    catch\n    {\n        transaction.Rollback(); // 回滚事务\n        throw;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch5\u003e\u003cstrong\u003e3. 数据集操作（\u003c/strong\u003e\u003ccode\u003eSqlDataAdapter\u003c/code\u003e\u003cstrong\u003e）\u003c/strong\u003e\u003c/h5\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003evar adapter = new SqlDataAdapter(\"SELECT * FROM Products\", connection);\nvar dataset = new DataSet();\nadapter.Fill(dataset, \"Products\"); // 填充数据集\n\n// 修改数据并更新回数据库\nDataTable table = dataset.Tables[\"Products\"];\ntable.Rows[0][\"Price\"] = 99.99;\n\nvar builder = new SqlCommandBuilder(adapter); // 自动生成更新命令\nadapter.Update(dataset, \"Products\");\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch4\u003e\u003cstrong\u003e三、进阶技巧\u003c/strong\u003e\u003c/h4\u003e\n\u003ch5\u003e\u003cstrong\u003e1. 参数化查询最佳实践\u003c/strong\u003e\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e避免SQL注入\u003c/strong\u003e：始终用 \u003ccode\u003eSqlParameter\u003c/code\u003e 代替字符串拼接\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e明确参数类型\u003c/strong\u003e：推荐使用 \u003ccode\u003eAdd()\u003c/code\u003e 代替 \u003ccode\u003eAddWithValue()\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003evar param = new SqlParameter(\"@date\", SqlDbType.DateTime);\nparam.Value = DateTime.Now;\ncommand.Parameters.Add(param);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch5\u003e\u003cstrong\u003e2. 批量插入（\u003c/strong\u003e\u003ccode\u003eSqlBulkCopy\u003c/code\u003e\u003cstrong\u003e）\u003c/strong\u003e\u003c/h5\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003eusing (var bulkCopy = new SqlBulkCopy(connection))\n{\n    bulkCopy.DestinationTableName = \"Orders\";\n    bulkCopy.WriteToServer(dataTable); // 高速批量插入（DataTable或IDataReader）\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch5\u003e\u003cstrong\u003e3. 异步操作（.NET 5+）\u003c/strong\u003e\u003c/h5\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003eawait using (var connection = new SqlConnection(connectionString))\n{\n    await connection.OpenAsync();\n    var command = new SqlCommand(\"WAITFOR DELAY '00:00:02';\", connection);\n    await command.ExecuteNonQueryAsync(); // 异步等待\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch5\u003e\u003cstrong\u003e4. 存储过程调用\u003c/strong\u003e\u003c/h5\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003eusing (var command = new SqlCommand(\"usp_GetUserInfo\", connection))\n{\n    command.CommandType = CommandType.StoredProcedure;\n    command.Parameters.AddWithValue(\"@userId\", 123);\n    using (var reader = command.ExecuteReader())\n    {\n        // 处理结果...\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch4\u003e\u003cstrong\u003e四、错误处理与资源管理\u003c/strong\u003e\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003etry\n{\n    using (var connection = new SqlConnection(connectionString))\n    {\n        connection.Open();\n        // 执行命令...\n    }\n}\ncatch (SqlException ex) // 捕获SQL特定异常\n{\n    Console.WriteLine($\"数据库错误: {ex.Message}\");\n    foreach (SqlError error in ex.Errors)\n    {\n        Console.WriteLine($\"错误代码: {error.Number}, 消息: {error.Message}\");\n    }\n}\ncatch (Exception ex)\n{\n    Console.WriteLine($\"通用异常: {ex.Message}\");\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch4\u003e\u003cstrong\u003e五、Entity Framework Core集成（可选）\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e若需更高层抽象，推荐使用 \u003cstrong\u003eORM工具\u003c/strong\u003e（如EF Core）：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003e// 定义DbContext\npublic class AppDbContext : DbContext\n{\n    public DbSet\u0026#x3C;User\u003e Users { get; set; }\n    protected override void OnConfiguring(DbContextOptionsBuilder options)\n        =\u003e options.UseSqlServer(\"连接字符串\");\n}\n\n// 示例查询\nusing (var context = new AppDbContext())\n{\n    var user = await context.Users\n                    .Where(u =\u003e u.Age \u003e 18)\n                    .FirstOrDefaultAsync();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e\u003cstrong\u003e12 网络通信\u003c/strong\u003e\u003c/h2\u003e\n\u003cp\u003e看网络通信笔记\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e\u003cstrong\u003e13 表达式\u003c/strong\u003e\u003c/h2\u003e\n\u003ch3\u003e\u003cstrong\u003e1. Lambda 表达式\u003c/strong\u003e\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003e// 隐式类型（表达式形式）\nFunc\u0026#x3C;int, int\u003e square = x =\u003e x * x;\nConsole.WriteLine(square(5)); // 输出 25\n\n// 显式语句块（带大括号）\nAction\u0026#x3C;string\u003e log = message =\u003e \n{\n    Console.WriteLine($\"[LOG] {DateTime.Now}: {message}\");\n};\nlog(\"Hello!\");\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch3\u003e\u003cstrong\u003e2. 空条件运算符 (\u003ccode\u003e?.\u003c/code\u003e 和 \u003ccode\u003e?[]\u003c/code\u003e)\u003c/strong\u003e\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003e// 避免 NullReferenceException\nstring name = person?.Name;          // 如果 person 为 null，返回 null\nint length = person?.Name?.Length ?? 0; // 链式安全访问 + 空合并运算符\n\n// 安全访问集合\nList\u0026#x3C;int\u003e numbers = null;\nint? first = numbers?[0];            // 如果 numbers 为 null，返回 null\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch3\u003e\u003cstrong\u003e3. 空合并运算符 (\u003ccode\u003e??\u003c/code\u003e 和 \u003ccode\u003e??=\u003c/code\u003e)\u003c/strong\u003e\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003estring name = inputName ?? \"Anonymous\"; // 如果 inputName 为 null，返回 \"Anonymous\"\n\n// 简化 null 检查赋值\nList\u0026#x3C;int\u003e list = null;\nlist ??= new List\u0026#x3C;int\u003e(); // 如果 list 为 null，初始化新对象\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch3\u003e\u003cstrong\u003e4. 模式匹配 switch表达式\u003c/strong\u003e\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003e\n// Switch 表达式 (C# 8+)\nstring message = shape switch\n{\n    Circle c =\u003e $\"Circle with radius {c.Radius}\",\n    Rectangle r =\u003e $\"Rectangle {r.Width}x{r.Height}\",\n    _ =\u003e \"Unknown shape\"\n};\n\n// 关系模式 (C# 9+)\nstring grade = score switch\n{\n    \u003e= 90 =\u003e \"A\",\n    \u003e= 80 =\u003e \"B\",\n    \u003e= 60 =\u003e \"C\",\n    _ =\u003e \"F\"\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch3\u003e\u003cstrong\u003e5. 对象与集合初始化表达式\u003c/strong\u003e\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003e// 对象初始化\nvar person = new Person \n{ \n    Name = \"Alice\", \n    Age = 30 \n};\n\n// 集合初始化\nvar numbers = new List\u0026#x3C;int\u003e { 1, 2, 3 };\nvar dict = new Dictionary\u0026#x3C;string, int\u003e\n{\n    [\"one\"] = 1,\n    [\"two\"] = 2\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch3\u003e\u003cstrong\u003e6. 字符串插值 (\u003ccode\u003e$\u003c/code\u003e)\u003c/strong\u003e\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003estring name = \"Bob\";\nint age = 25;\nConsole.WriteLine($\"{name} is {age} years old.\"); // 输出 \"Bob is 25 years old.\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch3\u003e\u003cstrong\u003e7. 索引与范围运算符 (\u003ccode\u003e^\u003c/code\u003e 和 \u003ccode\u003e..\u003c/code\u003e) (C# 8+)\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e[[^]start]..[[^]end],  含头不含尾,^是倒数的意思\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003eint[] arr = { 0, 1, 2, 3, 4, 5 };\nint last = arr[^1];      // 5（倒数第一个）\nint[] sub = arr[1..4];   // {1, 2, 3}（区间左闭右开）\nint[] all = arr[..];     // 整个数组的拷贝\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch3\u003e\u003cstrong\u003e8. LINQ 表达式\u003c/strong\u003e\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003evar result = from p in people\n             where p.Age \u003e 18\n             orderby p.Name\n             select new { p.Name, p.Age };\n\n// 方法链式写法（等同效果）\nvar result = people\n    .Where(p =\u003e p.Age \u003e 18)\n    .OrderBy(p =\u003e p.Name)\n    .Select(p =\u003e new { p.Name, p.Age });\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch3\u003e\u003cstrong\u003e9. 异步表达式 (\u003ccode\u003easync\u003c/code\u003e/\u003ccode\u003eawait\u003c/code\u003e)\u003c/strong\u003e\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003epublic async Task DownloadFileAsync()\n{\n    using var client = new HttpClient();\n    string content = await client.GetStringAsync(\"https://example.com\");\n    await File.WriteAllTextAsync(\"file.txt\", content);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch3\u003e\u003cstrong\u003e10. 析构与元组\u003c/strong\u003e\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003e// 元组初始化与析构\nvar tuple = (Name: \"Alice\", Age: 30);\n(string name, int age) = tuple;\n\n// 方法返回元组\npublic (int, string) GetData() =\u003e (42, \"Answer\");\n\n// 接收返回值（直接析构）\nvar (number, text) = GetData();\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch3\u003e\u003cstrong\u003e11. 记录类型 (C# 9+)\u003c/strong\u003e\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003epublic record Person(string Name, int Age); // 不可变记录\n\nvar person1 = new Person(\"Bob\", 25);\nvar person2 = person1 with { Age = 26 }; // 通过 with 表达式创建副本\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch3\u003e\u003cstrong\u003e12. 异常筛选器 (\u003ccode\u003ewhen\u003c/code\u003e 子句, C# 6+)\u003c/strong\u003e\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003etry { /* 可能抛异常的操作 */ }\ncatch (HttpRequestException ex) when (ex.StatusCode == 404)\n{\n    Console.WriteLine(\"Resource not found!\");\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch3\u003e\u003cstrong\u003e13. 全局命名空间 (C# 10+)\u003c/strong\u003e\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003eglobal using System; // 整个项目生效的全局引用\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch3\u003e\u003cstrong\u003e14. 静态匿名函数 (\u003ccode\u003estatic\u003c/code\u003e in Lambda, C# 9+)\u003c/strong\u003e\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003e// 禁止捕获外部变量，避免意外闭包\nFunc\u0026#x3C;int, int\u003e multiplier = static x =\u003e x * 2;\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch3\u003e\u003cstrong\u003e15. 可空引用类型 (C# 8+ \u003ccode\u003e?\u003c/code\u003e 标记)\u003c/strong\u003e\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003estring? nullableString = null; // 明确声明允许 null\nstring nonNullable = \"Hello\"; // 默认不可为 null（编译器警告）\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch3\u003e\u003cstrong\u003e16. 类型测试is typeof与强制转换表达式\u003c/strong\u003e\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003e// 类型模式 is\nif (obj is int i)\n{\n    Console.WriteLine($\"It's an integer: {i}\");\n}\n\n// typeof 运算符的实参必须是类型或类型形参的名称\nConsole.WriteLine(typeof(Dictionary\u0026#x3C;,\u003e));\n\t\npublic class Animal { }\n\t\npublic class Giraffe : Animal { }\n\t\npublic static class TypeOfExample\n{\n\tpublic static void Main()\n\t{\n\t    object b = new Giraffe();\n\t    Console.WriteLine(b is Animal);  // output: True\n\t    Console.WriteLine(b.GetType() == typeof(Animal));  \n\t    // output: False\n\t\n\t    Console.WriteLine(b is Giraffe);  // output: True\n\t    Console.WriteLine(b.GetType() == typeof(Giraffe));  \n\t    // output: \t\tTrue\n\t}\n}\n// 强制转换 (T)E 的强制转换表达式将表达式 E 的结果显式转换为类型 T\ndouble x = 1234.7;\nint a = (int)x;\nConsole.WriteLine(a);   // output: 1234\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch3\u003e\u003cstrong\u003e17. with\u003c/strong\u003e\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003epublic record NamedPoint(string Name, int X, int Y);\npublic static void Main()\n{\n\tvar p1 = new NamedPoint(\"A\", 0, 0);\n\tConsole.WriteLine($\"{nameof(p1)}: {p1}\");  \n\t// output: p1: NamedPoint { Name = A, X = 0, Y = 0 }\n\t    \n\tvar p2 = p1 with { Name = \"B\", X = 5 };\n\tConsole.WriteLine($\"{nameof(p2)}: {p2}\");  \n\t// output: p2: NamedPoint { Name = B, X = 5, Y = 0 }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch3\u003e\u003cstrong\u003e附：操作优先级备忘\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e| \u003cstrong\u003e运算符\u003c/strong\u003e | \u003cstrong\u003e例子\u003c/strong\u003e        | \u003cstrong\u003e描述\u003c/strong\u003e          |\n| ---------- | --------------- | ----------------- |\n| \u003ccode\u003e?.\u003c/code\u003e \u003ccode\u003e?[]\u003c/code\u003e | \u003ccode\u003eobj?.Method()\u003c/code\u003e | 空条件运算符      |\n| \u003ccode\u003e??\u003c/code\u003e \u003ccode\u003e??=\u003c/code\u003e | \u003ccode\u003ea ?? b\u003c/code\u003e        | 空合并运算符      |\n| \u003ccode\u003e=\u003e\u003c/code\u003e       | \u003ccode\u003ex =\u003e x + 1\u003c/code\u003e    | Lambda 箭头运算符 |\n| \u003ccode\u003eis\u003c/code\u003e \u003ccode\u003eas\u003c/code\u003e  | \u003ccode\u003eif (x is int)\u003c/code\u003e | 类型检查/转换     |\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e\u003cstrong\u003e14 正则\u003c/strong\u003e\u003c/h2\u003e\n\u003ch3\u003e\u003cstrong\u003e1. 正则表达式与通配符对比\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e| \u003cstrong\u003e类型\u003c/strong\u003e | \u003cstrong\u003e通配符（如文件匹配）\u003c/strong\u003e       | \u003cstrong\u003e正则表达式\u003c/strong\u003e                            |\n| -------- | ------------------------------ | ----------------------------------------- |\n| 匹配范围 | 简单文件路径（\u003ccode\u003e*.txt\u003c/code\u003e）        | 复杂文本模式（邮件、电话号、URL等）       |\n| 标准语法 | \u003ccode\u003e?\u003c/code\u003e（单字符）、\u003ccode\u003e*\u003c/code\u003e（任意字符） | 元字符组合（如\u003ccode\u003e\\d\u003c/code\u003e、\u003ccode\u003e[a-z]\u003c/code\u003e、\u003ccode\u003e^\u003c/code\u003e、\u003ccode\u003e$\u003c/code\u003e等） |\n| 场景举例 | 文件搜索：\u003ccode\u003eDocument?.docx\u003c/code\u003e     | 数据验证：\u003ccode\u003e^\\w+@\\w+\\.\\w+$\u003c/code\u003e                |\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e\u003cstrong\u003e2. 正则表达式核心语法\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e| \u003cstrong\u003e类别\u003c/strong\u003e       | \u003cstrong\u003e语法/符号\u003c/strong\u003e        | \u003cstrong\u003e功能说明\u003c/strong\u003e                   | \u003cstrong\u003e示例\u003c/strong\u003e                            |\n| -------------- | -------------------- | ------------------------------ | ----------------------------------- |\n| \u003cstrong\u003e基础匹配\u003c/strong\u003e   | \u003ccode\u003e.\u003c/code\u003e                  | 匹配任意单字符（除换行符）     | \u003ccode\u003ea.c\u003c/code\u003e → \"abc\", \"a@c\"                |\n| \u003cstrong\u003e转义符\u003c/strong\u003e     | \u003ccode\u003e\\\u003c/code\u003e                  | 转义特殊字符（如\u003ccode\u003e\\.\u003c/code\u003e匹配点号） | \u003ccode\u003e\\\\d\u003c/code\u003e → 匹配字符串\"\\d\"              |\n| \u003cstrong\u003e字符类\u003c/strong\u003e     | \u003ccode\u003e[abc]\u003c/code\u003e              | 匹配括号内任意字符             | \u003ccode\u003e[aeiou]\u003c/code\u003e → 匹配任意元音字母        |\n|                | \u003ccode\u003e[^abc]\u003c/code\u003e             | 匹配不在括号内的字符           | \u003ccode\u003e[^0-9]\u003c/code\u003e → 匹配非数字字符           |\n|                | \u003ccode\u003e[a-z]\u003c/code\u003e              | 匹配字符范围                   | \u003ccode\u003e[A-Fa-f]\u003c/code\u003e → 匹配十六进制字符       |\n| \u003cstrong\u003e预定义字符\u003c/strong\u003e | \u003ccode\u003e\\d\u003c/code\u003e                 | 数字（等价于\u003ccode\u003e[0-9]\u003c/code\u003e）          | \u003ccode\u003e\\d\\d\u003c/code\u003e → \"01\", \"99\"                 |\n|                | \u003ccode\u003e\\w\u003c/code\u003e                 | 单词字符（字母/数字/下划线）   | \u003ccode\u003e\\w+\u003c/code\u003e → 匹配整个单词                |\n|                | \u003ccode\u003e\\s\u003c/code\u003e                 | 空白字符（空格、制表符等）     | \u003ccode\u003e\\s+\u003c/code\u003e → 匹配连续空格                |\n| \u003cstrong\u003e量词\u003c/strong\u003e       | \u003ccode\u003e*\u003c/code\u003e                  | 前导元素出现 \u003cstrong\u003e0次或多次\u003c/strong\u003e     | \u003ccode\u003eab*c\u003c/code\u003e → \"ac\", \"abbc\"               |\n|                | \u003ccode\u003e+\u003c/code\u003e                  | 前导元素出现 \u003cstrong\u003e1次或多次\u003c/strong\u003e     | \u003ccode\u003e\\d+\u003c/code\u003e → \"5\", \"123\"                  |\n|                | \u003ccode\u003e?\u003c/code\u003e                  | 前导元素出现 \u003cstrong\u003e0次或1次\u003c/strong\u003e      | \u003ccode\u003ecolou?r\u003c/code\u003e → \"color\", \"colour\"       |\n|                | \u003ccode\u003e{n}\u003c/code\u003e/\u003ccode\u003e{n,}\u003c/code\u003e/\u003ccode\u003e{n,m}\u003c/code\u003e | 精确次数/最少n次/范围次数      | \u003ccode\u003e\\d{3,5}\u003c/code\u003e → \"123\", \"45678\"          |\n| \u003cstrong\u003e分组与捕获\u003c/strong\u003e | \u003ccode\u003e(exp)\u003c/code\u003e              | 捕获分组并分配编号             | \u003ccode\u003e(\\d{3})-(\\d{4})\u003c/code\u003e → 分组1: 区号     |\n|                | \u003ccode\u003e(?:exp)\u003c/code\u003e            | 非捕获分组（仅分组，不记录）   | \u003ccode\u003e(?:http\\|ftp)://\u003c/code\u003e → 不捕获协议类型 |\n| \u003cstrong\u003e锚点\u003c/strong\u003e       | \u003ccode\u003e^\u003c/code\u003e                  | 匹配字符串开始                 | \u003ccode\u003e^\\d+\u003c/code\u003e → 字符串必须以数字开头       |\n|                | \u003ccode\u003e$\u003c/code\u003e                  | 匹配字符串结束                 | \u003ccode\u003e\\w+$\u003c/code\u003e → 字符串必须以单词字符结尾   |\n| \u003cstrong\u003e逻辑或\u003c/strong\u003e     | \u003ccode\u003e\\|\u003c/code\u003e                 | 匹配左侧或右侧表达式           | \u003ccode\u003ecat\\|dog\u003c/code\u003e → \"cat\"或\"dog\"           |\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e\u003cstrong\u003e3. 在C#中的操作（System.Text.RegularExpressions）\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e| \u003cstrong\u003e操作类型\u003c/strong\u003e | \u003cstrong\u003e方法/属性\u003c/strong\u003e                                | \u003cstrong\u003e功能说明\u003c/strong\u003e                              | \u003cstrong\u003e代码示例\u003c/strong\u003e                                       |\n| ------------ | -------------------------------------------- | ----------------------------------------- | -------------------------------------------------- |\n| \u003cstrong\u003e匹配验证\u003c/strong\u003e | \u003ccode\u003eRegex.IsMatch(input, pattern)\u003c/code\u003e              | 判断字符串是否匹配模式                    | \u003ccode\u003eif (Regex.IsMatch(phone, @\"^\\d{3}-\\d{8}$\"))\u003c/code\u003e      |\n| \u003cstrong\u003e提取匹配\u003c/strong\u003e | \u003ccode\u003eRegex.Match()\u003c/code\u003e                              | 提取第一个匹配结果（返回\u003ccode\u003eMatch\u003c/code\u003e对象）     | \u003ccode\u003eMatch m = Regex.Match(text, @\"\\d+\")\u003c/code\u003e              |\n|              | \u003ccode\u003eRegex.Matches()\u003c/code\u003e                            | 提取所有匹配结果（返回\u003ccode\u003eMatchCollection\u003c/code\u003e） | \u003ccode\u003eforeach (Match m in Regex.Matches(...))\u003c/code\u003e          |\n| \u003cstrong\u003e替换文本\u003c/strong\u003e | \u003ccode\u003eRegex.Replace(input, pattern, replacement)\u003c/code\u003e | 替换匹配内容                              | \u003ccode\u003estring clean = Regex.Replace(input, @\"\\s+\", \" \")\u003c/code\u003e |\n| \u003cstrong\u003e分割文本\u003c/strong\u003e | \u003ccode\u003eRegex.Split(input, pattern)\u003c/code\u003e                | 按正则表达式分割字符串                    | \u003ccode\u003estring[] parts = Regex.Split(...)\u003c/code\u003e                |\n| \u003cstrong\u003e选项控制\u003c/strong\u003e | \u003ccode\u003eRegexOptions.IgnoreCase\u003c/code\u003e                    | 忽略大小写（作为参数传入）                | \u003ccode\u003enew Regex(pattern, RegexOptions.IgnoreCase)\u003c/code\u003e      |\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e\u003cstrong\u003e4. 常用正则表达式示例\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e| \u003cstrong\u003e场景\u003c/strong\u003e         | \u003cstrong\u003e正则模式\u003c/strong\u003e                                    | \u003cstrong\u003e说明\u003c/strong\u003e                           |\n| ---------------- | ----------------------------------------------- | ---------------------------------- |\n| 中国大陆手机号   | \u003ccode\u003e^1[3-9]\\d{9}$\u003c/code\u003e                                 | 11位数字，以13-19开头              |\n| 邮箱验证         | \u003ccode\u003e^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$\u003c/code\u003e | 简化版通用邮箱格式                 |\n| 提取HTML标签内容 | \u003ccode\u003e\u0026#x3C;\\s*([a-z]+)[^\u003e]*\u003e(.*?)\u0026#x3C;/\\1\u003e\u003c/code\u003e                  | 分组捕获标签名和内容（非贪婪匹配） |\n| 中文匹配         | \u003ccode\u003e[\\u4e00-\\u9fa5]+\u003c/code\u003e                              | 匹配连续中文字符                   |\n| URL提取          | \u003ccode\u003e(https?://)?([\\w学-]+\\.)+[\\w-]+(/[\\w-?=\u0026#x26;]*)?\u003c/code\u003e  | 匹配HTTP/HTTPS链接                 |\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e\u003cstrong\u003e5. 注意事项\u003c/strong\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e贪婪与懒惰\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e贪婪量词\u003c/strong\u003e（默认）：\u003ccode\u003e*\u003c/code\u003e、\u003ccode\u003e+\u003c/code\u003e → 尽可能多匹配（如\u003ccode\u003e\u0026#x3C;.*\u003e\u003c/code\u003e会匹配到最后一个\u003ccode\u003e\u003e\u003c/code\u003e）\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e懒惰量词\u003c/strong\u003e：\u003ccode\u003e*?\u003c/code\u003e、\u003ccode\u003e+?\u003c/code\u003e → 尽可能少匹配（如\u003ccode\u003e\u0026#x3C;.*?\u003e\u003c/code\u003e正确匹配单个HTML标签）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e性能优化\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e频繁使用的正则表达式 → 用\u003ccode\u003eRegex\u003c/code\u003e构造函数\u003cstrong\u003e预编译\u003c/strong\u003e（\u003ccode\u003eRegexOptions.Compiled\u003c/code\u003e）\u003c/li\u003e\n\u003cli\u003e避免回溯爆炸 → 优先使用具体字符集（如用\u003ccode\u003e\\d\u003c/code\u003e替代\u003ccode\u003e[0-9]\u003c/code\u003e）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e特殊符号转义\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003e// C#字符串中需对反斜杠转义\nstring pattern = @\"^\\d+$\";  // 推荐逐字字符串\n// 或\nstring pattern = \"^\\\\d+$\";  // 标准字符串写法\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch4\u003e\u003cstrong\u003e使用案例\u003c/strong\u003e\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-csharp\"\u003e// 提取所有电话号码\nstring text = \"联系人：张三 13812345678，李四 13987654321\";\nvar matches = Regex.Matches(text, @\"1[3-9]\\d{9}\");\nforeach (Match m in matches) {\n    Console.WriteLine($\"找到号码：{m.Value}\");\n}\n\n// 替换敏感词\nstring censored = Regex.Replace(\n    input: \"这篇文章包含TMD敏感词\", \n    pattern: @\"TMD|MMP\", \n    replacement: \"***\", \n    options: RegexOptions.IgnoreCase\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e\u003cstrong\u003e15 其他\u003c/strong\u003e\u003c/h2\u003e\n\u003ch3\u003e\u003cstrong\u003e打包软件\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e04.11项目  创建setup项目\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e打包好的软件；软件icon；  卸载软件msiexec.exe （C:\\Windows\\System32）\u003c/li\u003e\n\u003cli\u003e配置桌面快捷方式，并且配置icon；菜单快捷方式，并且配置icon；卸载的快捷方式，可配置icon；\u003c/li\u003e\n\u003cli\u003e卸载的参数要设置/x 软件代码；\u003c/li\u003e\n\u003cli\u003e配置对应的系统x86 x64\u003c/li\u003e\n\u003cli\u003e生成代码\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e\u003cstrong\u003e加密 混淆工具\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003evirboxprotector   virboxprotector_3.5.0.21419_windows\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"main\",null,{\"children\":[[\"$\",\"div\",null,{\"className\":\"border-b dark:bg-slate-800 bg-neutral-50 border-neutral-200\",\"children\":[\"$\",\"div\",null,{\"className\":\"container mx-auto px-5\",\"children\":[\"$\",\"div\",null,{\"className\":\"py-2 text-center text-sm\",\"children\":[\"The source code for this blog is\",\" \",[\"$\",\"a\",null,{\"href\":\"https://github.com/vercel/next.js/tree/canary/examples/blog-starter\",\"className\":\"underline hover:text-blue-600 duration-200 transition-colors\",\"children\":\"available on GitHub\"}],\".\"]}]}]}],[\"$\",\"div\",null,{\"className\":\"container mx-auto px-5\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"-ml-[8px] mb-16 tracking-tight\",\"children\":[\"$\",\"div\",null,{\"className\":\"lg:sticky lg:top-20\",\"children\":[\"$\",\"nav\",null,{\"className\":\"flex flex-row items-start relative px-0 pb-0 fade md:overflow-auto scroll-pr-6 md:relative\",\"id\":\"nav\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex flex-row space-x-0 pr-10\",\"children\":[[\"$\",\"$Le\",\"/\",{\"href\":\"/\",\"className\":\"transition-all hover:text-neutral-800 dark:hover:text-neutral-200 flex align-middle relative py-1 px-2 m-1 text-2xl\",\"children\":\"首页\"}],[\"$\",\"$Le\",\"/blog\",{\"href\":\"/blog\",\"className\":\"transition-all hover:text-neutral-800 dark:hover:text-neutral-200 flex align-middle relative py-1 px-2 m-1 text-2xl\",\"children\":\"博客\"}],[\"$\",\"$Le\",\"https://vercel.com/templates/next.js/portfolio-starter-kit\",{\"href\":\"https://vercel.com/templates/next.js/portfolio-starter-kit\",\"className\":\"transition-all hover:text-neutral-800 dark:hover:text-neutral-200 flex align-middle relative py-1 px-2 m-1 text-2xl\",\"children\":\"部署\"}]]}]}]}]}],[\"$\",\"h2\",null,{\"className\":\"text-2xl md:text-4xl font-bold tracking-tight md:tracking-tighter leading-tight mb-20 mt-8 flex items-center\",\"children\":[[\"$\",\"$Le\",null,{\"href\":\"/\",\"className\":\"hover:underline\",\"children\":\"Blog\"}],\".\"]}],[\"$\",\"article\",null,{\"className\":\"mb-32\",\"children\":[[[\"$\",\"h1\",null,{\"className\":\"text-5xl md:text-7xl lg:text-8xl font-bold tracking-tighter leading-tight md:leading-none mb-12 text-center md:text-left\",\"children\":\"C#笔记\"}],[\"$\",\"div\",null,{\"className\":\"hidden md:block md:mb-12\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex items-center\",\"children\":[[\"$\",\"img\",null,{\"src\":\"/assets/blog/authors/jj.jpeg\",\"className\":\"w-12 h-12 rounded-full mr-4\",\"alt\":\"JJ Kasper\"}],[\"$\",\"div\",null,{\"className\":\"text-xl font-bold\",\"children\":\"JJ Kasper\"}]]}]}],[\"$\",\"div\",null,{\"className\":\"mb-8 md:mb-16 sm:mx-0\",\"children\":[\"$\",\"div\",null,{\"className\":\"sm:mx-0\",\"children\":[\"$\",\"$Lf\",null,{\"src\":\"/assets/blog/dynamic-routing/cover.jpg\",\"alt\":\"Cover Image for C#笔记\",\"className\":\"shadow-sm w-full\",\"width\":1300,\"height\":630}]}]}],[\"$\",\"div\",null,{\"className\":\"max-w-2xl mx-auto\",\"children\":[[\"$\",\"div\",null,{\"className\":\"block md:hidden mb-6\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex items-center\",\"children\":[[\"$\",\"img\",null,{\"src\":\"/assets/blog/authors/jj.jpeg\",\"className\":\"w-12 h-12 rounded-full mr-4\",\"alt\":\"JJ Kasper\"}],[\"$\",\"div\",null,{\"className\":\"text-xl font-bold\",\"children\":\"JJ Kasper\"}]]}]}],[\"$\",\"div\",null,{\"className\":\"mb-6 text-lg\",\"children\":[\"$\",\"time\",null,{\"dateTime\":\"2020-03-16T05:35:07.322Z\",\"children\":\"March\\t16, 2020\"}]}]]}]],[\"$\",\"div\",null,{\"className\":\"max-w-2xl mx-auto\",\"children\":[\"$\",\"div\",null,{\"className\":\"markdown-styles-module__3QwRAG__markdown\",\"dangerouslySetInnerHTML\":{\"__html\":\"$10\"}}]}]]}]]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n"])</script><script>self.__next_f.push([1,"8:null\nc:[[\"$\",\"title\",\"0\",{\"children\":\"C#笔记 | Next.js Blog Example with Markdown\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"A statically generated blog example using Next.js and Markdown.\"}],[\"$\",\"meta\",\"2\",{\"property\":\"og:title\",\"content\":\"C#笔记 | Next.js Blog Example with Markdown\"}],[\"$\",\"meta\",\"3\",{\"property\":\"og:description\",\"content\":\"A statically generated blog example using Next.js and Markdown.\"}],[\"$\",\"meta\",\"4\",{\"property\":\"og:image\",\"content\":\"http://localhost:3000/assets/blog/dynamic-routing/cover.jpg\"}],[\"$\",\"meta\",\"5\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"6\",{\"name\":\"twitter:title\",\"content\":\"C#笔记 | Next.js Blog Example with Markdown\"}],[\"$\",\"meta\",\"7\",{\"name\":\"twitter:description\",\"content\":\"A statically generated blog example using Next.js and Markdown.\"}],[\"$\",\"meta\",\"8\",{\"name\":\"twitter:image\",\"content\":\"http://localhost:3000/assets/blog/dynamic-routing/cover.jpg\"}]]\n"])</script></body></html>